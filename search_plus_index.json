{"./":{"url":"./","title":"Introduction","keywords":"","body":" 主要记录 [x] python 基础 [x] python 文件处理 [x] python 正则表达式 [x] python 多进程，多线程 [x] python MongoDB数据库 [x] python 面向对象 Update time： 2020-06-12 "},"基础/":{"url":"基础/","title":"python 基础","keywords":"","body":"python 基础 Update time： 2020-05-25 "},"基础/Python Python 中的 if __name__ == '__main__'.html":{"url":"基础/Python Python 中的 if __name__ == '__main__'.html","title":"Python Python 中的 if name == 'main'","keywords":"","body":"Python Python 中的 if name == 'main' 程序入口 对于很多编程语言来说，程序都必须要有一个入口，比如 C，C++，以及完全面向对象的编程语言 Java，C# 等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，C 和 C++ 都需要有一个 main 函数来作为程序的入口，也就是程序的运行会从 main 函数开始。同样，Java 和 C# 必须要有一个包含 Main 方法的主类来作为程序入口。 而 Python 则有不同，它属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态的逐行解释运行。也就是从脚本第一行开始运行，没有统一的入口。 一个 Python 源码文件除了可以被直接运行外，还可以作为模块（也就是库）被导入。不管是导入还是直接运行，最顶层的代码都会被运行（Python 用缩进来区分代码层次）。而实际上在导入的时候，有一部分代码我们是不希望被运行的。 举一个例子来说明一下，假设我们有一个const.py文件，内容如下： PI = 3.14 def main(): print (\"PI:\", PI) mian() 我们在这个文件里边定义了一些常量，然后又写了一个 main 函数来输出定义的常量，最后运行 main 函数就相当于对定义做一遍人工检查，看看值设置的都对不对。然后我们直接执行该文件(python const.py),输出： PI: 3.14 现在，我们有一个area.py 文件，用于计算圆的面积，该文件里边需要用到 const.py 文件中的 PI 变量，那么我们从 const.py 中把 PI 变量导入到 area.py 中： from const import PI def calc_round_area(radius): return PI * (radius ** 2) def main(): print (\"round area: \", calc_round_area(2)) main() #输出： #PI: 3.14 #round area: 12.56 可以看到，const 中的 main 函数也被运行了，实际上我们是不希望它被运行，提供 main 也只是为了对常量定义进行下测试。这时，if __name__ == '__main__'就派上了用场。把 const.py 改一下： PI = 3.14 def main(): print (\"PI:\", PI) if __name__ == \"__main__\": main() 然后再运行 area.py，输出如下： round area: 12.56 再运行下 const.py，输出如下： PI: 3.14 if __name__ == '__main__'就相当于是 Python 模拟的程序入口。Python 本身并没有规定这么写，这只是一种编码习惯。由于模块之间相互引用，不同模块可能都有这样的定义，而入口程序只能有一个。到底哪个入口程序被选中，这取决于 __name__的值。 __name__ __name__是内置变量，用于表示当前模块的名字，同时还能反映一个包的结构。来举个例子，假设有如下一个包： a ├── b │ ├── c.py │ └── __init__.py └── __init__.py 目录中所有.py 文件的内容都为： print __name__ 我们执行python -c \"import a.b.c\"，输出结果： a a.b a.b.c __file__ 、__doc__的用法 __file__：当前文件路径 __doc__ ： 当前文件描述 #index.py ''' Create on XXXX @author:HHHH ''' print(__file__) print(__doc__) #打印 F:/CodeFile/Python1/file2/index.py Create on XXXX @author:HHHH Update time： 2020-05-25 "},"基础/Python 导入模块和package.html":{"url":"基础/Python 导入模块和package.html","title":"Python 导入模块和package","keywords":"","body":"Python 导入模块和package 模块：用来从逻辑上组织python代码(变量，函数，类)，本质上就是以.py结尾的python文件 package:本质上就是一个目录，但是必须带一个init.py的文件，它是用来从逻辑上组织模块的 import的本质是什么？ 导入模块的本质：就是把 python 文件拿来解释一遍 导入包的本质：就是执行该 package 下的 init.py 文件、 基础知识 当你import的时候，python只会在sys.path这个变量（一个list，你可以print出来看）里面的路径中找可能匹配的package和module。 而一个package跟一个普通文件夹的区别在于，package的文件夹中多了一个init.py文件。换句话说，如果你在某个文件夹中添加了一个init.py文件，则python就认为这个文件夹是一个package。 init.py文件可以是空的（也推荐者这么做），它只是告诉python当前文件夹是一个package。当然，也可以在里面添加一些代码，这些代码会在import这个包的时候运行。 所以，请确保你要import的文件所在的文件夹有init.py文件（除非它在sys.path中某个文件夹下）。 如果我现在有一个这样的目录： 在bin文件目录下的hello.py内容是: def hello(): print('i am in bin dir') 在Day5文件目录下的hello.py内容是: def hello(): print('i am in Day5 dir') 在pythonFile文件目录下的hello.py内容是: def hello(): print('i am in pythonFile dir') 如果我现在在bin目录下的 test.py 下写入 import hello hello.hello() 会出现的结果是什么呢？ i am in bin dir 是的确实是这样的。但是为什么呢？ 这个需要提及到环境变量的问题，我们可以看看当前文件所处的环境变量到底里面有什么？ 使用下面的语句： import sys, os print('--------') for path in sys.path: print(path) print('--------') 其中sys.path是所有环境变量的所构成的列表， -------- D:\\0 sty file\\myCode\\pythonFile\\Day5\\bin D:\\0 sty file\\myCode\\pythonFile C:\\ProgramData\\Anaconda3\\python36.zip C:\\ProgramData\\Anaconda3\\DLLs C:\\ProgramData\\Anaconda3\\lib C:\\ProgramData\\Anaconda3 C:\\ProgramData\\Anaconda3\\lib\\site-packages C:\\ProgramData\\Anaconda3\\lib\\site-packages\\Babel-2.5.0-py3.6.egg C:\\ProgramData\\Anaconda3\\lib\\site-packages\\win32 C:\\ProgramData\\Anaconda3\\lib\\site-packages\\win32\\lib C:\\ProgramData\\Anaconda3\\lib\\site-packages\\Pythonwin -------- 导入模块和package时候，我们的程序会从这个sys.path中从前到后寻找这些目录下有没有我们要找的模块，可以看见D:\\0 sty file\\myCode\\pythonFile\\Day5\\bin是在第一个的所有我们直接导入hello模块。python找到的D:\\0 sty file\\myCode\\pythonFile\\Day5\\bin里面的hello.py找到之后，就不找了，然后打印出来了。 导入的问题来了 现在问题来了，我现在就想要导入D:\\0 sty file\\myCode\\pythonFile\\Day5下面的hello，那我应该怎么办？ 我们知道在 python 中我们可以找到当前文件所在目录的父目录，然后将他加入到运行环境时候的环境变量中去，注意是运行环境中的，因为在当前python文件运行结束后，这个环境变量就释放了。 import sys, os # 导入系统模块 print(os.path.abspath(__file__)) #打印当前文件所处的绝对路径 print(os.path.dirname(os.path.abspath(__file__))) #打印当前文件所处的上级目录 # 打印当前文件所处的上级目录的父目录 print( os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) # Outputs: # D:\\0 sty file\\myCode\\pythonFile\\Day5\\bin\\test.py # D:\\0 sty file\\myCode\\pythonFile\\Day5\\bin # D:\\0 sty file\\myCode\\pythonFile\\Day5 然后我们就可以在写下如下的代码: BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) sys.path.append(BASE_DIR) # 将BASE_DIR加入到系统环境变量 我们将当前文件所在目录的父目录加入到环境变量中去，然后我们在打印下sys.path得到： -------- D:\\0 sty file\\myCode\\pythonFile\\Day5\\bin D:\\0 sty file\\myCode\\pythonFile C:\\ProgramData\\Anaconda3\\python36.zip C:\\ProgramData\\Anaconda3\\DLLs C:\\ProgramData\\Anaconda3\\lib C:\\ProgramData\\Anaconda3 C:\\ProgramData\\Anaconda3\\lib\\site-packages C:\\ProgramData\\Anaconda3\\lib\\site-packages\\Babel-2.5.0-py3.6.egg C:\\ProgramData\\Anaconda3\\lib\\site-packages\\win32 C:\\ProgramData\\Anaconda3\\lib\\site-packages\\win32\\lib C:\\ProgramData\\Anaconda3\\lib\\site-packages\\Pythonwin D:\\0 sty file\\myCode\\pythonFile\\Day5 -------- Update time： 2020-05-25 "},"基础/Python args和kwargs的用法.html":{"url":"基础/Python args和kwargs的用法.html","title":"Python args和kwargs的用法","keywords":"","body":"Python args和kwargs的用法 *args *args用来将参数打包成tuple给函数体调用 def function(*args): print(args, type(args)) function(1) #(1,) def function(x, y, *args): print(x, y, args) function(1, 2, 3, 4, 5) #1 2 (3, 4, 5) **kwargs **kwargs打包关键字参数成 dict 给函数体调用 def function(**kwargs): print( kwargs, type(kwargs)) function(a=2) #{'a': 2} def function(**kwargs): print(kwargs) function(a=1, b=2, c=3) #{'a': 1, 'b': 2, 'c': 3} 实际应用中，按照解压序列进行参数传递 打包 打包就是将传递给函数的任意多个（也可以是零个）非关键字参数/关键字参数打包成一个元组/字典（元组只能接收非关键字参数，字典只能接收关键字参数） 元组打包的例子 #!/usr/bin/env python #coding=utf-8 def tuple_pack(a, *b): print(a) print(b) tuple_pack(1,2,3,4,5) 1 (2,3,4,5) 在该例子中，*b这个位置可以接收任意多个（也可以是零个）非关键字参数，并将收集到的参数转换成一个元组。 字典打包的例子 def dictionary_pack(a, **b): print(a) print(b) dictionary_pack(1,one=1,two=2,three=3,four=4) 1 {'four':4，'one':2,'three':4,'two':3} 在该例子中，**b 这个位置可以接收任意多个（也可以是零个）关键字参数，并将收集到的参数转换成一个字典。 元组和字典混合的例子 def tuple_dictionary_pack(*a, **b): print(a) print(b) tuple_dictionary_pack(1,2,3,one=2,two=2) (1,2,3) {'one':4,'two':5} 拆解 拆解就是将传递给函数的一个列表、元组或字典拆分成独立的多个元素然后赋值给函数中的参变量（包括普通的位置参数，关键字参数，元组也即*非关键字参数，字典也即**关键字参数）。 在解字典时会有两种解法，一种使用*解，解出来传给函数的只有键值（.key）另一种是用**解，解出来的是字典的每一项。 位置变量和元组混合拆解的例子 #!/usr/bin/env python #coding=utf-8 def variable_tuple_unpack(a,b,c,*d): print(c) print(d) ee = [1,2,3,4,5] variable_tuple_unpack(*ee) 输出的结果是： 3 (4,5) 元组和字典混合的例子 #!/usr/bin/env python #coding=utf-8 def tuple_dictionary_unpack(*a,**b): print(a) print(b) ee = (1,2,3) ff = {'one':1,'two':2,'three':3} tuple_dictionary_unpack(*ee,**ff) (1,2,3) {'one':1,'three':3,'two':2} 字典的键值解成元组的例子 #!/usr/bin/env python #coding=utf-8 def tuple_dictionary(*a): print(a) ff = {'one':1,'two':2,'three':3} tuple_dictionary(*ff) ('one','three','two') print(*ff) #('one', 'two', 'three') Update time： 2020-05-25 "},"基础/Python 常用函数.html":{"url":"基础/Python 常用函数.html","title":"Python 常用函数","keywords":"","body":"Python 常用函数 lambda函数 Python 中，lambda 函数也叫匿名函数，及即没有具体名称的函数，它允许快速定义单行函数，类似于 C 语言的宏，可以用在任何需要函数的地方。 lambda 与 def 的区别： def 创建的方法是有名称的，而 lambda 没有。 lambda会返回一个函数对象，但这个对象不会赋给一个标识符，而 def 则会把函数对象赋值给一个变量（函数名）。 lambda 只是一个表达式，而def则是一个语句。 lambda 表达式” : “后面，只能有一个表达式，def 则可以有多个。 像 if 或 for 或 print 等语句不能用于 lambda 中，def 可以。 lambda 一般用来定义简单的函数，而def可以定义复杂的函数。 lambda 函数不能共享给别的程序调用，def可以。 lambda 语法格式： lambda 变量 : 要执行的语句 lambda [arg1 [, agr2,.....argn]] : expression lambda表达式中，冒号前面是参数，可以有多个，用逗号分隔，冒号右边是返回值。 # 1、单个参数的： >>> g = lambda x : x ** 2 >>> print g(3) #2、多个参数的： >>> g = lambda x, y, z : (x + y) ** z >>> print g(1,2,2) lambda表达式会返回一个函数对象，如果没有变量接受这个返回值的话，它很快就会被丢弃。也正是由于lambda只是一个表达式，所以它可以直接作为list和dict的成员。如： >>> list_a = [lambda a: a**3, lambda b: b**3] >>> list_a[0] at 0x0259B8B0> >>> g = list_a[0] >>> g(2) 8 map函数 map(func, *iterables) --> map object 参数function传的是一个函数名，可以是python内置的，也可以是自定义的。 参数iterable传的是一个可以迭代的对象，例如列表，元组，字符串这样的。 处理序列中的的每个元素，得到的结果是一个‘列表+’，该列表的元素个数及位置与原来的一样； a=(1,2,3,4,5) b=[1,2,3,4,5] la=map(lambda x:x+1,a) lb=map(lambda x:x**2,b) print(list(la)) print(list(lb)) 输出： [2, 3, 4, 5, 6] [1, 4, 9, 16, 25] filter函数 filter(function or None, iterable) --> filter object 对 sequence 中的 item 依次执行 function(item)，将执行结果为True的item组成一个list/String/Tuple（取决于sequence的类型）返回; people=[ {'name':'alex','age':24}, {'name':'hu','age':23}, {'name':'gu','age':18} ] print(list(filter(lambda p:p['age'] reduce函数 reduce(function, sequence[, initial]) -> value function – 函数，要有两个参数 iterable – 可迭代对象 initializer – 可选，初始参数 reduce() 函数即为化简函数，它的执行过程为：每一次迭代，都将上一次的迭代结果（注：第一次为 init 元素，如果没有指定 init 则为 seq 的第一个元素）与下一个元素一同传入二元 func 函数中去执行。在reduce()函数中，init 是可选的，如果指定，则作为第一次迭代的第一个元素使用，如果没有指定，就取seq中的第一个元素。 需要导入模块 from functools import reduce 从 reduce函数的执行过程，让我们很容易联想到求一个数的阶乘，而Python中并没有给出一个求阶乘的内置函数，正好我们就拿这个例子来说明reduce函数吧。 #未指定init的情况 >>> n = 6 >>> print reduce(lambda x, y: x * y, range(1, n)) 120 上面的例子中range(1,6)函数生成的是一个[1, 2, 3, 4, 5]这样的列表，这里我们给它个名叫seq1吧，reduce()函数执行时，由于没有指定init参数，所以将取seq1中的第一个元素1，作为第一个元素，由于前面的lambda有2个变量，所以需要两个实参，于是就取seq1中的第2个元素2，与第一个元素1一起传入lambda中去执行，并将返回结果2，并同下一个元素3再一起传入lambda中执行，再次返回的结果，作为下一次执行的第一个元素，依次类推，就得出结果5! = 120。 如果我们希望得到阶乘的结果再多增加几倍，可以启用init这个可选项。如： >>> print reduce(lambda x, y: x * y, range(1, n),2) 240 >>>def add(x, y) : # 两数相加 ... return x + y ... >>> reduce(add, [1,2,3,4,5]) # 计算列表和：1+2+3+4+5 15 >>> reduce(lambda x, y: x+y, [1,2,3,4,5]) # 使用 lambda 匿名函数 15 partial()偏函数 Python 偏函数是通过 functools 模块被用户调用。 偏函数 partial 应用 函数在执行时，要带上所有必要的参数进行调用。但是，有时参数可以在函数被调用之前提前获知。这种情况下，一个函数有一个或多个参数预先就能用上，以便函数能用更少的参数进行调用。 偏函数是将所要承载的函数作为partial()函数的第一个参数，原函数的各个参数依次作为partial()函数后续的参数，除非使用关键字参数。 对于整数 100，取得对于不同数 m 的 100%m 的余数。 from functools import partial def mod(n, m): return n % m mod_by_100 = partial(mod, 100) #100为mod的第一个参数 print(mod_by_100( 7 ) ) #打印 2 7作为mod的第二个参数 Update time： 2020-05-25 "},"基础/Python set集合的并集union, 交集intersection, 差集difference.html":{"url":"基础/Python set集合的并集union, 交集intersection, 差集difference.html","title":"Python set集合的并集union, 交集intersection, 差集difference","keywords":"","body":"Python set集合的并集union, 交集intersection, 差集difference python的集合set和其他语言类似，是一个无序不重复元素集, 可用于消除重复元素。 支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算。 不支持 indexing, slicing, 或其它类序列（sequence-like）的操作。因为，sets作为一个无序的集合，sets不记录元素位置或者插入点。 并集 >>> a=[1,3,5] >>> b=[1,2,3] >>> set(a) | set(b) set([1, 2, 3, 5]) # 或者 >>> set(a).union(b) set([1, 2, 3, 5]) 交集 >>> a=[1,3,5] >>> b=[1,2,3] >>> set(a) & set(b) set([1, 3]) >>> # 或者 >>> set(a).intersection(b) set([1, 3]) >>> 差集 >>> a=[1,3,5] >>> b=[1,2,3] >>> set(a) - set(b) set([5]) # 或者 >>> set(a).difference(b) set([5]) >>> 对称差集 返回两个集合中不重复的元素 >>> a=[1,3,5] >>> b=[1,2,3] >>> set(a) ^ set(b) set([2, 5]) # 或者 >>> set(a).symmetric_difference(b) set([2, 5]) >>> Update time： 2020-05-25 "},"基础/Python 列表解析式.html":{"url":"基础/Python 列表解析式.html","title":"Python 列表解析式","keywords":"","body":"Python 列表解析式 什么是列表解析式？ 列表解析式是将一个列表（实际上适用于任何可迭代对象（iterable））转换成另一个列表的工具。在转换过程中，可以指定元素必须符合一定的条件，才能添加至新的列表中，这样每个元素都可以按需要进行转换。 如果你熟悉函数式编程（functional programming），你可以把列表解析式看作为结合了filter函数与map函数功能的语法糖： >>> doubled_odds = map(lambda n: n * 2, filter(lambda n: n % 2 == 1, numbers)) >>> doubled_odds = [n * 2 for n in numbers if n % 2 == 1] 从循环到解析式 每个列表解析式都可以重写为for循环，但不是每个for循环都能重写为列表解析式。掌握列表解析式使用时机的关键，在于不断练习识别那些看上去像列表解析式的问题。 new_things = [] for ITEM in old_things: if condition_based_on(ITEM): new_things.append(\"something with \" + ITEM) # 列表解析式格式 new_things = [\"something with \" + ITEM for ITEM in old_things if condition_based_on(ITEM)] 嵌套循环 那么嵌套循环（nested loop）又该怎样改写为列表解析式呢？ 下面是一个拉平（flatten）矩阵（以列表为元素的列表）的for循环： flattened = [] for row in matrix: for n in row: flattened.append(n) 下面这个列表解析式实现了相同的功能： flattened = [n for row in matrix for n in row] 如果要在列表解析式中处理嵌套循环，请记住for循环子句的顺序与我们原来for循环的顺序是一致的。 同样地原则也适用集合解析式（set comprehension）和字典解析式（dictionary comprehension）。 下面的代码将原有字典的键和值互换，从而创建了一个新的字典： flipped = {} for key, value in original.items(): flipped[value] = key 同样的代码可以改写为字典解析式： flipped = {value: key for key, value in original.items()} 可读性 你有没有发现上面的列表解析式读起来很困难？我经常发现，如果较长的列表解析式写成一行代码，那么阅读起来就非常困难。 不过，还好Python支持在括号和花括号之间断行。 列表解析式 List comprehension 断行前： doubled_odds = [n * 2 for n in numbers if n % 2 == 1] 断行后： doubled_odds = [ n * 2 for n in numbers if n % 2 == 1] ] Update time： 2020-05-25 "},"基础/Python list中append和extend函数区别.html":{"url":"基础/Python list中append和extend函数区别.html","title":"Python list中append和extend函数区别","keywords":"","body":"Python list中append和extend函数区别 append 和 extend 都是 python 内置函数，都有扩展列表的元素功能，但两者的扩展方式是不同的。 通过使用 ?list.append 命令查看append函数帮助文档 ?list.append Docstring: L.append(object) -> None -- append object to end Type: method_descriptor 通过 ?list.extend 命令查看extend函数帮助文档 ?list.extend Docstring: L.extend(iterable) -> None -- extend list by appending elements from the iterable Type: method_descriptor 可以看出两者区别：append函数直接将object整体当作一个元素追加到列表中，而extend函数则是将可迭代对象中的元素逐个追加到列表中。 In [1]: lt1=['A','B','C'] ...: lt2=['D','E','F'] ...: lt1.append(lt2)#将lt2整体当作一个元素追加到到lt1中 ...: print(lt1) ...: lt3=['A','B','C'] ...: lt2=['D','E','F'] ...: lt3.extend(lt2)#将lt2中每个元素逐个追加到t3中 ...: print(lt3) ...: ['A', 'B', 'C', ['D', 'E', 'F']] ['A', 'B', 'C', 'D', 'E', 'F'] Update time： 2020-05-25 "},"基础/Python zip函数.html":{"url":"基础/Python zip函数.html","title":"Python zip()函数","keywords":"","body":"Python zip()函数 zip([iterable, ...]) zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。 若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。利用 *号操作符，可以将list unzip（解压），看下面的例子就明白了： a = [1,2,3] b = [4,5,6] c = [4,5,6,7,8] [x for x in zip(a,b)] # [(1, 4), (2, 5), (3, 6)] [*zip(a,b)] # [(1, 4), (2, 5), (3, 6)] [x for x in zip(a,c)] # [(1, 4), (2, 5), (3, 6)] Update time： 2020-05-25 "},"基础/Python enumerate函数.html":{"url":"基础/Python enumerate函数.html","title":"Python enumerate()函数","keywords":"","body":"Python enumerate()函数 enumerate() 是python的内置函数 enumerate 在字典上是枚举、列举的意思 enumerate(sequence, start=0) ，返回一个枚举对象。sequence 必须是序列或迭代器 iterator，或者支持迭代的对象。 enumerate() 返回对象的每个元素都是一个元组，每个元组包括两个值，一个是计数，一个是 sequence 的值，计数是从start开始的，start默认为0。 a=[\"q\",\"w\",\"e\",\"r\"] c=enumerate(a) for i in c: print(i) 输出： (0, 'q') (1, 'w') (2, 'e') (3, 'r') 对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值 enumerate多用于在for循环中得到计数 enumerate()使用 如果对一个列表，既要遍历索引又要遍历元素时 list1 = [\"这\", \"是\", \"一个\", \"测试\"] for index, item in enumerate(list1): print( index, item) >>> 0 这 1 是 2 一个 3 测试 enumerate还可以接收第二个参数，用于指定索引起始值，如： list1 = [\"这\", \"是\", \"一个\", \"测试\"] for index, item in enumerate(list1, 1): print index, item >>> 1 这 2 是 3 一个 4 测试 统计文件的行数 count = 0 for index, line in enumerate(open(filepath,'r'))： count += 1 Update time： 2020-05-25 "},"基础/Python random函数.html":{"url":"基础/Python random函数.html","title":"Python random函数","keywords":"","body":"Python random函数 该模块实现了各种分布的伪随机数生成器。 对于整数，从范围中有统一的选择。 对于序列，存在随机元素的统一选择、用于生成列表的随机排列的函数、以及用于随机抽样而无需替换的函数。 .random() random.random() 返回 [0.0, 1.0) 范围内的下一个随机浮点数。 .uniform() 返回一个随机浮点数 N ，当 a m1=random.uniform(2.5, 10.0) # Random float: 2.5 .randrange() #random.randrange(stop) m=random.randrange(10) # Integer from 0 to 9 inclusive print(m) #random.randrange(start, stop[, step]) m=random.randrange(0, 101, 3) # Even integer from 0 to 100 inclusive print(m) 补充：range()函数，其功能是创建一个整数列表 语法格式：range(start, stop, step)，参数使用参考如下： start: 计数从 start 开始。默认是从 0 开始。例如range（4）等价于range（0， 4）;结果：（0,1,2,3） stop : 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5 step ：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1) # random.randint(a, b) m=random.randint(1, 10) print(m) .choice() Choose a random element from a non-empty sequence. #random.choice(seq) m0=['hu','gu','gg'] m1=random.choice(m0) # 'hu' 从非空序列 seq 返回一个随机元素。 如果 seq 为空，则引发 IndexError。 andom.choices(population, weights=None, *, cum_weights=None, k=1) 从population中选择替换，返回大小为 k 的元素列表。 如果 population 为空，则引发 IndexError。 #random.choices(population, weights=None, *, cum_weights=None, k=1) # Six roulette wheel spins (weighted sampling with replacement) n=random.choices(['red', 'black', 'green'], [18, 18, 2], k=6) print(n) 输出：['black', 'red', 'black', 'red', 'red', 'red'] 如果指定了 weight 序列，则根据相对权重进行选择。 或者，如果给出 cum_weights 序列，则根据累积权重（可能使用 itertools.accumulate() 计算）进行选择。 例如，相对权重[10, 5, 30, 5]相当于累积权重[10, 15, 45, 50]。 在内部，相对权重在进行选择之前会转换为累积权重，因此提供累积权重可以节省工作量。 如果既未指定 weight 也未指定 cum_weights ，则以相等的概率进行选择。 如果提供了权重序列，则它必须与 population 序列的长度相同。 一个 TypeError 指定了 weights 和cum_weights。 weights 或 cum_weights 可以使用任何与 random() 返回的 float 值互操作的数值类型（包括整数，浮点数和分数但不包括十进制小数）。 对于给定的种子，具有相等加权的 choices() 函数通常产生与重复调用 choice() 不同的序列。 choices() 使用的算法使用浮点运算来实现内部一致性和速度。 choice() 使用的算法默认为重复选择的整数运算，以避免因舍入误差引起的小偏差。 .shuffle() 将序列 x 随机打乱位置。 deck = 'ace two three four'.split() random.shuffle(deck) # Shuffle a list print(deck) 可选参数 random 是一个0参数函数，在 [0.0, 1.0) 中返回随机浮点数；默认情况下，这是函数 random() 。 要改变一个不可变的序列并返回一个新的打乱列表，请使用sample(x, k=len(x))。 请注意，即使对于小的 len(x)，x 的排列总数也可以快速增长，大于大多数随机数生成器的周期。 这意味着长序列的大多数排列永远不会产生。 例如，长度为2080的序列是可以在 Mersenne Twister 随机数生成器的周期内拟合的最大序列。 .sample() andom.sample(population, k) 返回从总体序列或集合中选择的唯一元素的 k 长度列表。== 用于无重复的随机抽样==。 >>> sample([10, 20, 30, 40, 50], k=4) # Four samples without replacement [40, 10, 50, 30] 返回包含来自总体的元素的新列表，同时保持原始总体不变。 结果列表按选择顺序排列，因此所有子切片也将是有效的随机样本。 这允许抽奖获奖者（样本）被划分为大奖和第二名获胜者（子切片）。 总体成员不必是 hashable 或 unique 。 如果总体包含重复，则每次出现都是样本中可能的选择。 要从一系列整数中选择样本，请使用 range() 对象作为参数。 对于从大量人群中采样，这种方法特别快速且节省空间：sample(range(10000000), k=60) 。 如果样本大小大于总体大小，则引发 ValueError 。 验证码案例 import random def v_code(): ret='' for i in range(5): num=random.randint(0,9) alf=chr(random.randint(65,122)) s=str(random.choice([num,alf])) ret+=s return ret print(v_code()) Update time： 2020-05-25 "},"基础/Python sort函数、sorted函数.html":{"url":"基础/Python sort函数、sorted函数.html","title":"Python 字符串 sort()函数、sorted()函数","keywords":"","body":"Python 字符串 sort()函数、sorted()函数 sort 与 sorted 区别： sort 是应用在 list 上的方法，sorted可以对所有可迭代的对象进行排序操作。 list 的 sort 方法返回的是对已经存在的列表进行操作，返回值为None， 而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。 用 sort 函数对列表排序时会影响列表本身，而sorted不会。 >>> a = [1,2,1,4,3,5] >>> a.sort() >>> a [1, 1, 2, 3, 4, 5] >>> a = [1,2,1,4,3,5] >>> sorted(a) [1, 1, 2, 3, 4, 5] >>> a [1, 2, 1, 4, 3, 5] sort() sort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。 sort()方法语法： list.sort( key=None, reverse=False) 参数 key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中， 指定可迭代对象中的一个元素来进行排序。 reverse -- 排序规则，reverse = True 降序， reverse = False 升序（默认）。 返回值 该方法没有返回值，但是会对列表的对象进行排序。 # 获取列表的第二个元素 def takeSecond(elem): return elem[1] # 列表 random = [(2, 2), (3, 4), (4, 1), (1, 3)] # 指定第二个元素排序 random.sort(key=takeSecond) # 输出类别 print ('排序列表：', random) sorted() sorted 语法： sorted(iterable, key=None, reverse=False) 参数说明： iterable -- 可迭代对象。 key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中， 指定可迭代对象中的一个元素来进行排序。 reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。 返回值 返回重新排序的列表。 sorted 的第一个参数是一个迭代器，第二个参数是用来排序的key，第三个参数的排序数序：正序还是倒序 第一个参数是迭代器 >>> sorted([36, 5, -12, 9, -21]) [-21, -12, 5, 9, 36] 第二个参数是用来排序的 key >>> sorted([36, 5, -12, 9, -21], key=abs) # 绝对值 [5, 9, -12, -21, 36] key 指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs 处理过的 list： list = [36, 5, -12, 9, -21] keys = [36, 5, 12, 9, 21] 第三个参数决定正向还是反向排序： 要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True： >>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) ['Zoo', 'Credit', 'bob', 'about'] student_tuples = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)] new_tuples = sorted(student_tuples, key=lambda student: student[2]) print(student_tuples) print(new_tuples) 由于这种含有 key 参数的方法很普遍，所以 python 中提供了一些方法使得访问器函数更加方便。比如operator模块中的itemgetter(), attrgetter()方法。 from operator import itemgetter, attrgetter class Student: def __init__(self, name, grade, age): self.name = name self.grade = grade self.age = age student_objects = [Student('john', 'A', 15), Student('jane', 'B', 12), Student('dave', 'B', 10)] student_tuples = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10) ] result1 = sorted(student_tuples, key=itemgetter(2)) # 通过元素的第三个值排序 result2 = sorted(student_objects, key=attrgetter('age')) # 通过对象的age属性排序 result3 = sorted(student_tuples, key=itemgetter(1,2)) # 首先通过元素的第一个值排序，然后通过第二个值排序 result4 = sorted(student_objects, key=attrgetter('grade', 'age')) # 通过对象的grade属性排序，后通过age属性排序 排序是保证稳定可靠的，当排序的key对应的值相同时，会保持它们在原数据中的顺序，比sort里的第3个例子如以下代码运行结果： from operator import itemgetter data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)] print(sorted(data, key=itemgetter(0))) #[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)] sorted对字典进行排序 sorted(iterable,key,reverse)，sorted一共有iterable,key,reverse这三个参数。 对字典排序，可以根据key,进行排序，对value排序，需要用到key` 要按key值对字典排序，则可以使用如下语句： dic = {'c': 10, 'a': 8, 'b': '3'} sorted(dic.keys()) #结果：['a', 'b', 'c'] 直接使用sorted(d.keys())就能按key值对字典排序，这里是按照顺序对key值排序的，如果想按照倒序排序的话，则只要将reverse置为true即可。 sorted函数按value值对字典排序 要对字典的value排序则需要用到key参数，在这里主要提供一种使用lambda表达式的方法，如下： Update time： 2020-05-25 "},"基础/Python 字符串的格式化.html":{"url":"基础/Python 字符串的格式化.html","title":"Python 字符串的格式化","keywords":"","body":"Python 字符串的格式化 format() str.format() 函数，相比于 % 操作符，format函数使用{}和:代替了%，威力更加强大，在映射关系方面，format函数支持位置映射、关键字映射、对象属性映射、下标映射等多种方式，不仅参数可以不按顺序，也可以不用参数或者一个参数使用多次，下面通过几个例子来说明。 '{1} {0}'.format('abc', 123) # 可以不按顺序进行位置映射，输出'123 abc' '{} {}'.format('abc', 123) # 可以不指定参数名称，输出'abc 123' '{1} {0} {1}'.format('abc', 123) # 参数可以使用多次，输出'123 abc 123' '{name} {age}'.format(name='tom', age=27) # 可以按关键字映射，输出'tom 27' '{person.name} {person.age}'.format(person=person) # 可以按对象属性映射，输出'tom 27' '{0[1]} {0[0]}'.format(lst) # 通过下标映射 可以看到，format函数比%操作符使用起来更加方便，不需要记住太多各种占位符代表的意义，代码可读性也更高。在复杂格式控制方面，format函数也提供了更加强大的控制方式： 参考 f-string Python在3.6版本中也为我们带来了类似的功能：Formatted String Literals（字面量格式化字符串），简称f-string。 f-string就是以f’‘开头的字符串，类似u’‘和b’’，字符串内容和format方法中的格式一样，但是可以直接将变量带入到字符串中，可读性进一步增加，例如： amount = 1234 f'请转账给我{amount:,.2f}元' # '请转账给我1,234.00元' 同时，f-string的性能是比%和format都有提升的，我们做一个简单的测试，分别使用%操作符、format和f-string将下面语句执行10000次： 'My name is %s and i'm %s years old.' % (name, age) 'My name is {} and i'm {} years old.'.format(name, age) f'My name is {name} and i'm {age} years old.' 简单使用 f-string用大括号 {} 表示被替换字段，其中直接填入替换内容： >>> name = 'Eric' >>> f'Hello, my name is {name}' 'Hello, my name is Eric' >>> number = 7 >>> f'My lucky number is {number}' 'My lucky number is 7' >>> price = 19.99 >>> f'The price of this book is {price}' 'The price of this book is 19.99' 表达式求值与函数调用 f-string的大括号 {} 可以填入表达式或调用函数，Python会求出其结果并填入返回的字符串内： >>> f'A total number of {24 * 8 + 4}' 'A total number of 196' >>> f'Complex number {(2 + 2j) / (2 - 3j)}' 'Complex number (-0.15384615384615388+0.7692307692307692j)' >>> name = 'ERIC' >>> f'My name is {name.lower()}' 'My name is eric' >>> import math >>> f'The answer is {math.log(math.pi)}' 'The answer is 1.1447298858494002' 引号、大括号与反斜杠 f-string大括号内所用的引号不能和大括号外的引号定界符冲突，可根据情况灵活切换 ' 和 \"： >>> f'I am {\"Eric\"}' 'I am Eric' >>> f'I am {'Eric'}' File \"\", line 1 f'I am {'Eric'}' ^ SyntaxError: invalid syntax 若 ' 和 \" 不足以满足要求，还可以使用 ''' 和 \"\"\"： >>> f\"He said {\"I'm Eric\"}\" File \"\", line 1 f\"He said {\"I'm Eric\"}\" ^ SyntaxError: invalid syntax >>> f'He said {\"I'm Eric\"}' File \"\", line 1 f'He said {\"I'm Eric\"}' ^ SyntaxError: invalid syntax >>> f\"\"\"He said {\"I'm Eric\"}\"\"\" \"He said I'm Eric\" >>> f'''He said {\"I'm Eric\"}''' \"He said I'm Eric\" 大括号外的引号还可以使用 \\ 转义，但大括号内不能使用 \\ 转义： >>> f'''He\\'ll say {\"I'm Eric\"}''' \"He'll say I'm Eric\" >>> f'''He'll say {\"I\\'m Eric\"}''' File \"\", line 1 SyntaxError: f-string expression part cannot include a backslash f-string大括号外如果需要显示大括号，则应输入连续两个大括号 {{ 和 }}： >>> f'5 {\"{stars}\"}' '5 {stars}' >>> f'{{5}} {\"stars\"}' '{5} stars' 自定义格式：对齐、宽度、符号、补零、精度、进制等 f-string采用 {content:format} 设置字符串格式，其中 content 是替换并填入字符串的内容，可以是变量、表达式或函数等，format 是格式描述符。采用默认格式时不必指定 {:format}，如上面例子所示只写 {content} 即可。 对齐相关格式描述符 格式描述符 含义与作用 左对齐（字符串默认对齐方式） > 右对齐（数值默认对齐方式） ^ 居中 数字符号相关格式描述符 格式描述符 含义与作用 + 负数前加负号（-），正数前加正号（+） - 负数前加负号（-），正数前不加任何符号（默认） （空格） 负数前加负号（-），正数前加一个空格 注：仅适用于数值类型。 数字显示方式相关格式描述符 格式描述符 含义与作用 # 切换数字显示方式 注1：仅适用于数值类型。 注2：# 对不同数值类型的作用效果不同，详见下表： 宽度与精度相关格式描述符 格式描述符 含义与作用 width 整数 width 指定宽度 0width 整数 width 指定宽度，开头的 0 指定高位用 0 补足宽度 width.precision 整数 width 指定宽度，整数 precision 指定显示精度 注1：0width 不可用于复数类型和非数值类型，width.precision 不可用于整数类型。 注2：width.precision 用于不同格式类型的浮点数、复数时的含义也不同：用于 f、F、e、E 和 % 时 precision 指定的是小数点后的位数，用于 g 和 G 时 precision 指定的是有效数字位数（小数点前位数+小数点后位数）。 注3：width.precision 除浮点数、复数外还可用于字符串，此时 precision 含义是只使用字符串中前 precision 位字符。 >>> a = 123.456 >>> f'a is {a:8.2f}' 'a is 123.46' >>> f'a is {a:08.2f}' 'a is 00123.46' >>> f'a is {a:8.2e}' 'a is 1.23e+02' >>> f'a is {a:8.2%}' 'a is 12345.60%' >>> f'a is {a:8.2g}' 'a is 1.2e+02' >>> s = 'hello' >>> f's is {s:8s}' 's is hello ' >>> f's is {s:8.3s}' 's is hel ' 千位分隔符相关格式描述符 格式描述符 含义与作用 , 使用,作为千位分隔符 _ 使用_作为千位分隔符 注1：若不指定 , 或 ，则f-string不使用任何千位分隔符，此为默认设置。 注2：, 仅适用于浮点数、复数与十进制整数：对于浮点数和复数，, 只分隔小数点前的数位。 注3： 适用于浮点数、复数与二、八、十、十六进制整数：对于浮点数和复数， 只分隔小数点前的数位；对于二、八、十六进制整数，固定从低位到高位每隔四位插入一个 （十进制整数是每隔三位插入一个 _）。 >>> a = 1234567890.098765 >>> f'a is {a:f}' 'a is 1234567890.098765' >>> f'a is {a:,f}' 'a is 1,234,567,890.098765' >>> f'a is {a:_f}' 'a is 1_234_567_890.098765' >>> b = 1234567890 >>> f'b is {b:_b}' 'b is 100_1001_1001_0110_0000_0010_1101_0010' >>> f'b is {b:_o}' 'b is 111_4540_1322' >>> f'b is {b:_d}' 'b is 1_234_567_890' >>> f'b is {b:_x}' 'b is 4996_02d2' ........ 参考 Python格式化字符串f-string Update time： 2020-05-25 "},"基础/Python 字符串 String 函数.html":{"url":"基础/Python 字符串 String 函数.html","title":"Python 字符串 String 函数","keywords":"","body":"Python 字符串 String 函数 find() 函数 str.find(str, beg=0, end=len(string)) 参数 str -- 指定检索的字符串 beg -- 开始索引，默认为0。 end -- 结束索引，默认为字符串的长度。 返回值 如果包含子字符串返回开始的索引值，否则返回-1。 find() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。 str1 = \"this is string example....wow!!!\"; str2 = \"exam\"; print(str1.find(str2)) print(str1.find(str2, 10)) print(str1.find(str2, 40)) count() 函数 count(str, start=0, end=len(string)) 功能 返回该字符串中出现某字符串序列（或字符）的次数 用法 str.count(sub, start=0, end=len(string)) 参数 sub: 被查找的字符串序列 start: 开始查找的索引位置，默认为字符串开始 end: 结束查找的索引位置，默认为字符串结束 返回值 被查找的序列在字符串的查找位置中出现的次数 str = \"hello world! hello world!\" sub = \"o\" print(\"str.count(sub): \", str.count(sub)) #4 sub = \"hello\" print(\"str.count(sub, 5) \", str.count(sub, 5)) #1 index() 函数 index(str, start=0, end=len(string)) 功能 功能上与 find() 相同，只是在未找到子字符串是抛出异常 用法 str.index(str, start=0, end=len(string)) 参数 同 find() 返回值 如果查找到，返回该子字符串的索引；未查找到，抛出异常 str = \"hello world!\" str1 = \"wo\" print(str.index(str1)) #6 print(str.index(str1, 8)) # Traceback (most recent call last): # File \"teststrmethods.py\", line 6, in # print str.index(str1, 8) # ValueError: substring not found join() 函数 join(seq) 函数 功能 用该字符串连接某字符序列(seq) 用法 str.join(sequence) 参数 sequence: 被连接的字符序列 返回值 返回连接之后的字符串 str = \"-\" sequence = (\"hello\", \"world\", \"everyone\", \"!\") print(str.join(sequence)) #hello-world-everyone-! ljust函数 ljust(width, fillchar=’ ‘)函数 功能 在字符串的右边填充字符使得字符串达到指定长度 用法 str.ljust(width, fillchar=' ') 参数 width: 填充后的目标长度 fillchar: 用于填充的字符，默认为空格 返回值 返回填充后的字符串 print(str.ljust(15)) print(str.ljust(15,'!')) # Hello world # Hello world!!!! center() 函数 center(width, fillchar) 函数 将字符串居中，居中后的长度为 width 功能 将字符串居中，居中后的长度为 width 用法 str.center(width[, fillchar]) 参数 width: 表示字符串总长度 fillchar: 使字符串居中所填充的字符，默认为空格 返回值 返回填充字符后的字符串 str = \"hello world!\" print(\"str.center(20): \", str.center(20)) print(\"str.center(20,'-'): \", str.center(20,'-')) # str.center(20): hello world! # str.center(20,'-'): ----hello world!---- isalnum() 函数 功能 判断该字符串是否只是字母数字组合 用法 str.isalnum() 参数 无 返回值 如果该字符串是字母数字组合，返回 True,否则返回 False str = \"helloworld\" print(str.isalnum()) #True str = \"hello world\" print(str.isalnum()) #False str = \"hello123\" print(str.isalnum()) #True str = \"hello123!\" print(str.isalnum()) #False isalpha() 函数 功能 判断该字符串是否是字母组合 用法 str.isalpha() 参数 无 返回值 如果该字符串是字母组合，返回 True,否则返回 False str = \"helloworld\" print(str.isalpha()) #True str = \"hello world\" print(str.isalpha()) #False str = \"hello123\" print(str.isalpha()) #False str = \"hello123!\" print(str.isalpha()) #False isdigit() 函数 功能 判断该字符串是否只包含数字 用法 str.isdigit() 参数 无 返回值 如果该字符串只包含数字，则返回 True,否则返回 False str = \"hello123\" print(str.isdigit()) #False str = \"123456\" print(str.isdigit()) #True replace() 函数 功能 将字符串中的子字符串用某字符串来代替 用法 str.replace(old, new[, max]) 参数 old: 被替换的子字符串 new: 替换后的字符串 max: 需要替换的个数 返回值 返回替换后的字符串 str = \"this is a string, this is a string\" print(str.replace(\"is\", \"was\")) print(str.replace(\"is\", \"was\", 2)) # thwas was a string, thwas was a string # thwas was a string, this is a string split() 函数 功能 分割字符串 用法 str.split(str=\" \", num=string.cout(str)) 参数 str: 分隔符，默认是空格 num: 分割的次数，默认为按照分隔符分割整个字符串 返回值 返回分割后的 list str = \"word1 word2 word3 word4\" print(str.split()) print(str.split('r')) print(str.split(' ', 2)) # ['word1', 'word2', 'word3', 'word4'] # ['wo', 'd1 wo', 'd2 wo', 'd3 wo', 'd4'] # ['word1', 'word2', 'word3 word4'] splitlines() 函数 功能 将字符串按行分割 用法 str.splitlines(num=string.count('\\n')) 参数 num: 该数值如果不为0，表示分割后的字符串中保留\\n 返回值 返回分割后的 list str = \"line1\\nline2\\nline3\\nline4\" print(str.splitlines()) print(str.splitlines(0)) print(str.splitlines(3)) # ['line1', 'line2', 'line3', 'line4'] # ['line1', 'line2', 'line3', 'line4'] # ['line1\\n', 'line2\\n', 'line3\\n', 'line4'] lstrip() 函数 strip() 函数 startswith() 函数 功能 判断字符串是否是以某子字符串开头 用法 str.stratswith(str, start=0, end=len(str)) 参数 str: 被检查的子字符串 start: 检查的字符串的起始 index，默认为 str 的开始位置 end: 检查的字符串的结束 index，默认为 str 的终止位置 返回值 如果字符串是否是以某子字符串开头，返回True；否则返回False str = \"hello world!\" print(str.startswith('hel')) #True print(str.startswith('hel',2,8)) #False endswith() 函数 endswith(suffix, start=0, end=len(string)) 判断字符串是否是以某字符串结尾的 用法 str.endswith(suffix, start=0, end=len(string)) 参数 suffix: 被查找的字符串 start: 字符串查找的起始位置，默认为字符串起始位置 end: 字符串查找的结束位置，默认为字符串结束位置 返回值 如果字符串是以 suffix 结尾的返回 True, 否则返回 False str = \"hello world!\" suffix = \"world!\" print(str.endswith(suffix)) #True suffix = \"llo\" print(str.endswith(suffix,0,4)) #False print(str.endswith(suffix,0,5)) #True istitle() 函数 功能 检查该字符串中的`单词`是否首字母都大写 用法 str.istitle() 参数 无 返回值 如果该字符串中的单词首字母都大写了，返回True,否则返回False str = \"Hello world!\" print(str.istitle()) #False str = \"Hello Wolrd!\" print(str.istitle()) #True isupper() 函数 功能 判断该字符串中的字母是否都是大写 用法 str.isupper() 参数 无 返回值 如果该字符串中的字母都是大写，返回True,否则返回False str = \"Hello world!\" print(str.isupper()) #False str = \"HELLO WORLD!\" print(str.isupper()) #True islower() 函数 功能 判断该字符串中是否只是小写字母 用法 str.islower() 参数 无 返回值 如果该字符串中只是小写字母，返回True,否则返回False str = \"hello wolrd!\" print(str.islower()) #True str = \"Hello Wolrd!\" print(str.islower()) #False captalize() 函数 功能 将一个字符串的第一个字母大写 用法 str.captalize() 参数 无 返回值 string str = \"hello world!\" print(\"str.capitalize(): \", str.capitalize()) #str.capitalize(): Hello world! swapcase() 函数 功能 将字符串中的大小写字母转换 用法 str.swapcase() 参数 无 返回值 返回转换后的字符串 str = \"Hello World!\" print(str.swapcase()) #hELLO wORLD! upper() 函数 功能 将字符串中的字母都转换成大写 用法 str.upper() 参数 无 返回值 返回转换后的字符串## 标题 str = \"Hello World!\" print(str.upper()) #HELLO WORLD! lower() 函数 功能 将字符串中的字母转换为小写 用法 str.lower() 参数 无 返回值 字符串 #示例代码 str = \"HELLO WORLD!\" print (str.lower()) #hello world! Update time： 2020-05-25 "},"基础/Python partition函数.html":{"url":"基础/Python partition函数.html","title":"Python partition函数","keywords":"","body":"Python partition函数 描述 Python partition()方法用来根据指定的分隔符将字符串进行分割。 如果字符串包含指定的分隔符，则返回一个3元的元组，第一个为分隔符前面的子字符串，第二个为分隔符本身，第三个为分隔符后面的子字符串。 语法 partition() 方法语法： S.partition(sep) 参数 sep : 指定的分隔符。 返回值 返回一个3元的元组，第一个为分隔符前面的子字符串，第二个为分隔符本身，第三个为分隔符后面的子字符串。 实例 S = \"http://www.w3cschool.cc/\" print (S.partition(\"://\")) # ('http', '://', 'www.w3cschool.cc/') print (S.partition(\"/\")) # ('http:', '/', '/www.w3cschool.cc/') Update time： 2020-05-25 "},"基础/Python 位运算符、位运算高级运用.html":{"url":"基础/Python 位运算符、位运算高级运用.html","title":"Python 位运算符、位运算高级运用","keywords":"","body":"Python 位运算符、位运算高级运用 按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下： 下表中变量 a 为 60，b 为 13，二进制格式如下： a = 0011 1100 b = 0000 1101 ----------------- a&b = 0000 1100 a|b = 0011 1101 a^b = 0011 0001 ~a = 1100 0011 位运算高级运用 1. 判断奇偶数 如果把 n 以二进制的形式展示的话，其实我们只需要判断最后一个二进制位是 1 还是 0 就行了，如果是 1 的话，代表是奇数，如果是 0 则代表是偶数，所以采用位运算的方式的话，代码如下： if(n & 1 == 1){ // n 是个奇数。 } 2、交换两个数 交换两个数相信很多人天天写过，我也相信你每次都会使用一个额外来变量来辅助交换，例如，我们要交换 x 与 y 值，传统代码如下： int tmp = x; x = y; y = tmp; 万一哪天有人要为难你，不允许你使用额外的辅助变量来完成交换呢？你还别说，有人面试确实被问过，这个时候，位运算大法就来了。代码如下： x = x ^ y // （1） y = x ^ y // （2） x = x ^ y // （3） 两个相同的数异或之后结果会等于 0，即n ^ n = 0。并且任何数与 0 异或等于它本身，即 n ^ 0 = n。 把（1）中的 x 带入 （2）中的 x，有 y = x ^ y = (x ^ y) ^ y = x ^ (y ^ y) = x^0 = x。 x 的值成功赋给了 y。 对于（3）,推导如下： x = x ^ y = (x ^ y) ^ x = (x ^ x) ^ y = 0^y = y。 异或运算支持运算的交换律和结合律 3、找出没有重复的数 给你一组整型数据，这些数据中，其中有一个数只出现了一次，其他的数都出现了两次，让你来找出一个数 。 例如这组数据是：1， 2， 3， 4， 5， 1， 2， 3， 4。其中 5 只出现了一次，其他都出现了两次，把他们全部异或一下，结果如下： 由于异或支持交换律和结合律，所以: 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 1 ^ 2 ^ 3 ^ 4 = （1 ^ 1) ^ ( 2 ^ 2 ) ^ (3^ 3) ^ (4 ^ 4) ^ 5= 0 ^ 0 ^ 0 ^0 ^5 = 5。 def singleNumber3( nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" a = 0 for i in nums: a ^= i return a 4、m的n次方 如果让你求解 m 的 n 次方，并且不能使用系统自带的 pow 函数，你会怎么做呢？这还不简单，连续让 n 个 m 相乘就行了，代码如下： int pow(int n){ int tmp = 1; for(int i = 1; i 我举个例子吧，例如 n = 13，则 n 的二进制表示为 1101, 那么 m 的 13 次方可以拆解为: m ^ 1101 = m^0001 m^0100 m^1000。 我们可以通过 & 1和 >>1 来逐位读取 1101，为1时将该位代表的乘数累乘到最终结果。直接看代码吧，反而容易理解： int pow(int n){ int sum = 1; int tmp = m; while(n != 0){ if(n & 1 == 1){ sum *= tmp; } tmp *= tmp; n = n >> 1; } return sum; } 5、找出不大于N的最大的2的幂指数 传统的做法就是让 1 不断着乘以 2，代码如下： int findN(int N){ int sum = 1; while(true){ if(sum * 2 > N){ return sum; } sum = sum * 2; } } 例如 N = 19，那么转换成二进制就是 00010011（这里为了方便，我采用8位的二进制来表示）。那么我们要找的数就是，把二进制中最左边的 1 保留，后面的 1 全部变为 0。即我们的目标数是 00010000。那么如何获得这个数呢？相应解法如下： 1、找到最左边的 1，然后把它右边的所有 0 变成 1 2、把得到的数值加 1，可以得到 00100000即 00011111 + 1 = 00100000。 3、把 得到的 00100000 向右移动一位，即可得到 00010000，即 00100000 >> 1 = 00010000。 那么问题来了，第一步中把最左边 1 中后面的 0 转化为 1 该怎么弄呢？我先给出代码再解释吧。下面这段代码就可以把最左边 1 中后面的 0 全部转化为 1， n |= n >> 1; n |= n >> 2; n |= n >> 4; 就是通过把 n 右移并且做或运算即可得到。我们假设最左边的 1 处于二进制位中的第 k 位(从左往右数),那么把 n 右移一位之后，那么得到的结果中第 k+1 位也必定为 1,然后把 n 与右移后的结果做或运算，那么得到的结果中第 k 和 第 k + 1 位必定是 1;同样的道理，再次把 n 右移两位，那么得到的结果中第 k+2和第 k+3 位必定是 1,然后再次做或运算，那么就能得到第 k, k+1, k+2, k+3 都是 1，如此往复下去…. 最终的代码如下 int findN(int n){ n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8 // 整型一般是 32 位，上面我是假设 8 位。 return (n + 1) >> 1; } Update time： 2020-05-25 "},"基础/Python set集合之间的区别.html":{"url":"基础/Python set集合之间的区别.html","title":"Python set(集合) & 与 and 、 | 与 or之间的区别","keywords":"","body":"Python set(集合) & 与 and 、 | 与 or之间的区别 \"集合的交\" --- (a & b) \"集合的并\" --- (a | b) \"集合的差\" --- a & (~b) a = set([1, 2, 3, 4, 5]) b = set([4, 5, 6, 7, 8]) #求两个集合的交集 print(a & b) # {4, 5} print(a and b) # {4, 5, 6, 7, 8} #求两个集合的并集 print(a | b) #{1, 2, 3, 4, 5, 6, 7, 8} print(a or b) # {1, 2, 3, 4, 5} 主要的原因是 & ！= and , | != or python 中 & 、| 代表的是位运算符， and 、or代表的是逻辑运算符 ① 当 a and b的结果为True 的时候，返回的并不是True，而是 运算结果的最后一位变量的值。这里是 返回b的值 （b and a 为真 ，返回的是 a 的值）, 当a and b结果为False 的时候，返回的是第一个False 的值，如 a 和 b都为False 那么返回 a的 值 ，a 为 真， b 为假，那么返回的是 b的值 ②当 a or b 为真的时候，返回的是第一个真的变量的值，如，当a 和 b都为真，那么返回的是 a 若 a or b 假的时候，返回的是最后一个判断条件的值，这里返回的是 b 的值 所以上面的代码 a and b返回的是 b的值 {4, 5, 6, 7, 8} a or b 返回的则是 a 的值 {1, 2, 3, 4, 5, 6, 7, 8} 题目： 给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]: nums1=set(nums1) nums2=set(nums2) return list(nums1&nums2) Update time： 2020-05-25 "},"基础/Python round函数，截取小数位数.html":{"url":"基础/Python round函数，截取小数位数.html","title":"Python round函数，截取小数位数","keywords":"","body":"Python round函数，截取小数位数 在很多场景的计算中，最终得到的数值例如123.45678，要截取2位小数得到123.45，而不是默认的四舍五入方法得到123.46，如何实现呢？ round() round(number[, ndigits]) 描述： 返回 number 舍入到小数点后 ndigits 位精度的值。 如果 ndigits 被省略或为 None，则返回最接近输入值的整数。 当指定取舍的小数点位数的时候，一般情况也是使用四舍五入的规则，但是碰到.5的这样情况，如果要取舍的位数前的小树是奇数，则直接舍弃，如果偶数这向上取舍。 小数点后取2位（四舍五入）的方法 方法一：round（）函数 a = 1.23456 b = 2.355 c = 3.5 d = 2.5 print(round(a, 3)) print(round(b, 2)) print(round(c)) print(round(d)) 1.235 # 1.23456最终向前进位了 2.35 # 2.355居然没进位 4 # 最终3.5居然变为4了 2 # 最终2.5取值变为2 （1）通过上面的函数，看着是不是很晕，感觉round（x,n）函数是否进位也没看出是啥规律 （2）round（x,n）函数中，是否进位或四舍五入，取决于n位以及n+1位小数的值 （3）只有当n+1位数字是5的时候，容易混淆，如果n为偶数，则n+1位数是5，则进位，例如round（1.23456，3）最终变为1.235 （4）如果n为奇数，则n+1位是数5，那不进位，例如round（2.355，2），最终为2.35 （5）如果n为0，即没有填写n的时候，最终结果与上面相反，即整数部分为偶数的时候，小数位5不进位，例如（round（2.5）变为2）。 （6）整数部分为奇数的时候，小数位5进位。（round（3.5）变为4） 方法二：’%.2f’ %f 方法 f = 1.23456 print('%.4f' % f) print('%.3f' % f) print('%.2f' % f) 1.2346 1.235 1.23 （1）原本以为：这个方法是最常规的方法，方便实用，居家旅行必备！ （2）但是… f = 0.625 print('%.2f' % f) # 结果：0.62 方法三：Decimal（）函数 from decimal import Decimal aa = Decimal('5.026').quantize(Decimal('0.00')) bb = Decimal('3.555').quantize(Decimal('0.00')) cc = Decimal('3.545').quantize(Decimal('0.00')) print(aa) print(bb) print(cc) 5.03 3.56 3.54 小数点后取2位（四舍五不入）的方法 通过计算的途径，很难将最终结果截取2位，我们直接想到的就是如果是字符串，直接截取就可以了。 例如 num = '1234567' #字符串num print(num[:3]) 结果： 123 如果是123.456取2位小数（截取2位小数），值需要把小数点右边的当做字符串截取即可 partition() 函数（将字符串根据字符串切割）： num = '123.4567' num_str = num.partition(\".\") print(num_str) 结果： ('123', '.', '4567') # 三个元素的元祖 Update time： 2020-05-25 "},"基础/Python 断言assert.html":{"url":"基础/Python 断言assert.html","title":"Python 断言assert","keywords":"","body":"Python 断言assert 使用assert断言是个好习惯 在没完善一个程序之前，我们不知道程序在哪里会出错，与其让它在运行最崩溃，不如在出现错误条件时就崩溃，这时候就需要assert断言的帮助。 assert异常参数：在断言表达式后添加字符串信息，用来解释断言并更好的知道是哪里出了问题 assert用法 assert 表达式 [, 异常提示字符串] 示例如下： assert type(users) == list #断言users对象的类型为list assert len(users) >5 #断言users对象的元素个数大于5 assert异常时，会报AssertionError错误，其后会带上断言时的异常参数，这样方便排查出问题的地方。 Update time： 2020-05-25 "},"基础/Python chr和ord函数.html":{"url":"基础/Python chr和ord函数.html","title":"Python chr()和ord()函数","keywords":"","body":"Python chr()和ord()函数 Python中经常会获得一些字符串，但是我们在对其进行计算的时候需要先将其转化为整型数。 ord（） ord（）函数就是用来返回单个字符的ascii值（0-255）或者unicode数值（）。 >>> ord('d') 100 >>> ord('5') 53 chr（） chr（）函数是输入一个整数【0，255】返回其对应的ascii符号. >>> chr(100) 'd' >>> chr(53) '5' def formatStrToInt(target): for i in range(len(target)): temp=ord(target[i]) print temp, return formatStrToInt(\"abcdefghijk\") 结果如下： ============================================== 97 98 99 100 101 102 103 104 105 106 107 Update time： 2020-05-25 "},"基础/Python fnmatch模块.html":{"url":"基础/Python fnmatch模块.html","title":"Python fnmatch模块","keywords":"","body":"Python fnmatch模块 fnmatch主要是用来判断一个文件名是否匹配”Unix shell-style wildcards”这种模式,就是平常用的那种ls *.log这样，看是否匹配。 用法很简单，常用也就这两个函数fnmatch/filter: fnmatch. fnmatch(filename, pattern) 测试 filename 字符串是否匹配 pattern 字符串，返回 True 或 False。 通配符 含义 * 匹配任何数量的字符 ？ 匹配单个字符 [seq] 匹配 seq 中的字符 [!seq] 匹配除 seq 以外的任何的字符 fnmatch 这个库相对比较简单，只有4个函数，分别是fnmatch、fnmatchcase、filter和 translate，其中最常用的是fnmatch。主要功能如下： fnmatch：判断文件名是否符合特定的模式。 fnmatchcase：判断文件名是否符合特定的模式，区分大小写。 filter：返回输入列表中，符合特定模式的文件名列表。 translate：将通配符模式转换成正则表达式。 fnmatch和fnmatchcase用法相同，判断名称是否符合表达式，返回True or False >>> os.listdir(os.curdir) ['A1.jpg', 'a1.txt', 'a2.txt', 'aA.txt', 'b3.jpg', 'b2.jpg', 'b1.jpg'] >>> [ name for name in os.listdir(os.curdir) if fnmatch.fnmatch(name,'*.jpg') ] ['A1.jpg', 'b3.jpg', 'b2.jpg', 'b1.jpg'] >>> [ name for name in os.listdir(os.curdir) if fnmatch.fnmatch(name,\"[ab]*\") ] ['a1.txt', 'a2.txt', 'aA.txt', 'b3.jpg', 'b2.jpg', 'b1.jpg'] >>> [ name for name in os.listdir(os.curdir) if fnmatch.fnmatch(name,\"[!a]*\") ] ['A1.jpg', 'b3.jpg', 'b2.jpg', 'b1.jpg'] >>> [ name for name in os.listdir(os.curdir) if fnmatch.fnmatch(name,\"b?.jpg\") ] ['b3.jpg', 'b2.jpg', 'b1.jpg'] >>> [ name for name in os.listdir(os.curdir) if fnmatch.fnmatchcase(name,\"A?.jpg\") ] ['A1.jpg'] filter和fnmatch类似，只不过filter接受的第一个参数是一个文件名列表，返回符合表达式的列表(即：筛选) >>> name = os.listdir(os.curdir) >>> name ['A1.jpg', 'a1.txt', 'a2.txt', 'aA.txt', 'b3.jpg', 'b2.jpg', 'b1.jpg'] >>> fnmatch.filter(name,'*.txt') ['a1.txt', 'a2.txt', 'aA.txt'] Update time： 2020-05-25 "},"基础/Python copy模块.html":{"url":"基础/Python copy模块.html","title":"Python copy模块","keywords":"","body":"Python copy模块 引用 变量保存字符串和整数值。 >>> spam = 42 >>> cheese = spam >>> spam = 100 >>> spam 100 >>> cheese 42 将 42 赋给 spam 变量， 然后拷贝 spam 中的值， 将它赋给变量 cheese。当稍后将 spam 中的值改变为 100 时， 这不会影响 cheese 中的值。这是因为 spam 和 cheese是不同的变量， 保存了不同的值。 但列表不是这样的。 当你将列表赋给一个变量时，实际上是将列表的“引用”赋给了该变量。引用是一个值，指向某些数据。列表引用是指向一个列表的值。这里有一些代码，让这个概念更容易理解。 #1 >>> spam = [0, 1, 2, 3, 4, 5] #2 >>> cheese = spam #3 >>> cheese[1] = 'Hello!' >>> spam [0, 'Hello!', 2, 3, 4, 5] >>> cheese [0, 'Hello!', 2, 3, 4, 5] 当创建列表时1，你将对它的引用赋给了变量。但下一行2只是将 spam 中的列表引用拷贝到 heese，而不是列表值本身。这意味着存储在 spam 和 cheese 中的值，现在指向了同一个列表。底下只有一个列表，因为列表本身实际从未复制。所以当你修改 cheese 变量的第一个元素时3，也修改了 spam 指向的同一个列表。 变量包含对列表值的引用， 而不是列表值本身。但对于字符串和整数值， 变量就包含了字符串或整数值。在变量必须保存可变数据类型的值时， 例如列表或字典，Python 就使用引用。对于不可变的数据类型的值， 例如字符串、 整型或元组， Python变量就保存值本身。 虽然 Python 变量在技术上包含了对列表或字典值的引用，但人们通常随意地说，该变量包含了列表或字典。 copy 模块 copy()和 deepcopy()函数 在处理列表和字典时，尽管传递引用常常是最方便的方法， 但如果函数修改了传入的列表或字典， 你可能不希望这些变动影响原来的列表或字典。要做到这一点，Python 提供了名为copy 的模块， 其中包含copy()和 deepcopy()函数。 copy.copy() 第一个函数copy.copy()， 可以用来复制列表或字典这样的可变值， 而不只是复制引用。在交互式环境中输入以下代码 >>> import copy >>> spam = ['A', 'B', 'C', 'D'] >>> cheese = copy.copy(spam) >>> cheese[1] = 42 >>> spam ['A', 'B', 'C', 'D'] >>> cheese ['A', 42, 'C', 'D'] 现在 spam 和 cheese 变量指向独立的列表， 这就是为什么当你将 42 赋给下标 7时， 只有 cheese 中的列表被改变。 copy.deepcopy() 如果要复制的列表中包含了列表， 那就使用 copy.deepcopy()函数来代替 deepcopy()函 数将同时复制它们内部的列表。 Update time： 2020-05-25 "},"基础/Python collections模块.html":{"url":"基础/Python collections模块.html","title":"Python collections模块","keywords":"","body":"Python collections模块 Python作为一个“内置电池”的编程语言，标准库里面拥有非常多好用的模块。比如今天想给大家 介绍的 collections就是一个非常好的例子。 基本介绍 Python拥有一些内置的数据类型，比如str, int, list, tuple, dict等， collections模块在这些内置数据类型的基础上，提供了几个额外的数据类型： namedtuple(): 生成可以使用名字来访问元素内容的tuple子类 deque: 双端队列，可以快速的从另外一侧追加和推出对象 Counter: 计数器，主要用来计数 OrderedDict: 有序字典 defaultdict: 带有默认值的字典 namedtuple() Python 中存储系列数据，比较常见的数据类型有 list，除此之外，还有 tuple 数据类型。相比与list，tuple 中的元素不可修改，在映射中可以当键使用。tuple 元组的 item 只能通过 index 访问， collections 模块的 namedtuple 子类不仅可以使用 item 的 index 访问 item，还可以通过 item的 name 进行访问。可以将 namedtuple 理解为 c 中的 struct 结构，其首先将各个 item 命名，然后对每个 item 赋予数据。 coordinate = namedtuple('Coordinate', ['x', 'y']) co = coordinate(10,20) print (co.x,co.y) print (co[0],co[1]) # 也可以通过一个list来创建一个User对象，这里注意需要使用\"_make\"方法 co = coordinate._make([100,200]) print (co.x,co.y) co = co._replace(x = 30) print (co.x,co.y) 10 20 10 20 100 200 30 200 from collections import namedtuple websites = [ ('Sohu', 'http://www.google.com/', u'张朝阳'), ('Sina', 'http://www.sina.com.cn/', u'王志东'), ('163', 'http://www.163.com/', u'丁磊') ] Website = namedtuple('Websites', ['name', 'url', 'founder']) # Website 对象名 # 参数'Websites': Websites(name='Sohu', url='http://www.google.com/', founder='张朝阳') # 指打印显示的名字 for website in websites: website = Website._make(website) print(website) ''' Websites(name='Sohu', url='http://www.google.com/', founder='张朝阳') Websites(name='Sina', url='http://www.sina.com.cn/', founder='王志东') Websites(name='163', url='http://www.163.com/', founder='丁磊') ''' print(website.name, website.url, website.founder) ''' Sohu http://www.google.com/ 张朝阳 Sina http://www.sina.com.cn/ 王志东 163 http://www.163.com/ 丁磊 ''' deque () deque 是一个双端队列, 如果要经常从两端 append 的数据, 选择这个数据结构就比较好了, 如果要实现随机访问,不建议用这个,请用列表. deque 优势就是可以从两边append , appendleft 数据. 这一点list 是没有的. 指定队列长度 from collections import deque # 可以指定 队列的长度 mydeque = deque(maxlen=10) print(mydeque.maxlen) # 10 从两端添加元素 # 默认从右边加入 mydeque.append(10) mydeque.append(12) print(mydeque) # deque([10, 12], maxlen=10) # 也可以从左边加入 mydeque.appendleft('a') mydeque.appendleft('b') mydeque.appendleft('c') print(mydeque) # deque(['c', 'b', 'a', 10, 12], maxlen=10) 取队列元素 # 出队列,返回出队列的元素 # 可以从左边也可以从右边 出队列 mydeque.pop() mydeque.popleft() 查看队列元素个数 # 查看 队列里面元素个数 print(len(mydeque)) 统计元素的个数 # 统计元素的个数 #统计a 有几个 print(mydeque.count('a')) 在某个位置insert一个元素 # insert(i, x) # Insert x into the deque at position i. d1 Out[31]: deque([10, 12, 13, 14]) d1.insert(2,'frank') d1 Out[33]: deque([10, 12, 'frank', 13, 14]) 翻转操作 #翻转操作 # deque.reverse() mydeque Out[52]: deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) mydeque.reverse() mydeque Out[54]: deque([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) remove 移除某个元素 mydeque Out[23]: deque(['e', 'd', 'c', 'b', 'a', 10, 12]) mydeque.remove(10) mydeque Out[25]: deque(['e', 'd', 'c', 'b', 'a', 12]) 清空队列元素 clear mydeque Out[46]: deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) mydeque.clear Out[47]: mydeque.clear() mydeque Out[49]: deque([]) rotate 方法 移动到最后一个，占用第一个位置，循环移动， value 是步长, rotate（value) 对队列实行旋转操作（每个元素依次向后移动value步，最后一个移动到第一个算一步） from collections import deque d = deque() d.extend(['a', 'b', 'c', 'd', 'e']) d.rotate(2) # 指定次数，默认1次 print(d) # deque(['d', 'e', 'a', 'b', 'c']) maxlen要说明一下, 如果指定了 maxlen 如果构建deque 的时候,指定了maxlen, 则可以通过 d.maxlen 来获得dueue的最大长度. 如果插入的数据大于 maxlen 则会自动删除旧的元素.删除 什么元素,取决于, 从哪边添加数据 d = deque(list(range(5)),maxlen=5) d Out[21]: deque([0, 1, 2, 3, 4]) d.maxlen Out[26]: 5 # 从左边添加元素, # 元素4 被挤出 队列 d.appendleft('frank') d Out[23]: deque(['frank', 0, 1, 2, 3]) # 从右边添加元素, 元素 'frank' 被挤出队列. d Out[23]: deque(['frank', 0, 1, 2, 3]) d.append('xiaoming') d Out[25]: deque([0, 1, 2, 3, 'xiaoming']) 参考： https://blog.csdn.net/u010339879/article/details/80767293 Counter() Counter类的目的是用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value。计数值可以是任意的Interger（包括0和负数） Counter类创建的四种方法： >>> c = Counter() # 创建一个空的Counter类 >>> c = Counter('gallahad') # 从一个可iterable对象（list、tuple、dict、字符串等）创建 >>> c = Counter({'a': 4, 'b': 2}) # 从一个字典对象创建 >>> c = Counter(a=4, b=2) # 从一组键值对创建 计数值的访问与缺失的键 当所访问的键不存在时，返回0，而不是KeyError；否则返回它的计数。 >>> c = Counter(\"abcdefgab\") >>> c[\"a\"] 2 >>> c[\"c\"] 1 >>> c[\"h\"] 0 计数器的更新（update和subtract） 可以使用一个iterable对象或者另一个Counter对象来更新键值。 计数器的更新包括增加和减少两种。其中，增加使用update()方法： >>> c = Counter('which') >>> c.update('witch') # 使用另一个iterable对象更新 >>> c['h'] 3 >>> d = Counter('watch') >>> c.update(d) # 使用另一个Counter对象更新 >>> c['h'] 4 减少则使用subtract()方法： >>> c = Counter('which') >>> c.subtract('witch') # 使用另一个iterable对象更新 >>> c['h'] 1 >>> d = Counter('watch') >>> c.subtract(d) # 使用另一个Counter对象更新 >>> c['a'] -1 键的删除 当计数值为0时，并不意味着元素被删除，删除元素应当使用del >>> c = Counter(\"abcdcba\") >>> c Counter({'a': 2, 'c': 2, 'b': 2, 'd': 1}) >>> c[\"b\"] = 0 >>> c Counter({'a': 2, 'c': 2, 'd': 1, 'b': 0}) >>> del c[\"a\"] >>> c Counter({'c': 2, 'b': 2, 'd': 1}) elements() 返回一个迭代器。元素被重复了多少次，在该迭代器中就包含多少个该元素。元素排列无确定顺序，个数小于1的元素不被包含。 >>> c = Counter(a=4, b=2, c=0, d=-2) >>> list(c.elements()) ['a', 'a', 'a', 'a', 'b', 'b'] most_common([n]) most_common(n)按照 counter 的计数，按照降序，返回前 n 项组成的list; n 忽略时返回全部 返回一个 TopN 列表。如果 n 没有被指定，则返回所有元素。当多个元素计数值相同时，排列是无确定顺序的。 >>> c = Counter('abracadabra') >>> c.most_common() [('a', 5), ('r', 2), ('b', 2), ('c', 1), ('d', 1)] >>> c.most_common(3) [('a', 5), ('r', 2), ('b', 2)] 算术和集合操作 +、-、&、|操作也可以用于Counter。其中&和|操作分别返回两个Counter对象各元素的最小值和最大值。需要注意的是，得到的Counter对象将删除小于1的元素。 >>> c = Counter(a=3, b=1) >>> d = Counter(a=1, b=2) >>> c + d # c[x] + d[x] Counter({'a': 4, 'b': 3}) >>> c - d # subtract（只保留正数计数的元素） Counter({'a': 2}) >>> c & d # 交集: min(c[x], d[x]) Counter({'a': 1, 'b': 1}) >>> c | d # 并集: max(c[x], d[x]) Counter({'a': 3, 'b': 2}) 其他 常见做法: sum(c.values()) 继承自字典的.values()方法返回values的列表，再求和 c.clear() 继承自字典的.clear()方法，清空counter list(c) 返回key组成的list set(c) 返回key组成的set dict(c) 转化成字典 c.items() 转化成(元素，计数值)组成的列表 Counter(dict(list_of_pairs)) 从(元素，计数值)组成的列表转化成Counter c.most_common()[:-n-1:-1] 最小n个计数的(元素，计数值)组成的列表 c += Counter() 利用counter的相加来去除负值和0的值 列表元素去重 给定列表 list1 = [1,2,2,3,4,4,6,5,6,7,9]: from collections import Counter list1 = [1,2,2,3,4,4,6,5,6,7,9] list(Counter(list1)) # [1, 2, 3, 4, 6, 5, 7, 9] 题目 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 import collections class Solution2(object): def majorityElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" return [k for k, v in collections.Counter(nums).items() if v>len(nums)//2][0] OrderedDict() Python中的字典对象可以以“键：值”的方式存取数据。OrderedDict 是它的一个子类，实现了对字典对象中元素的排序。 import collections print('Regular dictionary:') d={} d['a']='A' d['b']='B' d['c']='C' for k,v in d.items(): print( k,v) print( '\\nOrderedDict:') d=collections.OrderedDict() d['a']='A' d['b']='B' d['c']='C' for k,v in d.items(): print( k,v) Regular dictionary: a A c C b B OrderedDict: a A b B c C 可以看到，同样是保存了ABC三个元素，但是使用OrderedDict会根据放入元素的先后顺序进行排序。由于进行了排序，所以OrderedDict对象的字典对象，如果其顺序不同那么Python也会把他们当做是两个不同的对象，比如下面的代码： import collections print('Regular dictionary:') d1={} d1['a']='A' d1['b']='B' d1['c']='C' d2={} d2['c']='C' d2['a']='A' d2['b']='B' print(d1==d2) print('\\nOrderedDict:') d1=collections.OrderedDict() d1['a']='A' d1['b']='B' d1['c']='C' d2=collections.OrderedDict() d2['c']='C' d2['a']='A' d2['b']='B' print(d1==d2) Regular dictionary: True OrderedDict: False .fromkeys() (指定一个列表，把列表中的值作为字典的key,生成一个字典) import collections dic = collections.OrderedDict() name = ['tom','lucy','sam'] print(dic.fromkeys(name)) print(dic.fromkeys(name,20)) #输出：OrderedDict([('tom', None), ('lucy', None), ('sam', None)]) # OrderedDict([('tom', 20), ('lucy', 20), ('sam', 20)]) .items() (返回由“键值对组成元素“的元组列表) import collections dic = collections.OrderedDict() dic['k1'] = 'v1' dic['k2'] = 'v2' print(dic.items()) #输出：odict_items([('k1', 'v1'), ('k2', 'v2')]) .keys() (获取字典所有的key,返回一个列表) import collections dic = collections.OrderedDict() dic['k1'] = 'v1' dic['k2'] = 'v2' print(dic.keys()) # 输出：odict_keys(['k1', 'k2']) .values() (获取字典所有的value，返回一个列表) import collections dic = collections.OrderedDict() dic['k1'] = 'v1' dic['k2'] = 'v2' dic['k3'] = 'v3' print(dic.values()) # 输出：odict_values(['v1', 'v2', 'v3']) defaultdict() class collections.default([default_factory[, ...]]) 返回一个类字典对象。defaultdict是内置类型dict的子类。他重写了父的一个方法并且增加了一个可以的实例变量。余下的功能与字典的一样，在这里就不写文档了。 第一个参数为default_factory属性提供初始值；default_factory的默认值为None.余下的参数被视为dict构造器的参数包括关键字参数 使用list作为default_factory,他很容易的将一个以键值形式表现的序列分组成一个字典列表 >>> s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] >>> d = defaultdict(list) >>> for k, v in s: ... d[k].append(v) ... >>> d.items() [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])] 当每个 key 第一次被访问时，他们肯定没有在映射中：一个入口自动的被创建了使用default_factory 函数返回一个空的列表。然后 list.append() 操作将值放入新的列表中。当 key再次被访问时，查找工作正常（返回这个key的列表）然后 list.append() 操作为列表添加别外的值。这个技巧比等价的技艺（使用 dict.setdefault()) 更简节，更快 >>> d = {} >>> for k, v in s: ... d.setdefault(k, []).append(v) ... >>> d.items() [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])] 将default_factory设置成int使defaultdict对于计数非常有用 >>> s = 'mississippi' >>> d = defaultdict(int) >>> for k in s: ... d[k] += 1 ... >>> d.items() [('i', 4), ('p', 2), ('s', 4), ('m', 1)] 当一个字每第一次被访问时，这个字母在映射中不存在，因此default_factory函数调用int()提供一个默认的0作为count。然后自增操作计算每个字母出现的次数, int()函数总是返回0，因为他是常量函数的一个特殊的例子。一个更快更灵活的方式是创建一个常量函数 设置default_factory为set使 defaultdict 构建集合字典非常有用 >>> s = [('red', 1), ('blue', 2), ('red', 3), ('blue', 4), ('red', 1), ('blue', 4)] >>> d = defaultdict(set) >>> for k, v in s: ... d[k].add(v) ... >>> d.items() [('blue', set([2, 4])), ('red', set([1, 3]))] Update time： 2020-05-25 "},"基础/Python itertools 模块.html":{"url":"基础/Python itertools 模块.html","title":"Python itertools 模块","keywords":"","body":"Python itertools 模块 itertools库 迭代器的特点是：惰性求值（Lazy evaluation），即只有当迭代至某个值时，它才会被计算，这个特点使得迭代器特别适合于遍历大文件或无限集合等，因为我们不用一次性将它们存储在内存中。 Python 内置的 itertools 模块包含了一系列用来产生不同类型迭代器的函数或类，这些函数的返回都是一个迭代器，我们可以通过 for 循环来遍历取值，也可以使用next()来取值。 itertools 模块提供的迭代器函数有以下几种类型： 无限迭代器：生成一个无限序列，比如自然数序列 1, 2, 3, 4, …； 有限迭代器：接收一个或多个序列（sequence）作为参数，进行组合、分组和过滤等； 组合生成器：序列的排列、组合，求序列的笛卡儿积等 无限迭代器 itertools模块提供了三个函数（事实上，它们是类）用于生成一个无限序列迭代器： count(firstval=0, step=1) 创建一个从 firstval (默认值为 0) 开始，以 step (默认值为 1) 为步长的的无限整数迭代器 cycle(iterable) 对 iterable 中的元素反复执行循环，返回迭代器 repeat(object [,times] 反复生成 object，如果给定 times，则重复次数为 times，否则为无限 count count() 接收两个参数，第一个参数指定开始值，默认为 0，第二个参数指定步长，默认为 1： >>> import itertools >>> >>> nums = itertools.count() >>> for i in nums: ... if i > 6: ... break ... print i ... 0 1 2 3 4 5 6 >>> nums = itertools.count(10, 2) # 指定开始值和步长 >>> for i in nums: ... if i > 20: ... break ... print i ... 10 12 14 16 18 20 cycle cycle()用于对 iterable 中的元素反复执行循环： >>> import itertools >>> >>> cycle_strings = itertools.cycle('ABC') >>> i = 1 >>> for string in cycle_strings: ... if i == 10: ... break ... print i, string ... i += 1 ... 1 A 2 B 3 C 4 A 5 B 6 C 7 A 8 B 9 C repeat 1repeat() 用于反复生成一个 object： >>> import itertools >>> >>> for item in itertools.repeat('hello world', 3): ... print item ... hello world hello world hello world >>> >>> for item in itertools.repeat([1, 2, 3, 4], 3): ... print item ... [1, 2, 3, 4] [1, 2, 3, 4] [1, 2, 3, 4] 有限迭代器 itertools 模块提供了多个函数（类），接收一个或多个迭代对象作为参数，对它们进行组合、分组和过滤等： chain chain(iterable1, iterable2, iterable3, ...) chain 接收多个可迭代对象作为参数，将它们『连接』起来，作为一个新的迭代器返回。 >>> from itertools import chain >>> >>> for item in chain([1, 2, 3], ['a', 'b', 'c']): #chain([1, 2, 3], ['a', 'b', 'c'])==[1, 2, 3, 'a', 'b', 'c'] ... print item ... 1 2 3 a b c compress compress 的使用形式如下： compress(data, selectors) compress 可用于对数据进行筛选，当 selectors 的某个元素为 true 时， 则保留 data 对应位置的元素，否则去除： dropwhile dropwhile(predicate, iterable) 其中，predicate 是函数，iterable 是可迭代对象。 对于 iterable 中的元素，如果 predicate(item) 为 true，则丢弃该元素， **否则返回该项及所有后续项**。 >>> from itertools import dropwhile >>> >>> list(dropwhile(lambda x: x >> >>> list(dropwhile(lambda x: x > 3, [2, 1, 6, 5, 4])) [2, 1, 6, 5, 4] groupby groupby 用于对序列进行分组，它的使用形式如下： groupby(iterable[, keyfunc]) 其中，iterable 是一个可迭代对象，keyfunc 是分组函数，用于对 iterable 的连续项进行分组， 如果不指定，则默认对 iterable 中的连续相同项进行分组， 返回一个 (key, sub-iterator) 的迭代器。 >>> from itertools import groupby >>> >>> for key, value_iter in groupby('aaabbbaaccd'): ... print key, ':', list(value_iter) ... a : ['a', 'a', 'a'] b : ['b', 'b', 'b'] a : ['a', 'a'] c : ['c', 'c'] d : ['d'] >>> >>> data = ['a', 'bb', 'ccc', 'dd', 'eee', 'f'] >>> for key, value_iter in groupby(data, len): # 使用 len 函数作为分组函数 ... print key, ':', list(value_iter) ... 1 : ['a'] 2 : ['bb'] 3 : ['ccc'] 2 : ['dd'] 3 : ['eee'] 1 : ['f'] >>> >>> data = ['a', 'bb', 'cc', 'ddd', 'eee', 'f'] >>> for key, value_iter in groupby(data, len): ... print key, ':', list(value_iter) ... 1 : ['a'] 2 : ['bb', 'cc'] 3 : ['ddd', 'eee'] 1 : ['f'] ifilter , ifilterfalse ifilter 的使用形式如下： ifilter(function or None, sequence) 将 iterable 中 function(item) 为 True 的元素组成一个迭代器返回， 如果 function 是 None，则返回 iterable 中所有计算为 True 的项。 >>> from itertools import ifilter >>> >>> list(ifilter(lambda x: x >> >>> list(ifilter(None, [0, 1, 2, 0, 3, 4])) [1, 2, 3, 4] ifilterfalse 的使用形式和ifilter类似，它将 iterable 中 function(item) 为 False 的元素组成一个迭代器返回，如果 function 是 None，则返回 iterable 中所有计算为 False 的项。 >>> from itertools import ifilterfalse >>> >>> list(ifilterfalse(lambda x: x >> >>> list(ifilter(None, [0, 1, 2, 0, 3, 4])) [0, 0] takewhile takewhile 的使用形式如下： takewhile(predicate, iterable) 其中，predicate 是函数，iterable 是可迭代对象。 对于 iterable 中的元素，如果 predicate(item) 为 true，则保留该元素， 只要 predicate(item) 为 false，则立即停止迭代。 >>> from itertools import takewhile >>> >>> list(takewhile(lambda x: x >> list(takewhile(lambda x: x > 3, [2, 1, 6, 5, 4])) [] 使用takewhile 替代break 语句 有时，我们需要在每次循环开始时，判断循环是否需要提前结束。比如下面这样： for uer in users: # 当第一个不合格的用户出现后，不再进行后面的处理 if not is_qualified(user): break #进行处理... ... 对于这类需要提前中断的循环，我们可以使用 takewhile() 函数来简化它。takewhile(predicate,iterable)会在迭代 iterable 的过程中不断使用当前对象作为参数调用predicate 函数并测试返回结果，如果函数返回值为真，则生成当前对象，循环继续。否则立即中断当前循环。 from itertools import takewhile for user in takewhile(is_qualified, users): # 进行处理... ... izip , izip_longest izip 用于将多个可迭代对象对应位置的元素作为一个元组，将所有元组『组成』一个迭代器，并返回。它的使用形式如下： izip(iter1, iter2, ..., iterN) 如果某个可迭代对象不再生成值，则迭代停止。 >>> from itertools import izip >>> >>> for item in izip('ABCD', 'xy'): ... print item ... ('A', 'x') ('B', 'y') >>> for item in izip([1, 2, 3], ['a', 'b', 'c', 'd', 'e']): ... print item ... (1, 'a') (2, 'b') (3, 'c') izip_longest跟 izip类似，但迭代过程会持续到所有可迭代对象的元素都被迭代完。它的形式如下： izip_longest(iter1, iter2, ..., iterN, [fillvalue=None]) 如果有指定 fillvalue，则会用其填充缺失的值，否则为 None。 >>> from itertools import izip_longest >>> >>> for item in izip_longest('ABCD', 'xy'): ... print item ... ('A', 'x') ('B', 'y') ('C', None) ('D', None) >>> >>> for item in izip_longest('ABCD', 'xy', fillvalue='-'): ... print item ... ('A', 'x') ('B', 'y') ('C', '-') ('D', '-') 组合生成器 itertools 模块还提供了多个组合生成器函数，用于求序列的排列、组合等： product product 用于求多个可迭代对象的笛卡尔积，它跟嵌套的 for 循环等价。它的一般使用形式如下： product(iter1, iter2, ... iterN, [repeat=1]) 其中，repeat 是一个关键字参数，用于指定重复生成序列的次数， >>> from itertools import product >>> >>> for item in product('ABCD', 'xy'): ... print item ... ('A', 'x') ('A', 'y') ('B', 'x') ('B', 'y') ('C', 'x') ('C', 'y') ('D', 'x') ('D', 'y') >>> >>> list(product('ab', range(3))) [('a', 0), ('a', 1), ('a', 2), ('b', 0), ('b', 1), ('b', 2)] >>> >>> list(product((0,1), (0,1), (0,1))) [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)] >>> >>> list(product('ABC', repeat=2)) [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C', 'C')] >>> 使用 product 扁平化多层嵌套循环 虽然我们都知道“扁平的代码比嵌套的好”。但有时针对某类需求，似乎一定得写多层嵌套循环才行。比如下面这段： def find_twelve(num_list1, num_list2, num_list3): ''' 从 3 个数字列表中，寻找是否存在和为 12 的 3 个数 ''' for num1 in num_list1: for num2 in num_list2: for num3 in num_list3: if num1 + num2 + num3 == 12: return num1, num2, num3 对于这种需要嵌套遍历多个对象的多层循环代码，我们可以使用 product() 函数来优化它。product()可以接收多个可迭代对象，然后根据它们的笛卡尔积不断生成结果。 from itertools import product def find_twelve_v2(num_list1, num_list2, num_list3): for num1, num2, num3 in product(num_list1, num_list2, num_list3): if num1 + num2 + num3 == 12: return num1, num2, num3 permutations permutations 用于生成一个排列，它的一般使用形式如下： 返回的是元组列表 permutations(iterable[, r]) 其中，r 指定生成排列的元素的长度，如果不指定，则默认为可迭代对象的元素长度。 >>> from itertools import permutations >>> >>> permutations('ABC', 2) >>> >>> list(permutations('ABC', 2)) [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')] >>> >>> list(permutations('ABC')) [('A', 'B', 'C'), ('A', 'C', 'B'), ('B', 'A', 'C'), ('B', 'C', 'A'), ('C', 'A', 'B'), ('C', 'B', 'A')] >>> combinations combinations用于求序列的组合，它的使用形式如下： combinations(iterable, r) 其中，r 指定生成组合的元素的长度。 >>> from itertools import combinations >>> >>> list(combinations('ABC', 2)) [('A', 'B'), ('A', 'C'), ('B', 'C')] combinations_with_replacement 和combinations类似，但它生成的组合包含自身元素。 >>> from itertools import combinations_with_replacement >>> >>> list(combinations_with_replacement('ABC', 2)) [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')] accumulate 简单来说就是累加。 from itertools import accumulate x = accumulate(range(10)) print(list(x)) [0, 1, 3, 6, 10, 15, 21, 28, 36, 45] Update time： 2020-05-25 "},"基础/Python 时间模块.html":{"url":"基础/Python 时间模块.html","title":"Python 时间模块","keywords":"","body":"Python 时间模块 Python时间和日期操作需要用到datetime和time标准库模块。 一、time模块 time模块表示时间的方式 ①时间戳 ②格式化的时间字符串 ③以数组的形式表示，即(struct_time),共有九个元素 year (four digits, e.g. 1998) month (1-12) day (1-31) hours (0-23) minutes (0-59) seconds (0-59) weekday (0-6, Monday is 0) Julian day (day in the year, 1-366) DST (Daylight Savings Time) flag (-1, 0 or 1) 是否是夏令时 常用函数 asctime([tuple])-> string 将一个struct_time(默认为当时时间)，转换成字符串。 >>> time.asctime() 'Sun Jul 31 11:10:39 2016' >>> import time >>> thisTime = \"2016-07-31 12:12:12\" >>> timeTuple = time.strptime(thisTime, \"%Y-%m-%d %H:%M:%S\") >>> time.asctime(timeTuple) 'Sun Jul 31 12:12:12 2016' ctime(seconds)-> string 将一个时间戳(默认为当前时间)转换成一个时间字符串。 >>> time.ctime() 'Sun Jul 31 11:11:33 2016' >>> time.ctime(1469938332) 'Sun Jul 31 12:12:12 2016' strftime(format[, tuple])-> string 将指定的struct_time(默认为当前时间)，根据指定的格式化字符串输出。 >>> time.strftime(\"%Y-%m-%d %H:%M:%S\") '2016-07-31 11:20:41' >>> import time >>> thisTime = \"2016-07-31 12:12:12\" >>> timeTuple = time.strptime(thisTime, \"%Y-%m-%d %H:%M:%S\") >>> time.strftime(\"%Y-%m-%d %H:%M:%S\",timeTuple) '2016-07-31 12:12:12' strptime(string, format)-> struct_time 将时间字符串根据指定的格式化符转换成数组形式的时间。 >>> import time >>> thisTime = \"2016-07-31 12:12:12\" >>> timeTuple = time.strptime(thisTime, \"%Y-%m-%d %H:%M:%S\") >>> print timeTuple time.struct_time(tm_year=2016, tm_mon=7, tm_mday=31, tm_hour=12, tm_min=12, tm_sec=12, tm_wday=6, tm_yday=213, tm_isdst=-1) time() -> floating point number 返回当前时间的时间戳。 >>> time.time() 1469935566.776 二、datetime模块 datetime中的常量 datetime.MINYEAR，表示datetime所能表示的最小年份，MINYEAR = 1。 datetime.MAXYEAR，表示datetime所能表示的最大年份，MAXYEAR = 9999 datetime中的类 datetime.date：表示日期的类。常用的属性有year, month, day； datetime.time：表示时间的类。常用的属性有hour, minute, second, microsecond； datetime.datetime：表示日期时间。 datetime.timedelta：表示时间间隔，即两个时间点之间的长度。 datetime.tzinfo：与时区有关的相关信息 date类 date类表示一个由年、月、日组成的日期。 类方法与类属性 date类定义了一些常用的类方法与类属性，方便我们操作： date.max、date.min：date对象所能表示的最大、最小日期； date.resolution：date对象表示日期的最小单位。这里是天。 date.today()：返回一个表示当前本地日期的date对象； from datetime import date print(date.today()) #datetime.date(2019, 11, 12) print(type(date.today())) # #可以转化为字符串格式的,进行分割等字符串的相关操作 print(str(date.today())) #'2019-11-12' 实例方法和属性 date.year、date.month、date.day：年、月、日； date.replace(year, month,day)：生成一个新的日期对象，用参数指定的年，月，日代替原有对象中的属性。（原有对象仍保持不变） date.timetuple()：返回日期对应的time.struct_time对象； date.toordinal()：返回日期对应的Gregorian Calendar日期； date.weekday()：返回weekday，如果是星期一，返回0；如果是星期2，返回1，以此类推； data.isoweekday()：返回weekday，如果是星期一，返回1；如果是星期2，返回2，以此类推； date.isocalendar()：返回格式如(year，month，day)的元组； date.isoformat()：返回格式如’YYYY-MM-DD’的字符串； date.strftime(fmt)：自定义格式化字符串。 date支持的其他操作 date2 = date1 + timedelta #日期加上一个间隔，返回一个新的日期对象） date2 = date1 - timedelta #日期隔去间隔，返回一个新的日期对象 timedelta = date1 - date2 #两个日期相减，返回一个时间间隔对象 date1 date1 , date2 要是这样的时间格式 datetime.date(year, month, day) 三、常见的日期时间操作 更改日期格式 方法:先转换为时间元组,然后转换为其他格式。 >>> import time >>> thisTime = \"2016-07-31 12:12:12\" >>>timeTuple = time.strptime(thisTime, \"%Y-%m-%d %H:%M:%S\") >>>otherTime = time.strftime(\"%Y/%m/%d %H:%M:%S\", timeTuple) >>> print otherTime 2016/07/31 12:12:12 将当前时间并转换为指定日期格式 >>> import time >>> nowStamp = int(time.time()) >>> timeTuple = time.localtime(nowStamp) >>> otherTime = time.strftime(\"%Y-%m-%d %H:%M:%S\", timeTuple) >>> print otherTime 2016-07-31 10:19:47 >>> import datetime >>> now = datetime.datetime.now() >>> otherTime = now.strftime(\"%Y-%m-%d %H:%M:%S\") >>> print otherTime 2016-07-31 10:21:45 参考 https://blog.csdn.net/HHG20171226/article/details/102808269 Update time： 2020-05-25 "},"基础/Python Arrow 时间模块.html":{"url":"基础/Python Arrow 时间模块.html","title":"Python Arrow 时间模块","keywords":"","body":"Python Arrow 时间模块 Arrow: Better dates & times for Python Arrow是一个用于时间处理的python库。它能够一键转化dates、times、timestamps等多种时间格式，而不需要大量import各种时间模块和格式转化函数。十分便捷和人性化，能够极大程度简化你的代码。 使用Arrow仅需两步，第一步接受各种类型时间类型（datetime,date,timestamps）转化为Arrow类型，第二步转化成自己需要的格式或进行操作。 import arrow #获取当前时间的Arrow格式 i=arrow.now() i str(i) '2019-11-21T17:04:57.018170+08:00' 转化时间戳 i.timestamp 1574327097 年 月 日 时 分 秒 i.format('YYYY-MM-DD HH:mm:ss') '2019-11-21 17:04:57' 年 月 日 i.format('YYYY-MM-DD') '2019-11-21' 时 分 秒 i.format('HH:mm:ss') '17:04:57' 星期 i.format('MMM DD dddd ') 'Nov 21 Thursday ' 66天后日期 i.shift(days=66).format('YYYY-MM-DD') '2020-01-26' 修改日期,梦回2008 i.replace(year=2008, month=8, day=8).format('YYYY-MM-DD') '2008-08-08' 获取当前时间 arrow.now() # arrow.now('US/Pacific') # arrow.utcnow() # get 格式转化 from datetime import datetime arrow.get(datetime(2019, 11, 21)) # arrow.get(datetime(2019, 11, 21),'US/Pacific') 解析字符串格式： >>> arrow.get('2013-05-05 12:30:45', 'YYYY-MM-DD HH:mm:ss') # 当天数为一位数字时 ，前面不可以＋0 >>> arrow.get(2013, 5, 5) >>> arrow.Arrow(2013, 5, 5) arrow.get(2019,11,21).format(\"YYYY-MM-DD\") #'2019-11-21' arrow.get(\"20191121\").format(\"YYYY-MM-DD\") #'2019-11-21' Replace & Shift Get a new Arrow object, with altered attributes, just as you would with a datetime: 时间替换 a.replace(\\kwargs)** ​ 返回一个被替换后的arrow对象，原对象不变 In [14]: arw = arrow.utcnow() In [15]: arw Out[15]: In [16]: arw.replace(hour=4, minute=40) Out[16]: Or, get one with attributes shifted forward or backward: shift 方法获取某个时间之前或之后的时间,关键字参数为years,months,weeks,days,hours，seconds，microseconds In [17]: arw.shift(weeks=+3) #三周后 Out[17]: In [18]: arw.shift(days=-14) Out[18]: In [19]: arw.shift(days =14) Out[19]: In [20]: arw.shift(years=1) Out[20]: Format In [21]: arrow.utcnow().format('YYYY-MM-DD HH:mm:ss ZZ') Out[21]: '2019-11-21 11:11:14 +00:00' Ranges & Spans Get the time span of any unit: In [22]: arrow.utcnow().span('hour') Out[22]: (, ) Or just get the floor and ceiling: In [23]: arrow.utcnow().floor('hour') Out[23]: In [24]: arrow.utcnow().ceil('hour') Out[24]: You can also get a range of time spans: arrow.Arrow.span_rang() 返回一个元组 start = datetime(2013, 5, 5,) end = datetime(2013,6, 5,) for r in arrow.Arrow.span_range('day', start, end): print(r) print(type(r)) # (, ) # Or just iterate over a range of time: start = datetime(2013, 5, 5, 12, 30) end = datetime(2013, 5, 5, 17, 15) for r in arrow.Arrow.range('hour', start, end): print( repr(r)) '或者' start =arrow.get (2013, 5, 5, 12, 30) end = arrow.get(2013, 5, 5, 17, 15) for r in arrow.Arrow.range('hour', start, end): print( repr(r)) '对获取范围内的日期进行格式化' 'range' 的到的范围，为闭区间 start =arrow.get (2013, 5, 5, 12, 30) end = arrow.get(2013, 5, 10, 17, 15) for r in arrow.Arrow.range('day', start, end): print(r.format(\"YYYY-MM-DD\")) 2013-05-05 2013-05-06 2013-05-07 2013-05-08 2013-05-09 2013-05-10 '或者' start =arrow.get (2013, 5, 5, 12, 30) end = arrow.get(2013, 5, 5, 17, 15) for r in arrow.Arrow.range('hour', start, end): print( repr(r)) '对获取范围内的日期进行格式化' 'range'的到的范围，为闭区间 start =arrow.get (2013, 5, 5, 12, 30) end = arrow.get(2013, 5, 10, 17, 15) for r in arrow.Arrow.range('day', start, end): print(r.format(\"YYYY-MM-DD\")) 2013-05-05 2013-05-06 2013-05-07 2013-05-08 2013-05-09 2013-05-10 人性化输出 a.humanize() >>> present = arrow.utcnow() >>> past = present.shift(hours=-1) >>> past.humanize() #相对于当前时间 'an hour age' >>> future = present.shift(hours=2) >>> future.humanize(present) #相对于参数时间 'in 2 hours' >>> past.humanize(present, locale='zh') #locale参数可以指定地区语言 '1天前' 参考： https://arrow.readthedocs.io/en/latest/ Update time： 2020-05-25 "},"文件处理/":{"url":"文件处理/","title":"python 文件处理","keywords":"","body":"python 文件处理 Update time： 2020-05-25 "},"文件处理/Python open函数.html":{"url":"文件处理/Python open函数.html","title":"Python open() 函数","keywords":"","body":"Python open() 函数 open() 打开一个文件 open(file[, mode[, buffering[, encoding[, errors[, newline[, closefd=True]]]]]]) 参数说明： file： 要打开的文件名，需加路径(除非是在当前目录)。唯一强制参数 mode： 文件打开的模式 buffering： 设置buffer（取值为0,1,>1） encoding： 返回数据的编码（一般为UTF8或GBK） errors： 报错级别（一般为strict，ignore） newline： 用于区分换行符(只对文本模式有效，可以取的值有None,'\\n','\\r','','\\r\\n') closefd： 传入的file参数类型（缺省为True） 常用的是file，mode和encoding这三个参数 mode：文件打开的模式。有如下几种模式 'r'： 以只读模式打开（缺省模式）（必须保证文件存在） 'w'：以只写模式打开。若文件存在，则会自动清空文件，然后重新创建；若文件不存在，则新建文件。使用这个模式必须要保证文件所在目录存在，文件可以不存在。该模式下不能使用read()方法 'a'：以追加模式打开。若文件存在，则会追加到文件的末尾；若文件不存在，则新建文件。该模式不能使用read()方法。 下面四个模式要和上面的模式组合使用 'b'：以二进制模式打开 't'： 以文本模式打开（缺省模式） '+'：以读写模式打开 'U'：以通用换行符模式打开 常见的mode组合 'r'或'rt'： 默认模式，文本读模式 'w'或'wt'： 以文本写模式打开（打开前文件会被清空） 'rb'： 以二进制读模式打开 'ab'： 以二进制追加模式打开 'wb'： 以二进制写模式打开（打开前文件会被清空） 'r+'： 以文本读写模式打开，可以写到文件任何位置；默认写的指针开始指在文件开头, 因此会覆写文件 'w+'： 以文本读写模式打开（打开前文件会被清空）。可以使用read() 'a+'： 以文本读写模式打开（写只能写在文件末尾）。可以使用read() 'rb+'： 以二进制读写模式打开 'wb+'： 以二进制读写模式打开（打开前文件会被清空） 'ab+'： 以二进制读写模式打开 .buffering：设置buffer 0： 代表buffer关闭（只适用于二进制模式） 1： 代表line buffer（只适用于文本模式） 1： 表示初始化的buffer大小 .errors：报错级别 strict： 字符编码出现问题时会报错 ignore： 字符编码出现问题时程序会忽略而过，继续执行下面的程序 .closefd： True： 传入的file参数为文件的文件名 False： 传入的file参数只能是文件描述符 Ps： 文件描述符，就是一个非负整数，在Unix内核的系统中，打开一个文件，便会返回一个文件描述符。 注意：使用open打开文件后一定要记得关闭文件对象 Update time： 2020-05-25 "},"文件处理/Python pandas读写csv文件.html":{"url":"文件处理/Python pandas读写csv文件.html","title":"Python pandas读写csv文件","keywords":"","body":"Python pandas读写csv文件 pandas.read_csv函数 pandas.read_csv(filepath_or_buffer, sep=', ', usecols=None, engine=None, header='infer', skiprows=None, nrows=None, skipfooter=0 ) filepath_or_buffer：可以是一个URL或者本地文件。有效的URL包括http，ftp，s3和文件。也可以是本地文件：table.csv（在本机的绝对地址）。 sep：分隔符。如果sep为None，那么C引擎不会自动检测到分隔符，但是Python解释器可以使用，这意味着后者将被使用，并通过Python的内置嗅探工具csv.Sniffer自动检测分隔符。 另外，长度超过1个字符且与’\\ s +‘不同的分隔符将被解释为正则表达式，并且还将强制使用Python解释器。 请注意，正则表达式分隔符很容易忽略带引号的数据。 正则表达式示例：’\\ r \\ t’ usecols：返回列的一个子集。 如果是数组的，所有元素必须是位置索引的（即文档列中的整数索引），或者是与由用户提供的名称或从文档标题行推断的列名相对应的字符串。 例如，有效的类似数组的usecols参数应该是[0,1,2]或[‘foo’，‘bar’，‘baz’]。如果可调用，则可调用函数将根据列名进行评估，返回可调用函数评估为True的名称。 一个有效的可调用参数的例子是[‘AAA’，‘BBB’，‘DDD’]中的lambda x：x.upper（）。 使用此参数可以缩短解析时间并降低内存使用量。 header：指定第几行来作为列名，默认是数据最开始的那一行。如果文件中没有列名，则默认为0，否则设置为None。如果明确设定header=0就会替换掉原来存在列名。header参数可以是一个list例如：[0,1,3]，这个list表示将文件中的这些行作为列标题（意味着每一列有多个标题），介于中间的行将被忽略掉（例如本例中的2；本例中的数据1,2,4行将被作为多级标题出现，第3行数据将被丢弃，dataframe的数据从第5行开始。）。 注意：如果skip_blank_lines=True 那么header参数忽略注释行和空行，所以header=0表示第一行数据而不是文件的第一行。 skiprows：list-like，int或callable，optional 要在文件开头跳过 （0索引）或要跳过的行数（int）的行号。 如果是可调用的，则将根据行索引计算可调用函数，如果应该跳过该行则返回True，否则返回False。 有效可调参数的一个例子是[0,2]中的lambda x：x。 nrows：int，可选 要读取的文件行数。用于读取大文件。 engine：使用的解释器。{‘c’, ‘python’}二选一。 skipfooter：文件底部要跳过的行数（不支持引擎=‘c’） DataFrame.to_csv to_csv()是DataFrame类的方法，read_csv()是pandas的方法 dt.to_csv() #默认dt是DataFrame的一个实例，参数解释如下 DataFrame.to_csv(path_or_buf=None, sep=',', na_rep='', float_format=None, columns=None, header=True, index=True, index_label=None, mode='w', encoding=None, compression='infer', quoting=None, quotechar='\"', line_terminator=None, chunksize=None, date_format=None, doublequote=True, escapechar=None, decimal='.', errors='strict') path_or_buf=None： string or file handle, default None File path or object, if None is provided the result is returned as a string. 字符串或文件句柄，默认无文件 路径或对象，如果没有提供，结果将返回为字符串。 sep : character, default ‘,’ Field delimiter for the output file. 默认字符 ‘ ，’ 输出文件的字段分隔符。 na_rep : string, default ‘’ Missing data representation 字符串，默认为 ‘’ 浮点数格式字符串 float_format : string, default None Format string for floating point numbers 字符串，默认为 None 浮点数格式字符串 columns : sequence, optional Columns to write 顺序，可选列写入 header : boolean or list of string, default True Write out the column names. If a list of strings is given it is assumed to be aliases for the column names 字符串或布尔列表，默认为true 写出列名。如果给定字符串列表，则假定为列名的别名。 index : boolean, default True Write row names (index) 布尔值，默认为Ture 写入行名称（索引） index_label : string or sequence, or False, default None Column label for index column(s) if desired. If None is given, and header and index are True, then the index names are used. A sequence should be given if the DataFrame uses MultiIndex. If False do not print fields for index names. Use index_label=False for easier importing in R 字符串或序列，或False,默认为None 如果需要，可以使用索引列的列标签。如果没有给出，且标题和索引为True，则使用索引名称。如果数据文件使用多索引，则应该使用这个序列。如果值为False，不打印索引字段。在R中使用index_label=False 更容易导入索引. mode : str 模式：值为‘str’，字符串 Python写模式，默认“w” encoding : string, optional 编码：字符串，可选 表示在输出文件中使用的编码的字符串，Python 2上默认为“ASCII”和Python 3上默认为“UTF-8”。 compression : string, optional 字符串，可选项 表示在输出文件中使用的压缩的字符串，允许值为“gzip”、“bz2”、“xz”，仅在第一个参数是文件名时使用。 line_terminator : string, default ‘\\n’ 字符串，默认为 ‘\\n’ 在输出文件中使用的换行字符或字符序列 quoting : optional constant from csv module CSV模块的可选常量 默认值为to_csv.QUOTE_MINIMAL。如果设置了浮点格式，那么浮点将转换为字符串，因此csv.QUOTE_NONNUMERIC会将它们视为非数值的。 quotechar : string (length 1), default ‘”’ 字符串（长度1），默认“” 用于引用字段的字符 doublequote : boolean, default True 布尔，默认为Ture 控制一个字段内的quotechar escapechar : string (length 1), default None 字符串（长度为1），默认为None 在适当的时候用来转义sep和quotechar的字符 chunksize : int or None int或None 一次写入行 tupleize_cols : boolean, default False 布尔值 ，默认为False 从版本0.21.0中删除：此参数将被删除，并且总是将多索引的每行写入CSV文件中的单独行 （如果值为false）将多索引列作为元组列表（如果TRUE）或以新的、扩展的格式写入，其中每个多索引列是CSV中的一行。 date_format : string, default None 字符串，默认为None 字符串对象转换为日期时间对象 decimal: string, default ‘.’ 字符串，默认’。’ 字符识别为小数点分隔符。例如。欧洲数据使用 ​​’，’ 参考 pandas系列 read_csv 与 to_csv 方法各参数详解（全，中文版） Update time： 2020-08-13 "},"文件处理/Python pandas读写excel文件.html":{"url":"文件处理/Python pandas读写excel文件.html","title":"Python pandas读写excel文件","keywords":"","body":"Python pandas读写excel文件 pandas.ExcelWriter pandas.ExcelWriter(path, engine=None**, *kwargs*) 使用 ExcelWriter() 可以向同一个 excel 的不同 sheet 中写入对应的表格数据，首先需要创建一个writer对象，传入的主要参数为已存在容器表格的路径及文件名称: 参数： path ：字符串，文件路径 engine ： str (optional) 用于编写的引擎。默认是 io.excel，也可以是 engine='openpyxl' date_format : 格式化字符串以写入Excel文件的日期 ,(e.g. ‘YYYY-MM-DD’). datetime_format : 写入Excel文件的日期时间对象的格式字符串 , (e.g. ‘YYYY-MM-DD HH:MM:SS’). mode : {‘w’, ‘a’}, default ‘w’ 要使用的文件模式（写或追加） Examples Default usage: with ExcelWriter('path_to_file.xlsx') as writer: df.to_excel(writer) To write to separate sheets in a single file: with ExcelWriter('path_to_file.xlsx') as writer: df1.to_excel(writer, sheet_name='Sheet1') df2.to_excel(writer, sheet_name='Sheet2') You can set the date format or datetime format: with ExcelWriter('path_to_file.xlsx', date_format='YYYY-MM-DD', datetime_format='YYYY-MM-DD HH:MM:SS') as writer: df.to_excel(writer) You can also append to an existing Excel file: with ExcelWriter('path_to_file.xlsx', mode='a') as writer: df.to_excel(writer, sheet_name='Sheet3') pandas.read_excel read_excel(io, sheetname=0, header=0, skiprows=None, skip_footer=0, index_col=None, names=None, parse_cols=None, parse_dates=False, date_parser=None, na_values=None, thousands=None, convert_float=True, has_index_names=None, converters=None, dtype=None, true_values=None, false_values=None, engine=None, squeeze=False, **kwds ) 常用参数解析： io: string, path object ; excel 路径。 sheetname : string, int, mixed list of strings/ints, or None, default 0 返回多表使用sheetname=[0,1],若sheetname=None是返回全表 注意：int/string 返回的是dataframe，而none和list返回的是dict of dataframe header : int, list of ints, default 0 指定列名行，默认0，即取第一行，数据为列名行以下的数据 若数据不含列名，则设定 header = None skiprows : list-like,Rows to skip at the beginning，省略指定行数的数据 skip_footer : int,default 0, 省略从尾部数的int行数据 index_col : int, list of ints, default None指定列为索引列，也可以使用u”strings”，读取的时候指定 索引 names : array-like, default None, 指定列的名字。 na_values:指定原数据集中哪些特征的值作为缺失值。 na_filter : boolean, default True；是否检查丢失值（空字符串或者是空值）。对于大文件来说数据集中没有空值，设定na_filter=False可以提升读取速度。 thousands：指定原始数据中的千位符 comment：指定注释符，在读取数据时，如果碰到首行指定的注释符，则跳过该行。 parse_datas：指明日期列，为字符串构成的 list； 数据源： 数据源： sheet1: ID NUM-1 NUM-2 NUM-3 36901 142 168 661 36902 78 521 602 36903 144 600 521 36904 95 457 468 36905 69 596 695 sheet2： ID NUM-1 NUM-2 NUM-3 36906 190 527 691 36907 101 403 470 basestation =\"F://pythonBook_PyPDAM/data/test.xls\" data = pd.read_excel(basestation) print data 输出：是一个dataframe ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 sheet_name参数 ：返回多表使用sheetname=[0,1],若sheetname=None是返回全表 注意：int/string 返回的是dataframe，而none和list返回的是dict of dataframe data_1 = pd.read_excel(basestation,sheet_name=[0,1]) print(data_1) print(type(data_1)) ''' OrderedDict([(0, ID NUN-1 NUM-2 NUM-3 0 36901 45 78 95 1 36902 47 45 63 2 39603 85 47 21 3 39604 96 36 45 4 39605 25 89 15), (1, ID NUN-1 NUM-2 NUM-3 0 36906 58 52 47 1 36907 66 26 14)]) header参数 指定列名行，默认0，即取第一行，数据为列名行以下的数据 若数据不含列名，则设定 header = None ，注意这里还有列名的一行。 data = pd.read_excel(basestation,header=None) print(data) ''' 0 1 2 3 0 ID NUN-1 NUM-2 NUM-3 1 36901 45 78 95 2 36902 47 45 63 3 39603 85 47 21 4 39604 96 36 45 5 39605 25 89 15 ''' data = pd.read_excel(basestation,header=[3]) print(data) ''' 39603 85 47 21 0 39604 96 36 45 1 39605 25 89 15 ''' skiprows参数 省略指定行数的数据 data = pd.read_excel(basestation,skiprows = [1]) print(data) ''' ID NUN-1 NUM-2 NUM-3 0 36902 47 45 63 1 39603 85 47 21 2 39604 96 36 45 3 39605 25 89 15 ''' skip_footer参数 省略从尾部数的int行的数据 data = pd.read_excel(basestation, skip_footer=3) print(data) ''' ID NUN-1 NUM-2 NUM-3 0 36901 45 78 95 1 36902 47 45 63 ''' index_col参数 指定列为索引列，也可以使用u”strings” data = pd.read_excel(basestation, index_col=\"NUM-3\") print(data) ''' ID NUN-1 NUM-2 NUM-3 95 36901 45 78 63 36902 47 45 21 39603 85 47 45 39604 96 36 15 39605 25 89 ''' names参数 指定列的名字。 data = pd.read_excel(basestation,names=[\"a\",\"b\",\"c\",\"e\"]) print(data) ''' a b c e 0 36901 45 78 95 1 36902 47 45 63 2 39603 85 47 21 3 39604 96 36 45 4 39605 25 89 15 ''' nrows参数 读取指定的几行数据 data = pd.read_excel(basestation, nrows=3) print(data) ''' ID NUN-1 NUM-2 NUM-3 0 36901 45 78 95 1 36902 47 45 63 2 39603 85 47 21 ''' usecols 参数 读取指定的列, 也可以通过名字或索引值（指定需要读取原数据集中的哪些变量名，以列表传入。） data = pd.read_excel(basestation, usecols=2) print(data) ''' ID NUN-1 NUM-2 0 36901 45 78 1 36902 47 45 2 39603 85 47 3 39604 96 36 4 39605 25 89 ''' DataFrame.to_excel 存储函数为pd.DataFrame.to_excel()，注意，必须是DataFrame写入excel, 即Write DataFrame to an excel sheet。其具体参数如下： to_excel(self, excel_writer, sheet_name='Sheet1', na_rep='', float_format=None, columns=None, header=True, index=True, index_label=None, startrow=0, startcol=0, engine=None, merge_cells=True, encoding=None, inf_rep='inf', verbose=True, freeze_panes=None ) 数据源： ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 5 36906 165 453 加载数据： basestation =\"./ex.xls\" basestation_end =\"./test_end.xls\" data = pd.read_excel(basestation) 参数excel_writer str or ExcelWriter object File path or existing ExcelWriter. data.to_excel(basestation_end) sheet_name 将数据存储在excel的那个sheet页面 data.to_excel(basestation_end,sheet_name=\"sheet2\") na_rep 缺失值填充 data.to_excel(basestation_end,na_rep=\"NULL\") colums sequence, optional，Columns to write 选择输出的的列。 data.to_excel(basestation_end,columns=[\"ID\"]) header boolean or list of string，默认为True,可以用list命名列的名字。header = False 则不输出题头。 data.to_excel(basestation_end,header=[\"a\",\"b\",\"c\",\"d\"]) header = False 则不输出题头 data.to_excel(basestation_end,header=False,columns=[\"ID\"]) index boolean, default True Write row names (index) 默认为True，显示index，当index=False 则不显示行索引（名字）。 index_label : string or sequence, default None 设置索引列的列名。 data.to_excel(basestation_end,index=False) index_label 设置索引列的列名 data.to_excel(basestation_end,index_label=[\"f\"]) 案例 写入excel，自定义索引 data={'ID':[1,2,3,4], 'year':[2000,2001,2002,2003], 'pop':[3.7,3.6,2.4,0.9]} df=pd.DataFrame(data) print(df) ''' ID year pop 0 1 2000 3.7 1 2 2001 3.6 2 3 2002 2.4 3 4 2003 0.9 ''' df.to_excel('text.xls') data={'ID':[1,2,3,4], 'year':[2000,2001,2002,2003], 'pop':[3.7,3.6,2.4,0.9]} df=pd.DataFrame(data) df=df.set_index('ID') df.to_excel('text.xls') 读取的数据无表头，为其添加新的表头并保存 people=pd.read_excel('People.xlsx',header=None) people.columns=['id', 'type', 'title', 'First', 'Middle', 'Last'] print(people.columns) #Index(['id', 'type', 'title', 'First', 'Middle', 'Last'], dtype='object') #默认添加行索引 ，可以重新指定 people=people.set_index('id') people.to_excel('people2.xls') 指定列为索引，避免自动pands再生成新的索引 #指定某列为索引 ，pands就不会再自动生成索引 people=pd.read_excel('people2.xls',index_col='id') 将多个Sheet写入到本地同一Excel文件中 import pandas as pd #读取两个表格 data1=pd.read_excel('文件路径') data2=pd.read_excel('文件路径') #将两个表格输出到一个excel文件里面 writer=pd.ExcelWriter('D:新表.xlsx') data1.to_excel(writer,sheet_name='sheet1') data2.to_excel(writer,sheet_name='sheet2') #必须运行writer.save()，不然不能输出到本地 writer.save() with pd.ExcelWriter(r'C:\\Users\\数据\\Desktop\\data\\test2.xls') as writer: df1.to_excel(writer, sheet_name='df1') df2.to_excel(writer, sheet_name='df2') 将多个 sheet 写入到一个文件的时候，切记 close 文件 Update time： 2020-08-13 "},"文件处理/Python 读写Excel文件.html":{"url":"文件处理/Python 读写Excel文件.html","title":"Python 读/写Excel文件","keywords":"","body":"Python 读/写Excel文件 Python与Excel交互——Xlwings 基础 引入库 import xlwings as xw 打开 Excel 程序，默认设置：程序可见，只打开不新建工作薄 app = xw.App(visible=True,add_book=False) #新建工作簿 (如果不接下一条代码的话，Excel只会一闪而过，卖个萌就走了） wb = app.books.add() 打开已有工作簿（支持绝对路径和相对路径） # 打开一个新的 workbook wb = xw.Book() # 打开当前目录已经存在的一个 workbook wb = xw.Book('example.xlsx') #这样的话就不会频繁打开新的Excel 保存工作簿 wb.save('example.xlsx') 退出工作簿（可省略） wb.close() 退出Excel app.quit() 引用Excel工作表，单元格 引用工作表 sht = wb.sheets[0] #sht = wb.sheets[第一个sheet名] 引用单元格 rng = sht.range('a1') #rng = sht['a1'] #rng = sht[0,0] 第一行的第一列即a1,相当于pandas的切片 引用区域 rng = sht.range('a1:a5') #rng = sht['a1:a5'] #rng = sht[:5,0] 写入数据 (xlwings多个单元格的写入大多是以表格形式) 选择起始单元格A1,写入字符串‘Hello’ sht.range('a1').value = 'Hello' 一维数据 默认按行插入：A1:D1分别写入1,2,3,4 sht.range('a1').value = [1,2,3,4] 等同于 sht.range('a1:d1').value = [1,2,3,4] 按列插入： A2:A5分别写入5,6,7,8 sht.range('a2').options(transpose=True).value = [5,6,7,8] 既然默认的是按行写入，我们就把它倒过来嘛（transpose），单词要打对，如果你打错单词，它不会报错，而会按默认的行来写入 二维数据 多行输入就要用二维列表了： sht.range('a6').expand('table').value = [['a','b','c'],['d','e','f'],['g','h','i']] Excel中区域的选取表格 # 选取第一列 rng=sht. range('A1').expand('down') rng.value=['a1','a2','a3'] # 选取第一行 rng=sht.range('A1').expand('right') rng=['a1','b1'] # 选取表格 rng.sht.range('A1').expand('table') rng.value=[[‘a1’,'a2','a3'],['b1','b2','b3']] 读取数据 读取A1:D4（直接填入单元格范围就行了） print(sht.range('a1:d4').value) 返回的值是列表形式，多行多列为二维列表，但有一点要注意，返回的数值默认是浮点数 a = sht.range('a1:d1').value print(a) for i in a: print(i) print(type(i)) 读取excel的第一列怎么做？ *a = sht.range('a:a').value print(len(a)) 你将会得到一个1048576个元素的列表，也就是空值也包含进去了，所以这种方法不行 思路：先计算单元格的行数(前提是连续的单元格) rng = sht.range('a1').expand('table') nrows = rng.rows.count 接着就可以按准确范围读取了 a = sht.range(f'a1:a{nrows}').value 同理选取一行的数据也一样 ncols = rng.columns.count #用切片 fst_col = sht[0,:ncols].value range常用的api # 引用当前活动工作表的单元格 rng=xw.Range('A1') # 加入超链接 # rng.add_hyperlink(r'www.baidu.com','百度',‘提示：点击即链接到百度') # 取得当前range的地址 rng.address rng.get_address() # 清除range的内容 rng.clear_contents() # 清除格式和内容 rng.clear() # 取得range的背景色,以元组形式返回RGB值 rng.color # 设置range的颜色 rng.color=(255,255,255) # 清除range的背景色 rng.color=None # 获得range的第一列列标 rng.column # 返回range中单元格的数据 rng.count # 返回current_region rng.current_region # 返回ctrl + 方向 rng.end('down') # 获取公式或者输入公式 rng.formula='=SUM(B1:B5)' # 数组公式 rng.formula_array # 获得单元格的绝对地址 rng.get_address(row_absolute=True, column_absolute=True,include_sheetname=False, external=False) # 获得列宽 rng.column_width # 返回range的总宽度 rng.width # 获得range的超链接 rng.hyperlink # 获得range中右下角最后一个单元格 rng.last_cell # range平移 rng.offset(row_offset=0,column_offset=0) #range进行resize改变range的大小 rng.resize(row_size=None,column_size=None) # range的第一行行标 rng.row # 行的高度，所有行一样高返回行高，不一样返回None rng.row_height # 返回range的总高度 rng.height # 返回range的行数和列数 rng.shape # 返回range所在的sheet rng.sheet #返回range的所有行 rng.rows # range的第一行 rng.rows[0] # range的总行数 rng.rows.count # 返回range的所有列 rng.columns # 返回range的第一列 rng.columns[0] # 返回range的列数 rng.columns.count # 所有range的大小自适应 rng.autofit() # 所有列宽度自适应 rng.columns.autofit() # 所有行宽度自适应 rng.rows.autofit() books 工作簿集合的api # 新建工作簿 xw.books.add() # 引用当前活动工作簿 xw.books.active sheets 工作表的集合 # 新建工作表 xw.sheets.add(name=None,before=None,after=None) # 引用当前活动sheet xw.sheets.active 练习 保存数据 import xlwings as xw wb = xw.Book() sht = wb.sheets[0] info_list = [['20190001','已揽收','凯撒邮局'], ['20190001','已发货','凯撒邮局'], ['20192288','已揽收','麻花镇邮局'], ['20192288','已发货','麻花镇邮局'], ['20192288','正在派送','阿里山']] 首先，写入表头， titles = [['包裹号','状态','地点']] sht.range('a1').value = titles 然后写入轨迹信息 sht.range('a2').value = info_list 保存 wb.save('Track.xlsx') 这样，第一步保存数据就完成了 更新数据 second = [ ['20190001','已揽收','凯撒邮局'], ['20190001','已发货','凯撒邮局'], ['20190001','正在派送','王村村口'], ['20190001','已签收','老王家'], ['20192288','已揽收','麻花镇邮局'], ['20192288','已发货','麻花镇邮局'], ['20192288','正在派送','阿里山'], ['20192288','已发货','小马家'] ] 更新数据其实没什么难度，直接覆盖写入就好了 但是如果我想知道更新了多少条记录怎么办呢？ 将数据去重，剩下的就是更新的 首先读取之前写入的信息： import xlwings as xw wb = xw.Book('Track.xlsx') sht = wb.sheets[0] first = sht.range('a2').expand('table').value print(first) 乍一看没什么问题，仔细一看，包裹号都成了浮点数！写入的时候是字符串，读取出来就成了浮点数，所以这时候去重，由于数据类型不一致，无法真正去重。 思路一：直接转化数据类型，将每个列表的第一个元素转为整数，再转为字符串 first_str = [] for i in first: print(round(i[0])) i[0] = str(round(i[0])) first_str.append(i) print(first_str) 思路二：如果大家对Excel熟悉的话，就会知道，在数字前面加一个英文字符的单引号（'），数字就变成文本格式了，所以我们可以在写入信息的时候加上一个单引号，这样Excel就不会乱改格式了。 import xlwings as xw wb = xw.Book('Track.xlsx') sht = wb.sheets[0] info_list = [[\"'20190001\",\"已揽收\",\"凯撒邮局\"], [\"'20190001\",\"已发货\",\"凯撒邮局\"], [\"'20192288\",\"已揽收\",\"麻花镇邮局\"], [\"'20192288\",\"已发货\",\"麻花镇邮局\"], [\"'20192288\",\"正在派送\",\"阿里山\"]] sht.range('a2').value = info_list values = sht.range('a2').expand('table').value print(values) 然后开始真正的去重 extra = [i for i in second if i not in first_str] print(extra) print(len(extra)) 结果没问题，多出三个轨迹信息 为了介绍xlwings的插入功能，我们再来设想这样一种情况： 已经有了两个包裹的轨迹情况 但是我们得到了20190001包裹的最新情况，需要更新这一个包裹的信息: [ [\"20190001\",\"已揽收\",\"凯撒邮局\"], [\"20190001\",\"已发货\",\"凯撒邮局\"], [\"20190001\",\"正在派送\",\"王村村口\"], [\"20190001\",\"已签收\",\"老王家\"] ] 首先，去重 extra = [i for i in second if i not in first_str] print(extra) 显示要更新的就一条 读取第一列的包裹号 rng = sht.range('a1').expand('table') nrows = rng.rows.count row_a = sht.range(f'a1:a{nrows}').value 找到要更新的包裹号 for i in extra: pkg = i[0] position = row_a.index(pkg) print(position) times = row_a.count(pkg) print(times) position = 1 是指在第二行出现，times = 3 是指一共有3个此包裹号的信息 所以要在第五行插入 rows = position+times+1 sht.range(f'{rows}:{rows}').api.Insert() 然后再写入更新的信息 sht.range(f'a{rows}').value = extra 大功告成！保存 wb.save() 插入语句 sht.range('单元格或行列').api.Insert() #插入列 sht.range('a:a').api.Insert() #插入行 sht.range('2:2').api.Insert() #插入单元格 sht.range('b4').api.Insert() 参考 Python与Excel交互——Xlwings Python与Excel交互——Xlwings实战 xlwings - Make Excel Fly Update time： 2020-05-25 "},"文件处理/Python openpyxl模块.html":{"url":"文件处理/Python openpyxl模块.html","title":"Python openpyxl模块","keywords":"","body":"Python openpyxl模块 Create a workbook from openpyxl import Workbook wb = Workbook() 创建好工作簿后，至少包含一个 Sheet ，可以使用Workbook.active 获取： ws = wb.active 默认设置为0。除非您修改其值，否则您将始终使用此方法获得第一个工作表。 使用Workbook.create_sheet()方法创建新的 sheet ws1 = wb.create_sheet(\"Mysheet\") # insert at the end (default) # or ws2 = wb.create_sheet(\"Mysheet\", 0) # insert at first position # or ws3 = wb.create_sheet(\"Mysheet\", -1) # insert at the penultimate(倒数第二) position 重命名 sheet: Worksheet.title ws.title = \"New Title\" # 将 sheet ws 的名字改为 New Title 使用 RRGGBB 改变 sheet 的背景色：Worksheet.sheet_properties.tabColor ws.sheet_properties.tabColor = \"1072BA\" 通过字典访问的方式获取 sheet： ws3 = wb[\"New Title\"] 获取当前工作簿中的 sheet：Workbook.sheetnames print(wb.sheetnames) # ['Sheet2', 'New Title', 'Sheet1'] # or You can loop through worksheets for sheet in wb: print(sheet.title) 您可以在单个工作簿中创建工作表的副本： source = wb.active target = wb.copy_worksheet(source) 只复制单元格（包括值、样式、超链接和注释）和某些工作表属性（包括尺寸、格式和属性）。不会复制所有其他工作簿/工作表属性-例如图像、图表。 也不能在工作簿之间复制工作表。如果工作簿以只读或只读模式打开，则无法复制工作表。 如果是要从现有Excel里面导入数据，使用load_workbook函数即可： from openpyxl import load_workbook wb = load_workbook('data.xlsx') 要保存 Workbook，调用 Workbook 的 save函数就行： wb.save('data.xlsx') Sheet对象属性 Sheet对象有许多有用的函数和属性，基本的几个介绍如下。 title，即工作薄的名称，显示在Excel底部 >>> ws.title 'Sheet' parent，即所属的Ｗorkbook的名称 >>> wb1 = ws.parent >>> wb1 == wb True active_cell，即光标所在的单元格的编号 >>> ws.active_cell 'B5' rows和columns，表示行和列的迭代器，通过for循环可以得到每行或每列的单元格元组 >>> for row in ws.rows: ... print(row) ... (, ) (, ) Cell对象的操作 获取对象 获取对象也有好几种方式，下面一一介绍。 cell(row, column, value=None) 通过工作簿对象的cell函数获取 >>> c = ws.cell(row=1, column=1) # 获取第一行第一列的单元格 >>> c.value # 打印单元格的值 '姓名' >>> c.value = ‘Name’ # 重设单元格的值 通过工作薄对象的[]函数来获取，这里面获取方式比较灵活，举例如下： >>> c = ws['A4'] # 获取第４行，第１列的单元格 >>> c = ws['A'] # 获取第１列的所有单元格 >>> c = ws['5'] # 获取第５行的所有单元格 >>> c = ws['A1': 'B10'] # 获取第1行第1列到第10行第2列的矩形区域内的所有单元格 >>> c = ws['A':'B'] # 获取第1列到第2列的所有单元格 >>> c = ws[1:10] # 获取第1行到第10行的所有单元格 通过iter_cols或iter_rows来得到： >>> for row in ws.iter_rows(min_row=1, max_col=3, max_row=2): ... for cell in row: ... print(cell) 其中参数min_col和min_row是迭代时起始的列号和行号，max_col和max_row是结束的列号和行号，都是包含在迭代内部的。 >>> for col in ws.iter_cols(min_row=1, max_col=3, max_row=2): ... for cell in col: ... print(cell) 通过工作簿对象的active_cell得到光标所在的单元格： >>> ws.active_cell 'B5' coordinate 此单元格的坐标（例如“A5”） ws.cell(1,2).coordinate[:1] # 'B' ws.cell(1,2).coordinate[:] # 'B1' 遍历文件的所有行或列 Worksheet.rows >>> ws = wb.active >>> ws['C9'] = 'hello world' >>> tuple(ws.rows) ((, ), (, ), (, )) Worksheet.columns >>> tuple(ws.columns) ((, , ), (, , )) Values only If you just want the values from a worksheet you can use the Worksheet.values property. This iterates over all the rows in a worksheet but returns just the cell values: for row in ws.values: for value in row: print(value) vA1 vB1 vA2 vB2 vA3 vB3 按行遍历输出 value Both Worksheet.iter_rows() and Worksheet.iter_cols() can take the values_only parameter to return just the cell’s value: 以元组的方式返回整行或整列的数据 for row in ws.iter_rows(min_row=1, max_col=2, max_row=3, values_only=True): print(row) ('vA1', 'vB1') ('vA2', 'vB2') ('vA3', 'vB3') for row in ws.iter_cols(min_row=1, max_col=2, max_row=3, values_only=True): print(row) ('vA1', 'vA2', 'vA3') ('vB1', 'vB2', 'vB3') Saving to a file The simplest and safest way to save a workbook is by using the Workbook.save() method of the Workbook object: >>> wb = Workbook() >>> wb.save('balances.xlsx') Loading from a file The same way as writing, you can use the openpyxl.load_workbook() to open an existing workbook: >>> from openpyxl import load_workbook >>> wb2 = load_workbook('test.xlsx') >>> print wb2.sheetnames ['Sheet2', 'New Title', 'Sheet1'] Inserting rows and columns openpyxl.worksheet.worksheet.Worksheet.insert_rows() openpyxl.worksheet.worksheet.Worksheet.insert_cols() insert_cols ( idx , amount=1) 在co l== idx 之前插入一列或多个列 insert_rows ( idx , amount=1**)** 在 row == idx 之前插入一行或多个行 The default is one row or column. For example to insert a row at 7 (before the existing row 7): ws.insert_rows(7) Deleting rows and columns To delete the columns F:H: ws.delete_cols(6, 3) # 删除第六列即后面的三列（包含第六列） 方法： append (iterable) 在当前工作表的底部追加一组值。 如果是一个列表：所有值都是按顺序添加的，如果是dict，则从第一列开始：值被分配给键（数字或字母）指示的列 参数： iterable (list|tuple|range|generator or dict) – list, range or generator, or dict containing values to append Usage: append([‘This is A1’, ‘This is B1’, ‘This is C1’]) or append({‘A’ : ‘This is A1’, ‘C’ : ‘This is C1’}) or append({1 : ‘This is A1’, 3 : ‘This is C1’}) insert_cols (idx, amount=1) 在col==idx之前插入一列或多个列 insert_rows (idx, amount=1**)** 在row==idx之前插入一行或多个行 delete_cols (idx, amount=1**)** Delete column or columns from col==idx delete_rows (idx, amount=1**)** Delete row or rows from row==idx max_column ：包含数据的最大列索引（基于1）。 返回值：int max_row ：包含数据的最大行索引（基于1）。返回值：int min_column : 包含数据的最小列索引（基于1） min_row : 包含数据的最小行索引（基于1） values : 按行生成工作表中的所有单元格值。Type : generator iter_cols (min_col=None, max_col=None**, min_row=None, max_row=None, values_only=False)** 从工作表中按列生成单元格。使用行和列的索引指定迭代范围。 如果没有指定索引，则范围从A1开始。 如果工作表中没有单元格，则返回空元组。 Parameters ： min_col (int) – smallest column index (1-based index) min_row (int) – smallest row index (1-based index) max_col (int) – largest column index (1-based index) max_row (int) – largest row index (1-based index) values_only (bool) – whether only cell values should be returned 返回值： generator iter_rows (min_col=None, max_col=None**, min_row=None, max_row=None, values_only=False)** 从工作表中按行生成单元格。使用行和列的索引指定迭代范围。 如果没有指定索引，则范围从A1开始。 如果工作表中没有单元格，则返回空元组。 Parameters ： min_col (int) – smallest column index (1-based index) min_row (int) – smallest row index (1-based index) max_col (int) – largest column index (1-based index) max_row (int) – largest row index (1-based index) values_only (bool) – whether only cell values should be returned 返回值： generator calculate_dimension () 返回包含数据的所有单元格的最小边界范围（例如“A1:M24”） Return type : string Working with styles Styles can be applied to the following aspects: font to set font size, color, underlining, etc. fill to set a pattern or color gradient border to set borders on a cell cell alignment protection The following are the default values >>> from openpyxl.styles import PatternFill, Border, Side, Alignment, Protection, Font >>> font = Font(name='Calibri', # 字体 ... size=11, # 大小 ... bold=False, # 加粗 ... italic=False, # 斜体 ... vertAlign=None, ... underline='none', # 下划线 ... strike=False, # 删除线 ... color='FF000000') >>> fill = PatternFill(fill_type=None, ... start_color='FFFFFFFF', ... end_color='FF000000') >>> border = Border(left=Side(border_style=None, ... color='FF000000'), ... right=Side(border_style=None, ... color='FF000000'), ... top=Side(border_style=None, ... color='FF000000'), ... bottom=Side(border_style=None, ... color='FF000000'), ... diagonal=Side(border_style=None, ... color='FF000000'), ... diagonal_direction=0, ... outline=Side(border_style=None, ... color='FF000000'), ... vertical=Side(border_style=None, ... color='FF000000'), ... horizontal=Side(border_style=None, ... color='FF000000') ... ) >>> alignment=Alignment(horizontal='general', ... vertical='bottom', ... text_rotation=0, ... wrap_text=False, ... shrink_to_fit=False, ... indent=0) >>> number_format = 'General' >>> protection = Protection(locked=True, ... hidden=False) >>> Cell Styles >>> from openpyxl.styles import colors >>> from openpyxl.styles import Font, Color >>> from openpyxl import Workbook >>> wb = Workbook() >>> ws = wb.active >>> >>> a1 = ws['A1'] >>> d4 = ws['D4'] >>> ft = Font(color=\"FF0000\") >>> a1.font = ft >>> d4.font = ft >>> >>> a1.font.italic = True # is not allowed # doctest: +SKIP >>> >>> # If you want to change the color of a Font, you need to reassign it:: >>> >>> a1.font = Font(color=\"FF0000\", italic=True) # the change only affects A1 # italic 斜体 Copying styles Styles can also be copied >>> from openpyxl.styles import Font >>> from copy import copy >>> >>> ft1 = Font(name='Arial', size=14) >>> ft2 = copy(ft1) >>> ft2.name = \"Tahoma\" >>> ft1.name 'Arial' >>> ft2.name 'Tahoma' >>> ft2.size # copied from the 14.0 Colours 字体、背景、边框等的颜色可以通过三种方式设置：索引、aRGB或主题。Indexed colours are the legacy implementation，颜色本身取决于工作簿或应用程序默认提供的索引。主题颜色对于颜色的互补色调很有用，但也取决于工作簿中的主题。因此，建议使用aRGB颜色。 aRGB colours RGB颜色使用十六进制值设置为红色、绿色和蓝色。 >>> from openpyxl.styles import Font >>> font = Font(color=\"FF0000\") alpha值理论上指的是颜色的透明度，但这与单元格样式无关。默认值00将添加到任何简单的RGB值： >>> from openpyxl.styles import Font >>> font = Font(color=\"00FF00\") >>> font.color.rgb '0000FF00' 它还支持传统索引颜色以及主题和色调。 >>> from openpyxl.styles.colors import Color >>> c = Color(indexed=32) >>> c = Color(theme=6, tint=0.5) Indexed Colours Applying Styles 样式直接应用于单元格 >>> from openpyxl.workbook import Workbook >>> from openpyxl.styles import Font, Fill >>> wb = Workbook() >>> ws = wb.active >>> c = ws['A1'] >>> c.font = Font(size=12) 样式也可以应用于列和行，但请注意，这只适用于关闭文件后（在Excel中）创建的单元格。如果要将样式应用于整个行和列，则必须自己将样式应用于每个单元格。这是对文件格式的限制： >>> col = ws.column_dimensions['A'] >>> col.font = Font(bold=True) >>> row = ws.row_dimensions[1] >>> row.font = Font(underline=\"single\") 参考 openpyxl Update time： 2020-08-05 "},"文件处理/Python csv模块.html":{"url":"文件处理/Python csv模块.html","title":"Python csv模块","keywords":"","body":"Python csv模块 csv模块包含在Python标准库中，可用于分析CSV文件中的数据行，让我们能够快速提取感兴趣的值。 csv模块 中的方法 只能够读取 / 写入到一个sheet中 csv.reader() csv.reader(csvfile, dialect='excel', **fmtparams) 参数： csvfile，必须是支持迭代(Iterator)的对象，可以是文件(file)对象或者列表(list)对象，如果是文件对象，打开时需要加\"b\"标志参数。 dialect，编码风格，默认为excel的风格，也就是用逗号（,）分隔，dialect方式也支持自定义，通过调用register_dialect方法来注册，。 fmtparam，格式化参数，用来覆盖之前dialect对象指定的编码风格。 import csv with open('test.csv','rb') as myFile: lines=csv.reader(myFile) for line in lines: print line open()返回了一个文件对象myFile，reader(myFile)只传入了第一个参数，另外两个参数采用缺省值，即以excel风格读入。reader()返回一个 reader 对象 lines, ines 是一个list，当调用它的方法lines.next()时，会返回一个string。 csv.writer() csv.writer(csvfile, dialect='excel', **fmtparams) with open('t.csv','wb') as myFile: myWriter=csv.writer(myFile) myWriter.writerow([7,'g']) myWriter.writerow([8,'h']) myList=[[1,2,3],[4,5,6]] myWriter.writerows(myList) csv.writer(myFile)返回writer对象myWriter。 writerow()方法是一行一行写入，writerows方法是一次写入多行。 补充：除了writerow、writerows，writer对象还提供了其他一些方法：writeheader、dialect 追加 除了直接写入，还能实现追加：还是刚才那个例子，我现在将一行新的数据添加到旧的数据后面，最后写入CSV import csv # 新增的数据行，以列表的形式表示 add_info = [\"Guo\", 150] # 以添加的形式写入csv，跟处理txt文件一样，设定关键字\"a\"，表追加 csvFile = open(\"instance.csv\", \"a\") # 新建对象writer writer = csv.writer(csvFile) # 写入，参数还是列表形式 writer.writerow(add_info) csvFile.close() 案例：从 CSV 文件中删除表头 #! python3 # removeCsvHeader.py - Removes the header from all CSV files in the current # working directory. import csv, os os.makedirs('headerRemoved', exist_ok=True) # Loop through every file in the current working directory. for csvFilename in os.listdir('.'): if not csvFilename.endswith('.csv'): continue # skip non-csv files print('Removing header from ' + csvFilename + '...') # Read the CSV file in (skipping first row). csvRows = [] csvFileObj = open(csvFilename) readerObj = csv.reader(csvFileObj) for row in readerObj: if readerObj.line_num == 1: #利用 line_num 属性确定要跳过哪一行 continue # skip first row csvRows.append(row) csvFileObj.close() # Write out the CSV file. csvFileObj = open(os.path.join('headerRemoved', csvFilename), 'w', newline='') csvWriter = csv.writer(csvFileObj) for row in csvRows: csvWriter.writerow(row) csvFileObj.close() csv.DictReader class csv.DictReader(csvfile, fieldnames=None, restkey=None, restval=None, dialect='excel', *args, **kwds ) 创建一个对象，其操作类似于普通读取器，但将读取的信息映射到一个 dict 中，其中的键由可选的 fieldnames 参数给出。fieldnames 参数是一个 sequence，其元素按顺序与输入数据的字段相关联。这些元素成为结果字典的键。如果省略 fieldnames 参数，则 csvfile 的第一行中的值将用作字段名称，如果读取的行具有比字段名序列更多的字段，则剩余数据将作为键值为 restkey 的序列添加。如果读取的行具有比字段名序列少的字段，则剩余的键使用可选的 restval 参数的值。任何其他可选或关键字参数都传递给底层的 reader 实例。 DictReader，和 reader 函数类似，接收一个可迭代的对象，能返回一个生成器，但是返回的每一个单元格都放在一个字典的值内，而这个字典的键则是这个单元格的标题（即列头） with open('names.csv') as csvfile: reader = csv.DictReader(csvfile) for row in reader: print(row['first_name'], row['last_name']) #输出 Baked Beans Lovely Spam Wonderful Spam import csv #读 with open(\"test.csv\", \"r\", encoding = \"utf-8\") as f: reader = csv.DictReader(f) column = [row for row in reader] print(column) 输出： [{'No.': '1', 'Age': '18', 'Score': '99', 'Name': 'mayi'}, {'No.': '2', 'Age': '21', 'Score': '89', 'Name': 'jack'}, {'No.': '3', 'Age': '25', 'Score': '95', 'Name': 'tom'}, {'No.': '4', 'Age': '19', 'Score': '80', 'Name': 'rain'}] 如果我们想用 DictReader 读取 csv 的某一列，就可以用列的标题查询： import csv #读取Name列的内容 with open(\"test.csv\", \"r\", encoding = \"utf-8\") as f: reader = csv.DictReader(f) column = [row['Name'] for row in reader] print(column) 输出： ['mayi', 'jack', 'tom', 'rain'] csv.DictWriter class csv.DictWriter(csvfile, fieldnames, restval='', extrasaction='raise', dialect='excel', *args, **kwds ) 创建一个操作类似于常规writer的对象，但将字典映射到输出行。fieldnames参数是一个sequence，用于标识传递给 writerow() 方法的字典中的值被写入csvfile。如果字典在fieldnames中缺少键，则可选的restval参数指定要写入的值。如果传递给writerow()方法的字典包含fieldnames中未找到的键，则可选的extrasaction参数指示要执行的操作。如果设置为’raise’，则会引发ValueError。如果设置为’ignore’，则会忽略字典中的额外值。任何其他可选或关键字参数都传递给底层的writer实例。 请注意，与 DictReader 类不同，DictWriter 的 fieldnames 参数不是可选的。由于Python的 dict 对象没有排序，因此没有足够的信息来推断将该行写入到csvfile的顺序。 import csv with open('names.csv', 'w') as csvfile: fieldnames = ['first_name', 'last_name'] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'}) writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'}) writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'}) delimiter和 lineterminator 关键字参数 假定你希望用制表符代替逗号来分隔单元格，并希望有两倍行距。 >>> import csv >>> csvFile = open('example.tsv', 'w', newline='') >>> csvWriter = csv.writer(csvFile, delimiter='\\t', lineterminator='\\n\\n') >>> csvWriter.writerow(['apples', 'oranges', 'grapes']) 24 >>> csvWriter.writerow(['eggs', 'bacon', 'ham']) 17 >>> csvWriter.writerow(['spam', 'spam', 'spam', 'spam', 'spam', 'spam']) 32 >>> csvFile.close( 默认情况下， CSV 文件的分隔符是逗号。行终止字符是出现在行末的字符。默认情况下，行终止字符是换行符。你可以利用 csv.writer()的 delimiter 和 lineterminator关键字参数，将这些字符改成不同的值。 Update time： 2020-05-25 "},"文件处理/Python os模块.html":{"url":"文件处理/Python os模块.html","title":"Python os模块","keywords":"","body":"Python os模块 os 模块是与操作系统交互的一个接口 os.getcwd()获取当前工作目录，即当前python脚本工作的目录路径 print(os.getcwd()) 输出：F:\\CodeFile\\16\\21 os.chdir(\"dirname\") 改变当前脚本工作目录；相当于shell下cd print(os.getcwd()) os.chdir('211') print(os.getcwd()) 输出： F:\\CodeFile\\16\\21 F:\\CodeFile\\16\\21\\211 os.makedirs('dirname1/dirname2') 可生成多层递归目录 os.makedirs('dir1/dir11') os.mkdir('dirname') 生成单级目录；相当于shell中mkdir dirname import random,os print(os.getcwd()) os.chdir('211') print(os.getcwd()) os.mkdir(\"100\") os.rmdir(‘dirname’) 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir - dirname os.listdir('dirname') 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 import os print(os.getcwd()) print(os.listdir()) 输出：['01.py', '02.py', '211'] os.rename(\"oldname\",\"newname\") 重命名文件/目录 os.removedirs('dirname1') 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.remove() 删除一个文件 os.stat('path/filename') 获取文件/目录信息 os.path.abspath(path) 返回path规范化的绝对路径 os.path.split(path) 将path分割成目录和文件名二元组返回 os.path.dirname(path) 返回 path 的目录。其实就是 os.path.split(path) 的第一个元素 os.path.basename(path)返回path最后的文件名，如果path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素 print(os.path.split(r'F:\\CodeFile\\16\\21\\02.py')) print(os.path.dirname(r'F:\\CodeFile\\16\\21\\02.py')) print(os.path.basename(r'F:\\CodeFile\\16\\21\\02.py')) 输出： ('F:\\\\CodeFile\\\\16\\\\21', '02.py') F:\\CodeFile\\16\\21 02.py os.path.splitext() 分离扩展名： os.path.splitext('poem.txt') --->('poem', '.txt') os.path.splitext('/home/swaroop/byte/code/poem.txt') --->('/home/swaroop/byte/code/poem', '.txt') os.path.getsize（filename） 获取文件大小 os.path.exists(path) 如果path存在，返回True；如果path不存在，返回False os.path.isabs(path) 如果path是绝对路径，返回True os.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回False os.path.isdir(path) 如果path是一个存在的目录，则返回True。否则返回False >>> os.path.exists('C:\\\\Windows') True >>> os.path.exists('C:\\\\some_made_up_folder') False >>> os.path.isdir('C:\\\\Windows\\\\System32') True >>> os.path.isfile('C:\\\\Windows\\\\System32') False os.path.join(path1[, path2[, ...]])将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.getatime(path) 返回path所指向的文件或者目录的最后存取时间 os.path.getmtime(path)返回path所指向的文件或者目录的最后修改时间 案例 #01.py import os,sys PATH=os.path.dirname(os.path.dirname(os.path.abspath(__file__))) sys.path.append(PATH) print(os.path.abspath(__file__)) #打印F:\\CodeFile\\Python1\\22\\conf\\01.py print(os.path.dirname(os.path.abspath(__file__))) #打印F:\\CodeFile\\Python1\\22\\conf print(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) #打印F:\\CodeFile\\Python1\\22 from core import lo #导入模块 lo.pp() #打印hhg import re import os import time #str.split(string)分割字符串 #'连接符'.join(list) 将列表组成字符串 def change_name(path): global i if not os.path.isdir(path) and not os.path.isfile(path): return False if os.path.isfile(path): file_path = os.path.split(path) #分割出目录与文件 lists = file_path[1].split('.') #分割出文件与文件扩展名 file_ext = lists[-1] #取出后缀名(列表切片操作) img_ext = ['bmp','jpeg','gif','psd','png','jpg'] if file_ext in img_ext: os.rename(path,file_path[0]+'/'+lists[0]+'_fc.'+file_ext) i+=1 #注意这里的i是一个陷阱 #或者 #img_ext = 'bmp|jpeg|gif|psd|png|jpg' #if file_ext in img_ext: # print('ok---'+file_ext) elif os.path.isdir(path): for x in os.listdir(path): change_name(os.path.join(path,x)) #os.path.join()在路径处理上很有用 img_dir = 'D:\\\\xx\\\\xx\\\\images' img_dir = img_dir.replace('\\\\','/') start = time.time() i = 0 change_name(img_dir) c = time.time() - start print('程序运行耗时:%0.2f'%(c)) print('总共处理了 %s 张图片'%(i)) Update time： 2020-05-25 "},"文件处理/Python glob模块.html":{"url":"文件处理/Python glob模块.html","title":"Python glob模块","keywords":"","body":"Python glob模块 功能描述：glob模块可以使用Unix shell风格的通配符匹配符合特定格式的文件和文件夹，跟windows的文件搜索功能差不多。glob模块并非调用一个子shell实现搜索功能，而是在内部调用了os.listdir()和fnmatch.fnmatch()。 glob模块共包含以下3个函数： glob(pathname, recursive=False) 第一个参数 pathname为需要匹配的字符串。（该参数应尽量加上r前缀，以免发生不必要的错误） 第二个参数代表递归调用，与特殊通配符“”一同使用，默认为False。 返回值为列表 该函数返回一个符合条件的路径的字符串列表，如果使用的是Windows系统，路径上的“\\”符号会自动加上转义符号变为“\\”（方便使用）。 在3.5版本之后，glob函数支持一个特殊的通配符“”，该通配符可以匹配指定路径里所有文件和目录，包括子目录里的所有文件和目录。相当于递归地调用了这个函数。使用这个通配符必须加上 recursive=True 参数。 （在有复杂目录结构的情况下使用该通配符可能会导致性能下降，拖累整个程序的运行，需谨慎使用！） iglob(pathname, recursive=False) 参数与glob()一致。 返回一个迭代器，该迭代器不会同时保存所有匹配到的路径，遍历该迭代器的结果与使用相同参数调用glob()的返回结果一致。 escape(pathname) 这个函数是在3.4版本之后才有的，功能是忽略所有通配符。（可以用于测试某文件是否存在） （3.5.1版本该函数不能正常运行，升级到3.5.2之后恢复正常） glob模块支持的通配符： import glob listglob = [] listglob = glob.glob(r\"/home/xxx/picture/*.png\") listglob.sort() print listglob print '--------------------' listglob = glob.glob(r\"/home/xxx/picture/0?.png\") listglob.sort() print listglob print '--------------------' listglob = glob.glob(r\"/home/xxx/picture/0[0,1,2].png\") listglob.sort() print listglob print '--------------------' listglob = glob.glob(r\"/home/xxx/picture/0[0-3].png\") listglob.sort() print listglob print '--------------------' listglob = glob.iglob(r\"/home/xxx/picture/0[a-z].png\") print listglob for item in listglob: print item import glob,os path=\"F:\\\\CodeFile\\\\my_directory\" l=[] l=glob.glob(os.path.join(path,\"*.txt\")) for i in l: print(i) 输出： F:\\CodeFile\\my_directory\\file3 - 副本 (2).txt F:\\CodeFile\\my_directory\\file3 - 副本 (3).txt F:\\CodeFile\\my_directory\\file3 - 副本 (4).txt F:\\CodeFile\\my_directory\\file3 - 副本.txt F:\\CodeFile\\my_directory\\file3.txt Update time： 2020-05-25 "},"文件处理/Python fnmatch模块.html":{"url":"文件处理/Python fnmatch模块.html","title":"Python fnmatch模块","keywords":"","body":"Python fnmatch模块 fnmatch主要是用来判断一个文件名是否匹配”Unix shell-style wildcards”这种模式,就是平常用的那种ls *.log这样，看是否匹配。 用法很简单，常用也就这两个函数fnmatch/filter: fnmatch. fnmatch(filename, pattern) 测试 filename 字符串是否匹配 pattern 字符串，返回 True 或 False。 通配符 含义 * 匹配任何数量的字符 ？ 匹配单个字符 [seq] 匹配 seq 中的字符 [!seq] 匹配除 seq 以外的任何的字符 fnmatch 这个库相对比较简单，只有4个函数，分别是fnmatch、fnmatchcase、filter和 translate，其中最常用的是fnmatch。主要功能如下： fnmatch：判断文件名是否符合特定的模式。 fnmatchcase：判断文件名是否符合特定的模式，区分大小写。 filter：返回输入列表中，符合特定模式的文件名列表。 translate：将通配符模式转换成正则表达式。 fnmatch和fnmatchcase用法相同，判断名称是否符合表达式，返回True or False >>> os.listdir(os.curdir) ['A1.jpg', 'a1.txt', 'a2.txt', 'aA.txt', 'b3.jpg', 'b2.jpg', 'b1.jpg'] >>> [ name for name in os.listdir(os.curdir) if fnmatch.fnmatch(name,'*.jpg') ] ['A1.jpg', 'b3.jpg', 'b2.jpg', 'b1.jpg'] >>> [ name for name in os.listdir(os.curdir) if fnmatch.fnmatch(name,\"[ab]*\") ] ['a1.txt', 'a2.txt', 'aA.txt', 'b3.jpg', 'b2.jpg', 'b1.jpg'] >>> [ name for name in os.listdir(os.curdir) if fnmatch.fnmatch(name,\"[!a]*\") ] ['A1.jpg', 'b3.jpg', 'b2.jpg', 'b1.jpg'] >>> [ name for name in os.listdir(os.curdir) if fnmatch.fnmatch(name,\"b?.jpg\") ] ['b3.jpg', 'b2.jpg', 'b1.jpg'] >>> [ name for name in os.listdir(os.curdir) if fnmatch.fnmatchcase(name,\"A?.jpg\") ] ['A1.jpg'] filter和fnmatch类似，只不过filter接受的第一个参数是一个文件名列表，返回符合表达式的列表(即：筛选) >>> name = os.listdir(os.curdir) >>> name ['A1.jpg', 'a1.txt', 'a2.txt', 'aA.txt', 'b3.jpg', 'b2.jpg', 'b1.jpg'] >>> fnmatch.filter(name,'*.txt') ['a1.txt', 'a2.txt', 'aA.txt'] # Update time： 2020-05-25 "},"文件处理/Python pathlib模块.html":{"url":"文件处理/Python pathlib模块.html","title":"Python pathlib模块","keywords":"","body":"Python pathlib模块 pathlib是 Python 内置库，Python 文档给它的定义是 Object-oriented filesystem paths（面向对象的文件系统路径）。pathlib 提供表示文件系统路径的类，其语义适用于不同的操作系统。路径类在纯路径之间划分，纯路径提供纯粹的计算操作而没有I / O，以及具体路径，它继承纯路径但也提供I / O操作。 基本用法 Path.iterdir()　　# 遍历目录的子目录或者文件 # 相当于os.listdir Path.is_dir()　　 # 判断是否是目录（文件夹） Path.glob()　　 # 过滤目录(返回生成器) Path.resolve()　　# 返回绝对路径 Path.exists()　　 # 判断路径是否存在 Path.open()　　 # 打开文件(支持with) Path.unlink()　　 # 删除文件或目录(目录非空触发异常) Path.glob() >>> sorted(Path('.').glob('*.py')) [PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib.py')] >>> sorted(Path('.').glob('*/*.py')) [PosixPath('docs/conf.py')] >>> sorted(Path('.').glob('**/*.py')) [PosixPath('build/lib/pathlib.py'), PosixPath('docs/conf.py'), PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib.py')] # The \"**\" pattern means \"this directory and all subdirectories, recursively\" Path.iterdir() 使用.iterdir方法获取当前文件下的所以文件. import pathlib from collections import Counter now_path = pathlib.Path.cwd() gen = (i.suffix for i in now_path.iterdir()) print(Counter(gen)) # Counter({'.py': 16, '': 11, '.txt': 1, '.png': 1, '.csv': 1}) 基本属性 Path.parts　　# 分割路径 类似os.path.split(), 不过返回元组 Path.drive　　# 返回驱动器名称 Path.root　　# 返回路径的根目录 Path.anchor　　# 自动判断返回drive或root Path.parents　　# 返回所有上级目录的列表 改变路径 Path.with_name()　　# 更改路径名称, 更改最后一级路径名 Path.with_suffix()　　# 更改路径后缀 PurePath.with_name(name) 返回一个新的路径并修改 name。如果原本路径没有 name，ValueError 被抛出: >>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz') >>> p.with_name('setup.py') PureWindowsPath('c:/Downloads/setup.py') >>> p = PureWindowsPath('c:/') >>> p.with_name('setup.py') Traceback (most recent call last): File \"\", line 1, in File \"/home/antoine/cpython/default/Lib/pathlib.py\", line 751, in with_name raise ValueError(\"%r has an empty name\" % (self,)) ValueError: PureWindowsPath('c:/') has an empty name 拼接路径 Path.joinpath()　　# 拼接路径 Path.relative_to()　　# 计算相对路径 测试路径 Path.match()　　# 测试路径是否符合pattern Path.is_dir()　　# 是否是文件 Path.is_absolute()　　# 是否是绝对路径 Path.is_reserved()　　# 是否是预留路径 Path.exists()　　# 判断路径是否真实存在 PurePath.is_absolute() 返回此路径是否为绝对路径。如果路径同时拥有驱动器符与根路径（如果风格允许）则将被认作绝对路径。 >>> PurePosixPath('/a/b').is_absolute() True >>> PurePosixPath('a/b').is_absolute() False >>> PureWindowsPath('c:/a/b').is_absolute() True >>> PureWindowsPath('/a/b').is_absolute() False >>> PureWindowsPath('c:').is_absolute() False >>> PureWindowsPath('//some/share').is_absolute() True PurePath.match(pattern) 将此路径与提供的通配符风格的模式匹配。如果匹配成功则返回 True，否则返回 False。 如果 pattern 是相对的，则路径可以是相对路径或绝对路径，并且匹配是从右侧完成的： >>> PurePath('a/b.py').match('*.py') True >>> PurePath('/a/b/c.py').match('b/*.py') True >>> PurePath('/a/b/c.py').match('a/*.py') False 其他方法 Path.cwd()　　# 返回当前目录的路径对象 Path.home()　　# 返回当前用户的home路径对象 Path.stat()　　# 返回路径信息, 同os.stat() Path.chmod()　　# 更改路径权限, 类似os.chmod() Path.expanduser()　　# 展开~返回完整路径对象 Path.mkdir()　　# 创建目录 Path.rename()　　# 重命名路径 Path.rglob()　　# 递归遍历所有子目录的文件 列出指定类型的文件 p = pathlib.Path('./') # print([str(x) for x in p.iterdir() ]) print([i for i in p.glob('*.py')]) #[WindowsPath('01.py'), WindowsPath('2018年Tibet温度统计.py'), # WindowsPath('lob.py')] 列出所有子目录 import pathlib p = pathlib.Path('./') print([x for x in p.iterdir() if x.is_dir()]) #当前目录所有文件 p = pathlib.Path('./') print([x for x in p.iterdir() ]) #[WindowsPath('.idea'), WindowsPath('01.py'), WindowsPath('数据下载.xlsx'), WindowsPath('数据下载3.xlsx')] #转化为字符串 p = pathlib.Path('./') print([str(x) for x in p.iterdir() ]) #['.idea', '01.py', '数据下载.xlsx', '数据下载3.xlsx'] 路径拼接 可以使用/符号来拼接路径 p = pathlib.Path('./') # print([str(x) for x in p.iterdir() ]) q = pathlib.Path(r'F:\\cookies\\python') print([str(q/i ) for i in p.glob('*.py')]) print([str(q.joinpath(i)) for i in p.glob('*.py')]) ''' ['F:\\\\cookies\\\\python\\\\01.py', 'F:\\\\cookies\\\\python\\\\2018年Tibet温度统计.py', 'F:\\\\cookies\\\\python\\\\lob.py'] ['F:\\\\cookies\\\\python\\\\01.py', 'F:\\\\cookies\\\\python\\\\2018年Tibet温度统计.py', 'F:\\\\cookies\\\\python\\\\lob.py'] ''' p = pathlib.Path(r'F:\\cookies\\python') q = p / 'learnPython' print(q) #F:\\cookies\\python\\learnPython data_folder = Path(\"source_data/text_files/\") file_to_open = data_folder / \"raw_data.txt\" 打开文件 >>> q = q / \"hello_world.py\" >>> with q.open() as f: >>> print(f.readline()) #!/usr/bin/env python PurePath PurePath 是一个纯路径对象，纯路径对象提供了实际上不访问文件系统的路径处理操作。有三种方法可以访问这些类，我们也称之为flavor。 一个通用的类，代表当前系统的路径风格（实例化为 PurePosixPath 或者 PureWindowsPath）: 产生Pure paths的三种方式 class pathlib.PurePath(*pathsegments) m=pathlib.PurePath('foo', 'some/path', 'bar') print(m) #foo\\some\\path\\bar n=pathlib.PureWindowsPath('foo', 'some/path', 'bar') print(n) #foo\\some\\path\\bar pa=pathlib.PurePath(pathlib.Path('foo'), pathlib.Path('bar')) print(pa) #foo\\bar pa=pathlib.PureWindowsPath('foo','bar') print(pa) #foo\\bar 如果参数为空，则默认指定当前文件夹 print(pathlib.PurePath()) #. 当同时指定多个绝对路径,则使用最后一个 >>> PureWindowsPath('c:/Windows', 'd:bar') PureWindowsPath('d:bar') class pathlib.PurePosixPath(*pathsegments) 一个 PurePath 的子类，路径风格不同于 Windows 文件系统: class pathlib.PureWindowsPath(*pathsegments) PurePath 的一个子类，路径风格为 Windows 文件系统路径: 常用属性和方法 返回驱动路径名称 >>> PureWindowsPath('c:/Program Files/').drive 'c:' 不太明白 print(pathlib.PureWindowsPath(r'c:/Program Files/').root) #\\ name 获取文件名 p = Path(r'd:\\test\\tt.txt.bk') p.name # 获取文件名 PureWindowsPath(r'd:\\test\\tt.txt.bk').name 获取文件的信息(size,createtime...) p = Path(r'd:\\test\\tt.txt') p.stat() # 获取详细信息 # os.stat_result(st_mode=33206, st_ino=562949953579011, st_dev=3870140380, st_nlink=1, st_uid=0, st_gid=0, st_size=0, st_atime=1525254557, st_mtime=1525254557, st_ctime=1525254557) p.stat().st_size # 文件大小 # 0 p.stat().st_ctime # 创建时间 # 1525254557.2090347 # 其他的信息也可以通过相同方式获取 p.stat().st_mtime # 修改时间 parents属性 获取不同等级的根目录 >>> p = PureWindowsPath('c:/foo/bar/setup.py') >>> p.parents[0] PureWindowsPath('c:/foo/bar') >>> p.parents[1] PureWindowsPath('c:/foo') >>> p.parents[2] PureWindowsPath('c:/') 此路径的逻辑父路径: PurePath.parent >>> p = PurePosixPath('/a/b/c/d') >>> p.parent PurePosixPath('/a/b/c') 访问个别部分:parts 一个元组，可以访问路径的多个组件: >>> p = PurePath('/usr/bin/python3') >>> p.parts ('/', 'usr', 'bin', 'python3') >>> p = PureWindowsPath('c:/Program Files/PSF') >>> p.parts ('c:\\\\', 'Program Files', 'PSF') PurePath.name属性 可以获取文件的名字，包含拓展名。 >>> PureWindowsPath('//some/share/setup.py').name 'setup.py' >>> PureWindowsPath('//some/share').name '' PurePath.suffix 最后一个组件的文件扩展名，如果存在:：PurePath.suffix、 路径的文件扩展名列表:PurePath.suffixes属性 >> PurePosixPath('my/library/setup.py').suffix '.py' >>> PurePosixPath('my/library.tar.gz').suffix '.gz' >>> PurePosixPath('my/library').suffix '' >>> PurePosixPath('my/library.tar.gar').suffixes ['.tar', '.gar'] >>> PurePosixPath('my/library.tar.gz').suffixes ['.tar', '.gz'] >>> PurePosixPath('my/library').suffixes [] PurePath.stem 最后一个路径组件，除去后缀: >>> PurePosixPath('my/library.tar.gz').stem 'library.tar' >>> PurePosixPath('my/library.tar').stem 'library' >>> PurePosixPath('my/library').stem 'library' PurePath.with_suffix(suffix) 返回一个新的路径并修改 suffix。如果原本的路径没有后缀，新的 suffix 则被追加以代替。如果 suffix 是空字符串，则原本的后缀被移除: >>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz') >>> p.with_suffix('.bz2') PureWindowsPath('c:/Downloads/pathlib.tar.bz2') >>> p = PureWindowsPath('README') >>> p.with_suffix('.txt') PureWindowsPath('README.txt') 参考 pathlib--- 面向对象的文件系统路径 超好用python库(Pathlib) Update time： 2020-05-25 "},"文件处理/Python os.walk遍历目录树.html":{"url":"文件处理/Python os.walk遍历目录树.html","title":"Python os.walk遍历目录树","keywords":"","body":"Python os.walk遍历目录树 假定你希望对某个文件夹中的所有文件改名， 包括该文件夹中所有子文件夹中的所有文件。也就是说， 你希望遍历目录树， 处理遇到的每个文件。写程序完成这件事，可能需要一些技巧。 好在， Python 提供了一个函数， 替你处理这个过程。 import os for dirpath, dirname, files in os.walk('.'): print(f'Found directory: {dirpath}') for file_name in files: print(file_name) os.walk()函数被传入一个字符串值，即一个文件夹的路径。 你可以在一个 for循环语句中使用 os.walk()函数，遍历目录树， 就像使用 range()函数遍历一个范围的数字一样。不像 range()，os.walk 的返回值是一个生成器(generator),也就是说我们需要不断的遍历它，来获得所有的内容, os.walk() 在循环的每次迭代中，返回 3 个值： 当前文件夹名称的字符串。 当前文件夹中子文件夹的字符串的列表。 当前文件夹中文件的字符串的列表。 所谓当前文件夹，是指 for 循环当前迭代的文件夹。程序的当前工作目录，不会因为 os.walk()而改变。 如果我们有如下的文件结构: a -> b -> 1.txt, 2.txt c -> 3.txt d -> 4.txt 5.txt for (root, dirs, files) in os.walk('a'): #第一次运行时，当前遍历目录为 a 所以 root == 'a' dirs == [ 'b', 'c', 'd'] files == [ '4.txt', '5.txt'] 。。。 # 接着遍历 dirs 中的每一个目录 b: root = 'a\\\\b' dirs = [] files = [ '1.txt', '2.txt'] # dirs为空，返回 # 遍历c c: root = 'a\\\\c' dirs = [] files = [ '3.txt' ] PS : 如果想获取文件的全路径，只需要 for f in files: path = os.path.join(root,f) # 遍历d d: root = 'a\\\\b' dirs = [] files = [] 遍历完毕，退出循环 import os for dirpath, dirname, files in os.walk('.'): print(f'Found directory: {dirpath}') for file_name in files: print(file_name) 在每次迭代中，会打印出它找到的子目录和文件的名称： Found directory: . test1.txt test2.txt Found directory: ./folder_1 file1.py file3.py file2.py Found directory: ./folder_2 file4.py file5.py file6.py Update time： 2020-05-25 "},"文件处理/Python os.scandir文件操作.html":{"url":"文件处理/Python os.scandir文件操作.html","title":"Python os.scandir文件操作","keywords":"","body":"Python os.scandir文件操作 scandir方法返回了一个DirEntry迭代器对象，它非常轻巧方便，并且能告诉你迭代文件的路径。之前案例中，我们检查了entry是一个文件或者是一个文件夹，与此同时，我们添加它的路径到列表中。 在 Python 3.5版本中，新添加了 os.scandir()方法，它是一个目录迭代方法。os.scandir() 的运行效率要比 os.walk 高。在 PEP 471 中，Python 官方也推荐我们使用 os.scandir() 来遍历目录。 具有以下属性和方法： `name·: 条目的文件名，相对于 scandir path 参数( 对应于 os.listdir的返回值) `path·: 输入路径 NAME ( 不一定是绝对路径) --与 os.path.join(scandir_path, entry.name) is_dir(, follow_symlinks=True): 类似于 pathlib.Path.is_dir()，但返回值在 DirEntry 对象上是缓存；大多数情况下不需要系统调用；如果 follow_symlinks 是 false，则不要跟随符号链接。 is_file(*, follow_symlinks=True): 类似于 pathlib.Path.is_file()，但返回值在 DirEntry 对象上是缓存；大多数情况下不需要系统调用；如果 follow_symlinks 是 false，则不要跟随符号链接。 is_symlink(): 类似 pathlib.Path.is_symlink()，但返回值缓存在 DirEntry 对象上；大多数情况下不需要系统调用 stat(*, follow_symlinks=True): 类似 os.stat()，但返回值缓存在 DirEntry 对象上；不需要对 Windows (。除了符号符号外) 进行系统调用；如果 follow_symlinks 是 false，则不跟随符号链接( 像 os.lstat() )。 inode(): 返回项的节点数；返回值在 DirEntry 对象上缓存 for i in os.scandir(r'.\\test'): print('Filename:',i.name,'Filepath:',i.path) import os import shutil data_path='D:/oanda/' target_path='D:/data/' with os.scandir(data_path) as it: for entry in it: if not entry.name.startswith('.') and entry.is_file(): file_name=entry.name pair='__'.join(file_name.split('__')[:2]) shutil.move(data_path+file_name,target_path+pair+'/'+file_name) print(file_name) Update time： 2020-05-25 "},"文件处理/Python 文件过滤.html":{"url":"文件处理/Python 文件过滤.html","title":"Python 文件过滤","keywords":"","body":"Python 文件过滤 endswith() 和 startswith()字符串方法 fnmatch.fnmatch() glob.glob() pathlib.Path.glob() 使用字符串方法 Python有几个内置 修改和操作字符串 的方法。当在匹配文件名时，其中的两个方法 .startswith()和 .endswith()非常有用。要做到这点，首先要获取一个目录列表，然后遍历。 import os for f_name in os.listdir('some_directory'): if f_name.endswith('.txt'): print(f_name) fnmatch.fnmatch() 使用 fnmatch进行简单文件名模式匹配 字符串方法匹配的能力是有限的。fnmatch 有对于模式匹配有更先进的函数和方法。我们将考虑使用 fnmatch.fnmatch()，这是一个支持使用*和 ?等通配符的函数。例如，使用 fnmatch 查找目录中所有 .txt 文件，你可以这样做: import os import fnmatch for f_name in os.listdir('some_directory'): if fnmatch.fnmatch(f_name, '*.txt'): print(f_name import os import fnmatch for f_name in os.listdir('some_directory'): if fnmatch.fnmatch(f_name, 'data_*_backup.txt'): print(f_name) Update time： 2020-05-25 "},"文件处理/Python JSON模块.html":{"url":"文件处理/Python JSON模块.html","title":"Python JSON模块","keywords":"","body":"Python JSON模块 程序都要求用户输入某种信息，如让用户存储游戏首选项或提供要可视化的数据。不管专注的是什么，程序都把用户提供的信息存储在列表和字典等数据结构中。用户关闭程序时，你几乎总是要保存他们提供的信息；一种简单的方式是使用模块 json 来存储数据。 模块 json 让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。还可以使用 json 在Python程序之间分享数据。 更重要的是， JSON 数据格式并非Python专用的，这让你能够将以 JSON 格式存储的数据与使用其他编程语言的人分享。 JSON（ JavaScript Object Notation）格式最初是为JavaScript开发的，但随后成了一种常见 格式，被包括Python在内的众多语言采用。 Json 模块提供了四个功能：dumps、dump、loads、load json.dump() 和 json.load() 来编码和解码JSON数据。 编写一个存储一组数字的简短程序，再编写一个将这些数字读取到内存中的程序。第一个程序将使用json.dump()来存储这组数字，而第二个程序将使用json.load()。 函数json.dump()接受两个实参：要存储的数据以及可用于存储数据的文件对象。 import json numbers = [2, 3, 5, 7, 11, 13] filename = 'numbers.json' with open(filename, 'w') as f_obj: json.dump(numbers, f_obj) dumps 实现python类型转化为json字符串，返回一个str对象。把一个Python对象编码转换成Json字符串，从python原始类型向json类型转化对照表如下： import json test_dict = {'bigberg': [7600, {1: [['iPhone', 6300], ['Bike', 800], ['shirt', 300]]}]} print(test_dict) print(type(test_dict)) #dumps 将数据转换成字符串 json_str = json.dumps(test_dict) print(json_str) print(type(json_str)) {'bigberg': [7600, {1: [['iPhone', 6300], ['Bike', 800], ['shirt', 300]]}]} {\"bigberg\": [7600, {\"1\": [[\"iPhone\", 6300], [\"Bike\", 800], [\"shirt\", 300]]}]} loads 把 json 格式字符串解码转换成Python对象, 从json到Python的类型转化对照如下： new_dict = json.loads(json_str) print(new_dict) print(type(new_dict)) {'bigberg': [7600, {'1': [['iPhone', 6300], ['Bike', 800], ['shirt', 300]]}]} dump 将Python内置类型序列化为 json 对象后写入文件 with open(\"record.json\",\"w\") as f: json.dump(new_dict,f) print(\"加载入文件完成...\") load 读取文件中 json 形式的字符串元素转化成 python 类型 with open(\"record.json\",'r') as load_f: load_dict = json.load(load_f) print(load_dict) load_dict['smallberg'] = [8200,{1:[['Python',81],['shirt',300]]}] print(load_dict) with open(\"record.json\",\"w\") as dump_f: json.dump(load_dict,dump_f) 重构 常会遇到这样的情况：代码能够正确地运行，但可做进一步的改进——将代码划分为一系列完成具体工作的函数。这样的过程被称为重构。重构让代码更清晰、更易于理解、更容易扩展。 #remember_me.py import json # 如果以前存储了用户名，就加载它 # 否则，就提示用户输入用户名并存储它 filename = 'username.json' try: with open(filename) as f_obj: username = json.load(f_obj) except FileNotFoundError: username = input(\"What is your name? \") with open(filename, 'w') as f_obj: json.dump(username, f_obj) print(\"We'll remember you when you come back, \" + username + \"!\") else: print(\"Welcome back, \" + username + \"!\") 函数greet_user()所做的不仅仅是问候用户，还在存储了用户名时获取它，而在没有存储用户名时提示用户输入一个。 下面来重构greet_user()，让它不执行这么多任务。为此，首先将获取存储的用户名的代码移到另一个函数中： import json def get_stored_username(): \"\"\"如果存储了用户名，就获取它\"\"\" filename = 'username.json' try: with open(filename) as f_obj: username = json.load(f_obj) except FileNotFoundError: return None else: return username def greet_user(): \"\"\"问候用户，并指出其名字\"\"\" username = get_stored_username() if username: print(\"Welcome back, \" + username + \"!\") else: username = input(\"What is your name? \") filename = 'username.json' with open(filename, 'w') as f_obj: json.dump(username, f_obj) print(\"We'll remember you when you come back, \" + username + \"!\") greet_user() 还需将greet_user()中的另一个代码块提取出来：将没有存储用户名时提示用户输入的代码放在一个独立的函数中： import json def get_stored_username(): \"\"\"如果存储了用户名，就获取它\"\"\" filename = 'username.json' try: with open(filename) as f_obj: username = json.load(f_obj) except FileNotFoundError: return None else: return username def get_new_username(): \"\"\"提示用户输入用户名\"\"\" username = input(\"What is your name? \") filename = 'username.json' with open(filename, 'w') as f_obj: json.dump(username, f_obj) return username def greet_user(): \"\"\"问候用户，并指出其名字\"\"\" username = get_stored_username() if username: print(\"Welcome back, \" + username + \"!\") else: username = get_new_username() print(\"We'll remember you when you come back, \" + username + \"!\") greet_user() Update time： 2020-08-13 "},"文件处理/Python JsonPath模块.html":{"url":"文件处理/Python JsonPath模块.html","title":"Python JsonPath模块","keywords":"","body":"Python JsonPath模块 jsonpath介绍 用来解析多层嵌套的json数据;JsonPath 是一种信息抽取类库，是从JSON文档中抽取指定信息的工具，提供多种语言实现版本，包括：Javascript, Python， PHP 和 Java。 jsonpath表达式总是和JSON结构结合在一起的 就如同 XML文档和XPath结合在一起一样。“根元素对象”在JsonPath中被称为$ 无论它是一个对象或数组。 使用方法 import jsonpath response = json.loads(reqs) jpid = jsonpath.jsonpath(response, '$..key_name') 其中：“$”表示最外层的{}，“..”表示模糊匹配,当传入不存在的key_name时,程序会返回false JsonPath表达式可以使用 点号 $.store.book[0].title 或使用 中括号 $['store']['book'][0]['title'] 操作符 n/a表not applicable不适用 JsonPath XPath 描述 $ / 根节点 @ . 过滤器断言（filter predicate）处理的 当前节点对象，类似于this * * 通配符，匹配所有的元素 .. // 递归搜索,不管位置，选择所有符合条件的条件 .or[] / 子节点 [] [] 迭代器标示（可以在里边做简单的迭代操作，如数组下标，根据内容选值等） [,] l 连接操作符在XPath结果合并其它结点集合。JsonPath允许name或者数组索引 ?() [] 应用过滤表示式,可进行过滤操作 [start:end:step] n/a 数组分割操作，XPath不支持 () n/a 脚本表达式，使用在脚本引擎下面,XPath不支持 n/a @ 属性访问字符,JsonPath不支持 n/a .. 父元素,JsonPath不支持 n/a () Xpath分组,JsonPath不支持 注意： [ ]在xpath表达式总是从前面的路径来操作数组，索引是从1开始。 使用JOSNPath的[]操作符操作一个对象或者数组，索引是从0开始。 函数 函数可以在路径尾部调用——函数的输入是路径表达式的输出。函数的输出取决于函数本身 函数 描述 输出 min() 获取数字数组的最小值 Double max() 获取数字数组的最大值 Double avg() 获取数字数组的平均值 Double stddev() 获取数字数组的标准差 Double length() 获取数组的长度 Integer 过滤运算符 过滤器是用于筛选数组的逻辑表达式。[?(@.age > 18)]是一个典型的过滤器，其中@代表当前被操作的节点。更多复杂的过滤语句可以通过&&和||创建出来。字符必须被但双引号闭合关闭 ([?(@.color == 'blue')] 或[?(@.color == \"blue\")])。 Operator Description == 等于（注意1不等于'1'） != 不等于 小于 小于等于 > 大于 >= 大于等于 =~ 匹配正则表达式[?(@.name =~ /foo.*?/i)] in 左值存在于右边[?(@.size in ['S', 'M'])] nin 左值不存在于右边 subsetof 左值是右边的子集[?(@.sizes subsetof ['S', 'M', 'L'])] size 左值（数组或字符串）的长度与右值相同 empty 左值(数组或字符串)为空 范例 { \"store\": { \"book\": [ { \"category\": \"reference\", \"author\": \"Nigel Rees\", \"title\": \"Sayings of the Century\", \"price\": 8.95 }, { \"category\": \"fiction\", \"author\": \"Evelyn Waugh\", \"title\": \"Sword of Honour\", \"price\": 12.99 }, { \"category\": \"fiction\", \"author\": \"Herman Melville\", \"title\": \"Moby Dick\", \"isbn\": \"0-553-21311-3\", \"price\": 8.99 }, { \"category\": \"fiction\", \"author\": \"J. R. R. Tolkien\", \"title\": \"The Lord of the Rings\", \"isbn\": \"0-395-19395-8\", \"price\": 22.99 } ], \"bicycle\": { \"color\": \"red\", \"price\": 19.95 } }, \"expensive\": 10 } JsonPath表达式 结果 $.store.book[*].author 所有book的author $..author 所有author(递归搜索) $.store.* store下的所有子节点包括(book和bicycle) $.store..price store下的所有price(递归搜索) $..book[2] 第三个book $..book[-2] 倒数的第二个book $..book[0,1] 第一、二个book $..book[:2] 索引0到2(不含2)的所有book $..book[1:2] 索引1到2(不含2)的所有book $..book[-2:] 索引-2到0(不含0)的所有book $..book[2:] 索引2到末尾的所有book $..book[?(@.isbn)] 带有isbn的所有book $.store.book[?(@.price price少于10的所有book $..book[?(@.price 价格少于expensive的所有book $..book[?(@.author =~ /.*REES/i)] book中author以REES结尾的所有值（不区分大小写） $..* 逐层列出json中的所有值，层级由外到内 $..book.length() book数组的长度 { \"store\": { \"book\": [{ \"category\": \"reference\", \"author\": \"Nigel Rees\", \"title\": \"Sayings of the Century\", \"price\": 8.95 }, { \"category\": \"fiction\", \"author\": \"Evelyn Waugh\", \"title\": \"Sword of Honour\", \"price\": 12.99 }, { \"category\": \"fiction\", \"author\": \"Herman Melville\", \"title\": \"Moby Dick\", \"isbn\": \"0-553-21311-3\", \"price\": 8.99 }, { \"category\": \"fiction\", \"author\": \"J. R. R. Tolkien\", \"title\": \"The Lord of the Rings\", \"isbn\": \"0-395-19395-8\", \"price\": 22.99 } ], \"bicycle\": { \"color\": \"red\", \"price\": 19.95 } } } XPath JsonPath Result /store/book/author $.store.book[*].author 所有book的author节点 //author $..author 所有author节点 /store/* $.store.* store下的所有节点，book数组和bicycle节点 /store//price $.store..price store下的所有price节点 //book[3] $..book[2] 匹配第3个book节点 //book[last()] $..book[(@.length-1)]，或 $..book[-1:] 匹配倒数第1个book节点 //book[position() $..book[0,1]，或 $..book[:2] 匹配前两个book节点 //book[isbn] $..book[?(@.isbn)] 过滤含isbn字段的节点 //book[price $..book[?(@.price 过滤price的节点 //* $..* 递归匹配所有子节点 参考 官方文档：http://goessner.net/articles/JsonPath Update time： 2020-08-13 "},"文件处理/Python shutil模块.html":{"url":"文件处理/Python shutil模块.html","title":"Python shutil模块","keywords":"","body":"Python shutil模块 shutil（或称为 shell 工具）模块中包含一些函数，让你在 Python 程序中复制、移动、改名和删除文件。要使用 shutil 的函数，首先需要 import shutil。 复制文件和文件夹 shutil 模块提供了一些函数，用于复制文件和整个文件夹。 shutil.copy() 调用 shutil.copy(source, destination)，将路径 source 处的文件复制到路径 destination处的文件夹（source 和 destination 都是字符串）。如果 destination 是一个文件名，它将作为被复制文件的新名字。该函数返回一个字符串，表示被复制文件的路径。 >>> import shutil, os >>> os.chdir('C:\\\\') >>> shutil.copy('C:\\\\spam.txt', 'C:\\\\delicious') 'C:\\\\delicious\\\\spam.txt' >>> shutil.copy('eggs.txt', 'C:\\\\delicious\\\\eggs2.txt') 'C:\\\\delicious\\\\eggs2.txt' 第一个 shutil.copy()调用将文件 C:\\spam.txt 复制到文件夹 C:\\delicious。返回值是刚刚被复制的文件的路径。 请注意，因为指定了一个文件夹作为目的地，原来的文件名 spam.txt 就被用作新复制的文件名。第二个 shutil.copy()调用也将文件C:\\eggs.txt 复制到文件夹 C:\\delicious，但为新文件提供了一个名字 eggs2.txt. shutil.copytree() shutil.copy()将复制一个文件， shutil.copytree()将复制整个文件夹，以及它包含的文件夹和文件。调用 shutil.copytree(source, destination)，将路径 source 处的文件夹，包括它的所有文件和子文件夹，复制到路径 destination 处的文件夹。 source 和destination 参数都是字符串。该函数返回一个字符串，是新复制的文件夹的路径。 >>> import shutil, os >>> os.chdir('C:\\\\') >>> shutil.copytree('C:\\\\bacon', 'C:\\\\bacon_backup') 'C:\\\\bacon_backup' shutil.copytree() 调用创建了一个新文件夹， 名为 bacon_backup，其中的内容与原来的 bacon 文件夹一样。现在你已经备份了非常非常宝贵的“bacon” 文件和文件夹的移动与改名 shutil.move() 调用 shutil.move(source, destination)， 将路径 source 处的文件夹移动到路径destination，并返回新位置的绝对路径的字符串。 如果 destination 指向一个文件夹， source 文件将移动到 destination 中， 并保持原来的文件名。 >>> import shutil >>> shutil.move('C:\\\\bacon.txt', 'C:\\\\eggs') 'C:\\\\eggs\\\\bacon.txt' 假定在 C:\\目录中已存在一个名为 eggs 的文件夹， 这个 shutil.move()调用就是说，“将 C:\\bacon.txt 移动到文件夹 C:\\eggs 中。 如果在 C:\\eggs 中原来已经存在一个文件 bacon.txt，它就会被覆写。因为用这种方式很容易不小心覆写文件， 所以在使用 move()时应该注意。 destination 路径也可以指定一个文件名。在下面的例子中， source 文件被移动并改名。 >>> shutil.move('C:\\\\bacon.txt', 'C:\\\\eggs\\\\new_bacon.txt') 'C:\\\\eggs\\\\new_bacon.txt' 这一行是说，“将 C:\\bacon.txt 移动到文件夹 C:\\eggs，完成之后，将 bacon.txt文件改名为 new_bacon.txt。” 永久删除文件和文件夹 shutil.rmtree(path) 利用 os 模块中的函数，可以删除一个文件或一个空文件夹。但利用 shutil 模块，可以删除一个文件夹及其所有的内容。 用 os.unlink(path)将删除 path 处的文件。 调用 os.rmdir(path)将删除 path 处的文件夹。该文件夹必须为空，其中没有任何文件和文件夹。 调用shutil.rmtree(path)将删除 path 处的文件夹，它包含的所有文件和文件夹都会被删除。 import os for filename in os.listdir(): if filename.endswith('.rxt'): os.unlink(filename) Update time： 2020-05-25 "},"文件处理/Python ZIP文件读取，解压.html":{"url":"文件处理/Python ZIP文件读取，解压.html","title":"Python ZIP文件读取，解压","keywords":"","body":"Python ZIP文件读取，解压 zipfile 模块是一个底层模块，是Python标准库的一部分。 zipfile 具有可以轻松打开和提取ZIP文件的函数。 要读取ZIP文件的内容，首先要做的是创建一个 ZipFile 对象。ZipFile 对象类似于使用 open() 创建的文件对象。ZipFile 也是一个上下文管理器，因此支持with语句： import zipfile with zipfile.ZipFile('data.zip', 'r') as zipobj: pass 这里创建一个ZipFile 对象，传入ZIP文件的名称并以读取模式下打开。 打开ZIP文件后，可以通过 zipfile 模块提供的函数访问有关存档文件的信息。 上面示例中的 data.zip 存档是从名为 data 的目录创建的，该目录包含总共5个文件和1个子目录： 要获取存档文件中的文件列表，请在 ZipFile 对象上调用 namelist()： import zipfile with zipfile.ZipFile('data.zip', 'r') as zipobj: zipobj.namelist() 生成一个文件列表: [‘file1.py’, ‘file2.py’, ‘file3.py’, ‘sub_dir/’, ‘sub_dir/bar.py’, ‘sub_dir/foo.py’] .namelist()返回存档文件中文件和目录的名称列表。要检索有关存档文件中文件的信息，使用 .getinfo()： import zipfile with zipfile.ZipFile('data.zip', 'r') as zipobj: bar_info = zipobj.getinfo('sub_dir/bar.py') print(bar_info.file_size) 提取ZIP文件 zipfile 模块允许你通过.extract()和.extractall()从ZIP文件中提取一个或多个文件。 默认情况下，这些方法将文件提取到当前目录。 它们都采用可选的路径参数，允许指定要将文件提取到的其他指定目录。 如果该目录不存在，则会自动创建该目录。 要从压缩文件中提取文件，请执行以下操作： >>> import zipfile >>> import os >>> os.listdir('.') ['data.zip'] >>> data_zip = zipfile.ZipFile('data.zip', 'r') >>> # 提取单个文件到当前目录 >>> data_zip.extract('file1.py') '/home/test/dir1/zip_extract/file1.py' >>> os.listdir('.') ['file1.py', 'data.zip'] >>> # 提所有文件到指定目录 >>> data_zip.extractall(path='extract_dir/') >>> os.listdir('.') ['file1.py', 'extract_dir', 'data.zip'] >>> os.listdir('extract_dir') ['file1.py', 'file3.py', 'file2.py', 'sub_dir'] >>> data_zip.close() 第三行代码是对 os.listdir()的调用，它显示当前目录只有一个文件 data.zip 。 接下来，以读取模式下打开 data.zip 并调用.extract()从中提取 file1.py 。 .extract() 返回提取文件的完整文件路径。 由于没有指定路径，.extract() 会将 file1.py 提取到当前目录。 下一行打印一个目录列表，显示当前目录现在包括除原始存档文件之外的存档文件。 之后显示了如何将整个存档提取到指定目录中。.extractall()创建 extract_dir 并将 data.zip 的内容提取到其中。 最后一行关闭ZIP存档文件。 从加密的文档提取数据 zipfile 支持提取受密码保护的ZIP。 要提取受密码保护的ZIP文件，请将密码作为参数传递给.extract()或.extractall()方法： >>> import zipfile >>> with zipfile.ZipFile('secret.zip', 'r') as pwd_zip: ... # 从加密的文档提取数据 ... pwd_zip.extractall(path='extract_dir', pwd='Quish3@o') 将以读取模式打开 secret.zip 存档。 密码提供给 .extractall() ，并且压缩文件内容被提取到 extract_dir 。 由于with语句，在完成提取后，存档文件会自动关闭。 Update time： 2020-05-25 "},"文件处理/Python with...as的用法.html":{"url":"文件处理/Python with...as的用法.html","title":"Python with...as的用法","keywords":"","body":"Python with...as的用法 with…as，就是个 python 控制流语句，像 if ，while一样。 with…as 语句是简化版的try except finally语句。 try…except语句 用于处理程序执行过程中的异常情况，比如语法错误、从未定义变量上取值等等，也就是一些 python 程序本身引发的异常、报错。比如你在 python下面输入 1 / 0： >>> 1/0 Traceback (most recent call last): File \"\", line 1, in ZeroDivisionError: division by zero 说白了就是为了防止一些报错影响你的程序继续运行，就用try语句把它们抓出来(捕获)。 try…except的标准格式： try: ## normal block except A: ## exc A block except: ## exc other block else: ## noError block 程序执行流程: –>执行normal block –>发现有A错误，执行 exc A block(即处理异常) –>结束 如果没有A错误呢？ –>执行normal block –>发现B错误，开始寻找匹配B的异常处理方法，发现A，跳过，发现except others(即except:)，执行exc other block –>结束 如果没有错误呢？ –>执行normal block –>全程没有错误，跳入else 执行noError block –>结束 Tips: 我们发现，一旦跳入了某条except语句，就会执行相应的异常处理方法(block)，执行完毕就会结束。不会再返回try的normal block继续执行了。 try: a = 1 / 2 #a normal number/variable print(a) b = 1 / 0 # an abnormal number/variable print(b) c = 2 / 1 # a normal number/variable print(c) except: print(\"Error\") 输出： 0.5 Error 结果是，先打出了一个0，又打出了一个Error。就是把ZeroDivisionError错误捕获了。 先执行try后面这一堆语句，由上至下： step1: a 正常，打印a. 于是打印出0.5 (python3.x以后都输出浮点数) step2: b, 不正常了，0 不能做除数，所以这是一个错误。直接跳到except报错去。于是打印了Error。 step3: 其实没有step3，因为程序结束了。c是在错误发生之后的b语句后才出现，根本轮不到执行它。也就看不到打印出的c了 但这还不是try/except的所有用法 except 后面还能跟表达式的! 所谓的表达式，就是错误的定义。也就是说，我们可以捕捉一些我们想要捕捉的异常。而不是什么异常都报出来。 异常分为两类： python标准异常 自定义异常 看看except都能捕捉到哪些python标准异常 try: a = 1 / 2 print(a) print(m) # 此处抛出python标准异常 b = 1 / 0 # 此后的语句不执行 print(b) c = 2 / 1 print(c) except NameError: print(\"Ops!!\") except ZeroDivisionError: print(\"Wrong math!!\") except: print(\"Error\") try…finallly语句 用于无论执行过程中有没有异常，都要执行清场工作。 好的 现在我们看看他俩合在一起怎么用!! try: execution block ##正常执行模块 except A: exc A block ##发生A错误时执行 except B: exc B block ##发生B错误时执行 except: other block ##发生除了A,B错误以外的其他错误时执行 else: if no exception, jump to here ##没有错误时执行 finally: final block ##总是执行 tips: 注意顺序不能乱，否则会有语法错误。如果用else就必须有except，否则会有语法错误。 try: a = 1 / 2 print(a) print(m) # 抛出NameError异常 b = 1 / 0 print(b) c = 2 / 1 print(c) except NameError: print(\"Ops!!\") # 捕获到异常 except ZeroDivisionError: print(\"Wrong math!!\") except: print(\"Error\") else: print(\"No error! yeah!\") finally: # 是否异常都执行该代码块 print(\"Successfully!\") with…as语句 with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭／线程中锁的自动获取和释放等。 with as 语句的结构如下： with expression [as variable]: with-block with 工作原理 （１）紧跟with后面的语句被求值后，返回对象的“–enter–()”方法被调用，这个方法的返回值将被赋值给as后面的变量； （２）当with后面的代码块全部被执行完之后，将调用前面返回对象的“–exit–()”方法。 with工作原理代码示例： class Sample: def __enter__(self): print \"in __enter__\" return \"Foo\" def __exit__(self, exc_type, exc_val, exc_tb): print \"in __exit__\" def get_sample(): return Sample() with get_sample() as sample: print \"Sample: \", sample 代码的运行结果如下： in __enter__ Sample: Foo in __exit__ 可以看到，整个运行过程如下： （１）enter()方法被执行； （２）enter()方法的返回值，在这个例子中是”Foo”，赋值给变量sample； （３）执行代码块，打印sample变量的值为”Foo”； （４）exit()方法被调用； 【注：】exit()方法中有３个参数， exc_type, exc_val, exc_tb，这些参数在异常处理中相当有用。 exc_type：　错误的类型 exc_val：　错误类型对应的值 exc_tb：　代码中错误发生的位置 示例代码： class Sample(): def __enter__(self): print('in enter') return self def __exit__(self, exc_type, exc_val, exc_tb): print \"type: \", exc_type print \"val: \", exc_val print \"tb: \", exc_tb def do_something(self): bar = 1 / 0 return bar + 10 with Sample() as sample: sample.do_something() 程序输出结果： in enter Traceback (most recent call last): type: val: integer division or modulo by zero File \"/home/user/cltdevelop/Code/TF_Practice_2017_06_06/with_test.py\", line 36, in tb: sample.do_something() File \"/home/user/cltdevelop/Code/TF_Practice_2017_06_06/with_test.py\", line 32, in do_something bar = 1 / 0 ZeroDivisionError: integer division or modulo by zero Process finished with exit code 1 实际上，在with后面的代码块抛出异常时，exit()方法被执行。开发库时，清理资源，关闭文件等操作，都可以放在exit()方法中。 总之，with-as表达式极大的简化了每次写finally的工作，这对代码的优雅性是有极大帮助的。 如果有多项，可以这样写： With open('1.txt') as f1, open('2.txt') as f2: do something Update time： 2020-05-25 "},"正则表达式/":{"url":"正则表达式/","title":"python 正则表达式","keywords":"","body":"python 正则表达式 Update time： 2020-05-25 "},"正则表达式/正则表达式基础语法.html":{"url":"正则表达式/正则表达式基础语法.html","title":"python 正则表达式基础语法","keywords":"","body":"python 正则表达式基础语法 literal 功能：匹配文本字符串的字面值 literal 例子：foo re1|re2 功能：匹配正则表达式 re1 或者 re2 例子：foo|bar . 功能：匹配任何字符(除了\\n 之外) 表达式：f.o 匹配：在字母“f”和“o”之间的任意一个字符;例如 fao、f9o、f#o 等 表达式：.. 匹配：任意两个字符 ^ 功能：匹配字符串起始部分 表达式：^From 匹配：任何以 From 作为起始的字符串 $ 功能：匹配字符串终止部分 表达式：/bin/*sh$ 匹配：任何以/bin/tcsh 作为结尾的字符串 * 功能：匹配 0 次或者多次前面出现的正则表达式 例子： 表达式：5* 匹配：5 或 555 或 没有5 + 功能：匹配 1 次或者多次前面出现的正则表达式 表达式：[a-z]+\\.com 匹配：a.com 或 abc.com 不匹配：.com ? 功能：匹配 0 次或者 1 次前面出现的正则表达式 表达式：goo? 匹配：goo 或 gooo 不匹配：goooo {N} 功能：匹配 N 次前面出现的正则表达式 表达式：[0-9]{3} 匹配：123 或 999 不匹配：1234 或 12 {M,N} 功能：匹配 M~N 次前面出现的正则表达式 表达式：[0-9]{1,3} 匹配：1 或 12 或 123 不匹配：1234 […] 功能：匹配来自字符集的任意单一字符 表达式：[aeiou] 匹配：a 或 e 或 i 或 o 或 u 不匹配：f 或 s 等 […x−y…] 功能：匹配 x~y 范围中的任意单一字符 表达式：[0-9] 匹配：1 或 5 或 8 （0到9之间的单个数字） 不匹配：a 表达式：[A-Za-z] 匹配：A, F, h 不匹配：5 [^…] 功能：不匹配此字符集中出现的任何一个字符，包括某一范围的字符(如果在此字符集中出现) 表达式：[^aeiou]good 匹配：sgood 不匹配：agood 或 egood (*|+|?|{})? 功能：用于匹配上面频繁出现/重复出现符号的非贪婪版本(*、+、?、{}) 解释： 贪婪模式：就是在整个表达式匹配成功的前提下，尽可能多的匹配，也就是所谓的“贪婪”，通俗点讲，就是看到想要的，有多少就捡多少，除非再也没有想要的了。 非贪婪模式：就是在整个表达式匹配成功的前提下，尽可能少的匹配，也就是所谓的“非贪婪”，通俗点讲，就是找到一个想要的捡起来就行了，至于还有没有没捡的就不管了。（带问号的） 字符串：'Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8' 表达式：.+(\\d+-\\d+-\\d+) 结果： Match 1 Full match 0-61 `Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8` Group 1. 56-61 `4-6-8` （Group1 匹配到的是`4-6-8`） 表达式：.+?(\\d+-\\d+-\\d+) # 注意，在加号后面，加了\"?\" 结果： Match 1 Full match 0-61 `Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8` Group 1. 47-61 `1171590364-6-8` （Group1 匹配到的是`1171590364-6-8`） 字符串：aatest1bbtest2cc 表达式：.* 结果：test1bbtest2 表达式：.*? 结果：test1（这里指的是一次匹配结果，所以没包括test2） 例子 比如有一段html片段，this is first labelthe second label,如何匹配出每个a标签中的内容，下面来看下最短与最长的区别。 >>> import re >>> str = 'this is first labelthe second label' >>> print re.findall(r'(.*?)', str) # 最短匹配 ['this is first label', 'the second label'] >>> print re.findall(r'(.*)', str) ['this is first labelthe second label'] 例子中，模式r'(.\\*?)' 的意图是匹配被和包含的文本，但是正则表达式中 * 操作符是贪婪的，因此匹配操作会查找出最长的可能。 但是在 *操作符后面加上 \\？操作符，这样使得匹配变成非贪婪模式，从而得到最短匹配。 (…) 功能：匹配封闭的正则表达式，然后另存为子组 例子：([0-9]{3})?,f(oo|u)bar \\d 功能：匹配任何十进制数字，与[0-9]一致(\\D 与\\d 相反，不匹配任何非数值型的数字) 例子：data\\d+.txt \\w 功能：匹配任何字母数字字符，与[A-Za-z0-9]相同(\\W 与之相反) 例子：[A-Za-z]\\w+ \\s 功能：匹配任何空格字符，与[\\n\\t\\r\\v\\f]相同(\\S 与之相反) 例子：of\\sthe \\b 功能：匹配任何单词边界(\\B 与之相反) 表达式：\\bThe\\b 意思：仅仅匹配单词 the。 匹配：\"a the b\" 不区别：\"fathe\" 表达式：\\Bthe 意思：任何包含但并不以 the 作为起始的字符串。 匹配：\"fathe\" 不区别：\"a the b\" \\N 功能：匹配已保存的子组 N(参见上面的(…)) 例子：price: \\16 \\c 功能：转义表达式用字符 例子： 表达式：data.txt 匹配：data.txt \\A(\\Z) 功能：匹配字符串的起始(结束)(另见上面介绍的^和$) 例子：\\ADear (?#comment) 功能：此处并不做匹配，只是作为注释 （没看到哪里用过） (?=) 解释 如果表达式为“(?=.com)”，意思是：一个字符串后面跟着“.com”才做匹配操作，并不使用任何目标字符串 (?!) 解释 如果表达式为“(?!.net)”，意思是：一个字符串后面不是跟着“.net”才做匹配操作 (? 解释 如果表达式为“(? (? 解释 如果表达式为“(? (?:) 功能 表示一个匹配不用保存的分组。 解释 当表达式中有圆括号“()”出现时，表示把匹配“()”内规则的字符串，保存成一个分组。保存成分组后，就可以使用 result.group(1) 来访问这个分组。当有多个分组时，就可以使用 result.group(N) 来访问第N个分组。 在分组内加“?:”的话（例如：(?:a) ），就表示匹配到“a”后，不把“a”保存到分组中。也就是说 result.group(1) 就取不到这个“a”了。 表达式：(?:https?|ftp)://([^/\\r\\n]+)(/[^\\r\\n]*)? 结果1: Match \"https://stackoverflow.com/\" Group 1: \"stackoverflow.com\" Group 2: \"/\" 结果2: Match \"https://stackoverflow.com/questions/tagged/regex\" Group 1: \"stackoverflow.com\" Group 2: \"/questions/tagged/regex\" (?(id/name)Y|N ) 功能： 如果分组所提供的 id 或者 name(名称)存在，就返回正则表达式的条件匹配 Y，如 果不存在，就返回 N;|N 是可选项。 解释 当有一个分组被保存后，就可以通过 result.group(1) 取得这个分组的值。在表达式中，可以“(1)”的方式，取出被保存的分组。“?(1)”表示，如果能取到“分组1”，就使用“Y”规则，否则就使用“X”规则。（当然，也可以使用“?(name)”的方式） 表达式：(?:x)y 结果1： Match \"xy\" Full match 0-2 `xy` （没有group(1)，也就是说“x”没有被保存到分组内） .* 或.+ 功能：\".*\" 是匹配所有字符，可以一个字符没有；\".+\" 是区别所有字符，必须有一个字符。 表达式：.*a 匹配：a 或 1a 不匹配：b 表达式：.+a 匹配：1a 或 aaaaa 不匹配：a 验证URL text = \"https://baike.baidu.com/item/Python/407313?fr=aladdin\" ret = re.match('(http|https|ftp)://[^\\s]+',text) #[^\\s]匹配非空白字符 print(ret.group()) Update time： 2020-05-25 "},"正则表达式/正则表达式 常用函数.html":{"url":"正则表达式/正则表达式 常用函数.html","title":"python 正则表达式 常用函数","keywords":"","body":"python 正则表达式 常用函数 re.compile(strPattern[, flag]) 这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。 第二个参数flag是匹配模式，取值可以使用按位或运算符'|'表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile('pattern', re.I | re.M)与re.compile('(?im)pattern')是等价的。 可选值有： re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同） M(MULTILINE): 多行模式，改变'^'和'$'的行为（参见上图） S(DOTALL): 点任意匹配模式，改变'.'的行为 L(LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 U(UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性 X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的： a = re.compile(r\"\"\"\\d + # the integral part \\. # the decimal point \\d * # some fractional digits\"\"\", re.X) b = re.compile(r\"\\d+\\.\\d*\") 1、match re.match(pattern, string[, flags]) 这个方法将从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。 pos和endpos的默认值分别为0和len(string)；re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。 注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符'$'。 2、search re.search(pattern, string[, flags]) 这个方法用于查找字符串中可以匹配成功的子串。从string的pos下标处起尝试匹配pattern，如果pattern结束时仍可匹配，则返回一个Match对象；若无法匹配，则将pos加1后重新尝试匹配；直到pos=endpos时仍无法匹配则返回None。 pos和endpos的默认值分别为0和len(string))；re.search()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。 3、findall re.findall(pattern, string[, flags]) 返回string中所有与pattern相匹配的全部字串，返回形式为数组。 当一条语句含有多个匹配值的时候返回的为元组组成的列表 表格 学号姓名 1001杨秀璋 1002严娜 # coding=utf-8 import re import urllib content = urllib.urlopen(\"test.html\").read() #打开本地文件 #获取间内容 res = r'(.*?)' texts = re.findall(res, content, re.S|re.M) for m in texts: print m \"\"\" texts: ['学号姓名', '1001杨秀璋', '1002严娜'] \"\"\" #直接获取间内容 res = r'(.*?)(.*?)' texts = re.findall(res, content, re.S|re.M) \"\"\" texts: [('1001', '杨秀璋'), ('1002', '严娜')] \"\"\" for m in texts: print m[0],m[1] 4、finditer re.finditer(pattern, string[, flags]) 返回 string 中所有与 pattern 相匹配的全部字串，返回形式为迭代器。 若匹配成功，match() / search()返回的是Match对象，finditer()返回的也是Match对象的迭代器，获取匹配结果需要调用Match对象的group()、groups或group(index)方法。 5、split split(string[, maxsplit]) | re.split(pattern, string[, maxsplit]): 按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。 import re p = re.compile(r'\\d+') print p.split('one1two2three3four4') ### output ### # ['one', 'two', 'three', 'four', ''] group()、groups()与group(index)的区别 ，如下所示： >>> import re >>> s = '23432werwre2342werwrew' >>> p = r'(\\d*)([a-zA-Z]*)' >>> m = re.match(p,s) >>> m.group() '23432werwre' >>> m.group(0) '23432werwre' >>> m.group(1) '23432' >>> m.group(2) 'werwre' >>> m.groups() ('23432', 'werwre') >>> m = re.findall(p,s) >>> m [('23432', 'werwre'), ('2342', 'werwrew'), ('', '')] >>> p=r'(\\d+)' >>> m=re.match(p,s) >>> m.group() '23432' >>> m.group(0) '23432' >>> m.group(1) '23432' >>> m.groups() ('23432',) >>> m=re.findall(p,s) >>> m ['23432', '2342'] group()：母串中与模式pattern匹配的子串； group(0)：结果与group()一样； groups()：所有group组成的一个元组，group(1)是与patttern中第一个group匹配成功的子- 串，group(2)是第二个，依次类推，如果index超了边界，抛出IndexError； findall()：返回的就是所有groups的数组，就是group组成的元组的数组，母串中的这一撮组成一个元组，那一措组成一个元组，这些元组共同构成一个list，就是findall()的返回结果。另，如果groups是只有一个元素的元组，findall的返回结果是子串的list，而不是元组的list了。例子 s =\"1113446777\" 用正则表达式把s分为1111, 3, 44, 6, 777 import re s =\"1113446777\" m=re.findall(r'(\\d)\\1*',s) print(m) #['1', '3', '4', '6', '7'] m = re.search(r'(\\d)\\1*',s) print(m.group()) #111 print(m.groups()) #('1',) print(m.groups(0)) #('1',) print(m.groups(1)) #('1',) >>> m.group(2) Traceback (most recent call last): File \"\", line 1, in IndexError: no such group >>> m=re.finditer(r'(\\d)\\1*',s) >>> m.next().group() '111' >>> m.next().group() '3' >>> m.next().group() '44' >>> m.next().group() '6' >>> m.next().group() '777' >>> m.next().group() Traceback (most recent call last): File \"\", line 1, in StopIteration >>> p = r'(\\d)\\1+([a-zA-Z]+)' >>> s = '1111werwrw3333rertert4444' >>> p = r'(\\d)\\1+([a-zA-Z]*)' >>> import re >>> re.findall(p,s) [('1', 'werwrw'), ('3', 'rertert'), ('4', '')] >>> m = re.search(p,s) >>> m.group() '1111werwrw' >>> m.group(1) '1' >>> m.group(2) 'werwrw' >>> m.groups() ('1', 'werwrw') >>> m = re.finditer(p,s) >>> m.next().group() '1111werwrw' >>> m.next().group() '3333rertert' >>> m.next().group() '4444' >>> m.next().group() Traceback (most recent call last): File \"\", line 1, in StopIteration group([group1, …]): 获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。 groups([default]): 以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 参考 Python正则表达式指南 Update time： 2020-05-26 "},"正则表达式/正则表达式 re.sub.html":{"url":"正则表达式/正则表达式 re.sub.html","title":"python 正则表达式 re.sub()","keywords":"","body":"python 正则表达式 re.sub() re.sub()替换功能 re.sub() 用于替换字符串中的匹配项。 re.sub(pattern, repl, string[, count]) 使用 repl 替换 string 中每一个匹配的子串后返回替换后的字符串。 当repl 是一个字符串时，可以使用 \\id或\\g、\\g引用分组，但不能使用编号 0。 当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。 count用于指定最多替换次数，不指定时全部替换。 re.sub()是个正则表达式方面的函数，用来实现通过正则表达式，实现比普通字符串的 replace 更加强大的替换功能。简单的替换功能可以使用replace()实现。 def main(): text = '123, word!' text1 = text.replace('123', 'Hello') print(text1) if __name__ == '__main__': main() # Hello, wold! 如果通过re.sub()函数则可以匹配任意的数字，并将其替换： import re def main(): content = 'abc124hello46goodbye67shit' list1 = re.findall(r'\\d+', content) print(list1) mylist = list(map(int, list1)) print(mylist) print(sum(mylist)) print(re.sub(r'\\d+[hg]', 'foo1', content)) print() print(re.sub(r'\\d+', '456654', content)) if __name__ == '__main__': main() # ['124', '46', '67'] # [124, 46, 67] # 237 # abcfoo1ellofoo1oodbye67shit # abc456654hello456654goodbye456654shit split()分割方法 使用正则表达式来分割字符串。 text = \"hello world ni hao\" ret = re.split('\\W',text) print(ret) >> [\"hello\",\"world\",\"ni\",\"hao\"] >>> import re >>> formula = 'YOU == ME**2' >>> re.split('[A-Z]+', formula) ['', ' == ', '**2'] 这里，[A-Z]+中的加号+表示，至少1次。[A-Z]+则表示，至少出现 1 个大写字母。 re.split('[A-Z]+', formula)的含义是，将 formula 字符串分解。分解的规则是，将 formula 字符串中的1个及以上字母去掉，返回剩余字符的1个列表。 Update time： 2020-05-25 "},"正则表达式/正则表达式 re.match与re.search.html":{"url":"正则表达式/正则表达式 re.match与re.search.html","title":"python 正则表达式 match()与search()","keywords":"","body":"python 正则表达式 match()与search() ﻿## re.match() import re def main(): username = 'jerry_friend' m = re.match(r'\\w{8,20}', username) print(m) print(m.span()) # span()，如果匹配值成功，则返回匹配成功的下标 print(m.group()) # group（）， 匹配成功，返回匹配成功后的部分 if __name__ == '__main__': main() ''' (0, 12) jerry_friend ''' 注意：re.match()函数只检测 RE 是不是在 string 的开始位置匹配，也就是说 match() 只有在0位置匹配成功的话才有返回， 如果不是开始位置匹配成功的话，match()就返回none, 不能和span()、group()搭配使用，否则会报错。以下的写法是错误的。 import re def main(): username = '#jerry_friend' m = re.match(r'\\w{8,20}', username) print(m) print(m.span()) # span()，如果匹配值成功，则返回匹配成功的下标 print(m.group()) # group（）， 匹配成功，返回匹配成功后的部分 if __name__ == '__main__': main() ''' None AttributeError: 'NoneType' object has no attribute 'span' ''' 下面的程序也会报错，那是应为能匹配的只有‘jerry’，总共匹配了5次，然而正则表达式中要求匹配 8 到 20 次，所以匹配的结果返回的是None。 import re def main(): username = 'jerry#friend' m = re.match(r'\\w{8,20}', username) print(m) print(m.span()) print(m.group()) if __name__ == '__main__': main() ''' None print(m.span()) AttributeError: 'NoneType' object has no attribute 'span' ''' re.search() 注意：search()会扫描整个 string 查找匹配；search()可以不从 0 位置开始匹配，这就是和match()的区别。以上的‘username = #jerry_friend’，如果选择使用search()，那么是不会返回None的。 if __name__ == '__main__': main() ''' (1, 13) jerry_friend ''' 注意，如果 string中 存在多个 pattern 子串，只返回第一个。 Update time： 2020-05-25 "},"正则表达式/正则表达式 re.findall与re.finditer.html":{"url":"正则表达式/正则表达式 re.findall与re.finditer.html","title":"python 正则表达式 re.findall()与re.finditer()","keywords":"","body":"python 正则表达式 re.findall()与re.finditer() ﻿## 正则表达式re.findall()与re.finditer()的区别 re.findall()如果可以匹配返回的是一个列表，re.finditer()返回的是一个迭代器，需要对其进行遍历，才能获取数据。 def findall(pattern, string, flags=0): \"\"\"Return a list of all non-overlapping matches in the string. If one or more capturing groups are present in the pattern, return a list of groups; this will be a list of tuples if the pattern has more than one group. Empty matches are included in the result.\"\"\" return _compile(pattern, flags).findall(string) import re def main(): content = '八神是我的好朋友，他的手机电话是18381665314， 他的QQ是1911966573， 他女朋友的电话是18381665315, QQ:1911966574 ！' regex = re.compile(r'\\d{11}') tels = regex.findall(content) print(tels) if __name__ == '__main__': main() # ['18381665314', '18381665315'] 用以下的finditer()代码，输出的效果是等价的. import re def main(): content = '八神是我的好朋友，他的手机电话是18381665314， 他的QQ是1911966573， 他女朋友的电话是18381665315, QQ:1911966574 ！' regex = re.compile(r'\\d{11}') tels_obj = regex.finditer(content) print(tels_obj) # tels_list = [] for tel in tels_obj: tels_list.append(tel.group()) print(tels_list) if __name__ == '__main__': main() # ['18381665314', '18381665315'] Update time： 2020-05-25 "},"正则表达式/正则表达式 re.compile.html":{"url":"正则表达式/正则表达式 re.compile.html","title":"python 正则表达式 re.compile()","keywords":"","body":"python 正则表达式 re.compile() ﻿## 正则表达式re.compile() 对于一些经常要用到的正则表达式，可以使用 compile 进行编译，后期再使用的时候可以直接拿过来用，执行效率会更快。而且 compile还可以指定flag=re.VERBOSE，在写正则表达式的时候可以做好注释。 compile()的定义： compile(pattern, flags=0) Compile a regular expression pattern, returning a pattern object. text = \"the number is 20.50\" r = re.compile(r\"\"\" \\d+ # 小数点前面的数字 \\.? # 小数点 \\d* # 小数点后面的数字 \"\"\",re.VERBOSE) ret = re.search(r,text) print(ret.group()) 从compile()函数的定义中，可以看出返回的是一个匹配对象，它单独使用就没有任何意义，需要和findall(), search(),match(）搭配使用。 compile()与findall()一起使用，返回一个列表。 import re def main(): content = 'Hello, I am Jerry, from Chongqing, a montain city, nice to meet you……' regex = re.compile('\\w*o\\w*') x = regex.findall(content) print(x) if __name__ == '__main__': main() # ['Hello', 'from', 'Chongqing', 'montain', 'to', 'you'] compile()与match()一起使用，可返回一个class、str、tuple。但是一定需要注意 match()，从位置 0 开始匹配，匹配不到会返回 None，返回 None 的时候就没有span/group属性了，并且与group使用，返回一个单词‘Hello’后匹配就会结束。 import re def main(): content = 'Hello, I am Jerry, from Chongqing, a montain city, nice to meet you……' regex = re.compile('\\w*o\\w*') y = regex.match(content) print(y) print(type(y)) print(y.group()) print(y.span()) if __name__ == '__main__': main() ''' Hello (0, 5) ''' compile()与search()搭配使用, 返回的类型与match()差不多， 但是不同的是search(), 可以不从位置 0 开始匹配。但是匹配一个单词之后，匹配和 match()一样，匹配就会结束。 import re def main(): content = 'Hello, I am Jerry, from Chongqing, a montain city, nice to meet you……' regex = re.compile('\\w*o\\w*') z = regex.search(content) print(z) print(type(z)) print(z.group()) print(z.span()) if __name__ == '__main__': main() ''' Hello (0, 5) ''' Update time： 2020-05-25 "},"正则表达式/正则表达式 flags 参数.html":{"url":"正则表达式/正则表达式 flags 参数.html","title":"python 正则表达式 flags 参数","keywords":"","body":"python 正则表达式 flags 参数 flags参数 re.I IGNORECASE 忽略字母大小写 re.L LOCALE 影响 “w, “W, “b, 和 “B，这取决于当前的本地化设置。 re.M MULTILINE 使用本标志后，‘^’和‘$’匹配行首和行尾时，会增加换行符之前和之后的位置。 re.S DOTALL 使 “.” 特殊字符完全匹配任何字符，包括换行；没有这个标志， “.” 匹配除了换行符外的任何字符。 re.X VERBOSE 当该标志被指定时，在 RE 字符串中的空白符被忽略，除非该空白符在字符类中或在反斜杠之后。 它也可以允许你将注释写入 RE，这些注释会被引擎忽略； 注释用 “#”号 来标识，不过该符号不能在字符串或反斜杠之后。 忽略大小写 import re text = '我爱Python我爱python' pat1 = 'p' # search r1 = re.findall(pattern=pat1, string=text, flags=re.I) print(r1) #[‘P’, ‘p’] 多行模式 import re text = '我爱数学\\n我爱Python\\n我爱python' pat1 = '^我' # search r1 = re.findall(pattern=pat1, string=text) r2 = re.findall(pattern=pat1, string=text, flags=re.M) print(r1) print(r2) #[‘我’] [‘我’, ‘我’, ‘我’] 匹配任何字符 import re text = ''' 我爱Python 我爱pandas ''' pat1 = '.我' # search r1 = re.findall(pattern=pat1, string=text, flags=re.S) print(r1) r2 = re.findall(pattern=pat1, string=text) print(r2) #[’\\n我’, ‘\\n我’] #[] Update time： 2020-05-26 "},"正则表达式/正则表达式 去优先级，选择.html":{"url":"正则表达式/正则表达式 去优先级，选择.html","title":"python 正则表达式 去优先级，选择","keywords":"","body":"python 正则表达式 去优先级，选择 选择 用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 ?: 放在第一个选项前来消除这种副作用。 其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 去优先级 import re ret = re.findall('www.(baidu|oldboy).com', 'www.oldboy.com') print(ret) # ['oldboy'] 这是因为findall会优先把匹配结果组里内容返回,如果想要匹配结果,取消权限即可 ret = re.findall('www.(?:baidu|oldboy).com', 'www.oldboy.com') print(ret) # ['www.oldboy.com'] import re pattern_0 = re.compile(r'(.*?(省|自治区|特别行政区|市))') pattern_1 = re.compile(r'(.*?(?:省|自治区|特别行政区|市))') s = '江苏省苏州市虎丘区马涧路靠近白马涧花园' result_0 = re.search(pattern_0, s).groups() result_1 = re.search(pattern_1, s).groups() In[242]: result_0 Out[242]: ('江苏省', '省') In[243]: result_1 Out[243]: ('江苏省',) result_0中的分组结果中有两个元素，而第二个元素‘省’不是我们需要的，所以在pattern_1的括号中增加 ?: ， 也就是(?:省|自治区|特别行政区|市)， 这样，括号中的内容就不会被捕获。 反向引用 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用\\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 可以使用非捕获元字符?:、?=或?!来重写捕获，忽略对相关匹配的保存。 正则表达式中，放在圆括号()中的表示是一个组。然后你可以对整个组使用一些正则操作,例如重复操作符。 要注意的是, 只有圆括号()才能用于形成组。”“用于定义字符集。”{}”用于定义重复操作。 当用()定义了一个正则表达式组后, 正则引擎则会把被匹配的组按照顺序编号,存入缓存。这样我们想在后面对已经匹配过的内容进行引用时，就可以用\\数字 的方式或者是通过命名分组进行(?P=name) 进行引用。\\1 表示引用第一个分组， \\2引用第二个分组,以此类推， \\n引用第 n 个组。而 \\0 则引用整个被匹配的正则表达式本身。这些引用都必须是在正则表达式中才有效，用于匹配一些重复的字符串。 #通过命名分组进行后向引用 >>> re.search(r'(?Pgo)\\s+(?P=name)\\s+(?P=name)', 'go go go').group('name') 'go' #通过默认分组编号进行后向引用 >>> re.search(r'(go)\\s+\\1\\s+\\1', 'go go go').group() 'go go go' Update time： 2020-05-25 "},"正则表达式/正则表达式 模式匹配与正则表达式一.html":{"url":"正则表达式/正则表达式 模式匹配与正则表达式一.html","title":"python 正则表达式 模式匹配与正则表达式 一","keywords":"","body":"python 正则表达式 模式匹配与正则表达式 一 用正则表达式查找文本模式 正则表达式， 简称为 regex， 是文本模式的描述方法。例如， \\d 是一个正则表达式， 表示一位数字字符，即任何一位 0 到 9 的数字。 Python 使用正则表达式\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d， 来匹配前面 isPhoneNumber()函数匹配的同样文本： 3 个数字、一个短横线、 3 个数字、一个短横线、 4 个数字。所有其他字符串都不能匹配\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d 正则表达式。 但正则表达式可以复杂得多。例如，在一个模式后加上花括号包围的 3（{3}），就是说，“匹配这个模式 3 次”。所以较短的正则表达式\\d{3}-\\d{3}-\\d{4}， 也匹配正确的电话号码格式。 创建正则表达式对象 Python 中所有正则表达式的函数都在 re 模块中。 import re 向re.compile()传入一个字符串值，表示正则表达式，它将返回一个 Regex 模式对象（或者就简称为 Regex 对象）。 要创建一个 Regex 对象来匹配电话号码模式，就在交互式环境中输入以下代码（， \\d 表示“一个数字字符”， \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d 是正确电话号码模式的正则表达式）。 phoneNumRegex = re.compile(r'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d') 现在 phoneNumRegex 变量包含了一个 Regex 对象。 匹配 Regex 对象 Regex 对象的search()方法查找==传入的字符串==， 寻找该正则表达式的所有匹配。如果字符串中没有找到该正则表达式模式， search()方法将返回 None。如果找到了该模式，search()方法将返回一个 Match 对象。 Match 对象有一个group()方法，它返回被查找字符串中实际匹配的文本。 >>> phoneNumRegex = re.compile(r'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d') >>> mo = phoneNumRegex.search('My number is 415-555-4242.') >>> print('Phone number found: ' + mo.group()) Phone number found: 415-555-4242 将期待的模式传递给 re.compile()， 并将得到的 Regex 对象保存在phoneNumRegex 中。然后我们在 phoneNumRegex 上调用 search()， 向它传入想查找的字符串。查找的结果保存在变量 mo 中。在这个例子里， 我们知道模式会在这个字符串中找到， 所以我们知道会返回一个 Match 对象。 知道 mo 包含一个 Match 对象， 而不是空值 None，我们就可以在 mo 变量上调用 group()， 返回匹配的结果。将 mo.group()写在打印语句中， 显示出完整的匹配，即 415-555-4242。 用正则表达式匹配更多模式 利用括号分组 假定想要将区号从电话号码中分离。添加括号将在正则表达式中==创建“分组”==：(\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d)。然后可以使用group()匹配对象方法，从一个分组中获取匹配的文本。 正则表达式字符串中的第一对括号是第 1 组。第二对括号是第 2 组。向 group()匹配对象方法传入整数 1 或 2， 就可以取得匹配文本的不同部分。 ==向 group()方法传入 0 或不传入参数， 将返回整个匹配的文本。== >>> phoneNumRegex = re.compile(r'(\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d)') >>> mo = phoneNumRegex.search('My number is 415-555-4242.') >>> mo.group(1) '415' >>> mo.group(2) '555-4242' >>> mo.group(0) '415-555-4242' >>> mo.group() '415-555-4242' 如果想要一次就获取所有的分组， 请使用 groups()方法， 注意函数名的复数形式。 >>> mo.groups() ('415', '555-4242') >>> areaCode, mainNumber = mo.groups() >>> print(areaCode) 415 >>> print 因为== mo.groups()返回多个值的元组==， 所以你可以使用多重复制的技巧， 每个值赋给一个独立的变量， 就像前面的代码行： areaCode, mainNumber = mo.groups()。 括号在正则表达式中有特殊的含义， 但是如果你需要在文本中匹配括号， 怎么办？例如， 你要匹配的电话号码， 可能将区号放在一对括号中。在这种情况下， 就需要用倒斜杠对(和)进行字符转义。 >>> phoneNumRegex = re.compile(r'(\\(\\d\\d\\d\\)) (\\d\\d\\d-\\d\\d\\d\\d)') >>> mo = phoneNumRegex.search('My phone number is (415) 555-4242.') >>> mo.group(1) '(415)' >>> mo.group(2) '555-4242' 用管道匹配多个分组 字符|称为“管道”。希望匹配许多表达式中的一个时， 就可以使用它。例如，正则表达式 r'Batman|Tina Fey'将匹配'Batman'或'Tina Fey'。 如果 Batman 和 Tina Fey 都出现在被查找的字符串中， 第一次出现的匹配文本，将作为 Match 对象返回。 >>> heroRegex = re.compile (r'Batman|Tina Fey') >>> mo1 = heroRegex.search('Batman and Tina Fey.') >>> mo1.group() 'Batman' >>> mo2 = heroRegex.search('Tina Fey and Batman.') >>> mo2.group() 'Tina Fey' 也可以使用管道来匹配多个模式中的一个， 作为正则表达式的一部分。假设你希望匹配'Batman'、 'Batmobile'、 'Batcopter'和'Batbat'中任意一个。因为所有这些字符串都以 Bat 开始， 所以如果能够只指定一次前缀， 就很方便。这可以通过括号实现。 >>> batRegex = re.compile(r'Bat(man|mobile|copter|bat)') >>> mo = batRegex.search('Batmobile lost a wheel') >>> mo.group() 'Batmobile' >>> mo.group(1) 'mobile' 方法调用 mo.group()返回了完全匹配的文本'Batmobile'， 而mo.group(1)只是返回第一个括号分组内匹配的文本'mobile'。通过使用管道字符和分组括号， 可以指定几种可选的模式， 让正则表达式去匹配。 如果需要匹配真正的管道字符， 就用倒斜杠转义，即|。 命名分组 命名分组就是给具有默认分组编号的组另外再给一个别名。命名分组的语法格式如下： (?P正则表达式)#name是一个合法的标识符 提取字符串中的ip地址: s = \"ip='230.192.168.78',version='1.0.0'\" m=re.search(r\"ip='(?P\\d+\\.\\d+\\.\\d+\\.\\d+).*\", s) print(m.group('ip')) # 输出：230.192.168.78 用问号实现可选匹配 有时候， 想匹配的模式是可选的。就是说， 不论这段文本在不在， 正则表达式都会认为匹配。字符?表明它前面的分组在这个模式中是可选的。 >>> batRegex = re.compile(r'Bat(wo)?man') >>> mo1 = batRegex.search('The Adventures of Batman') >>> mo1.group() 'Batman' >>> mo2 = batRegex.search('The Adventures of Batwoman') >>> mo2.group() 'Batwoman' 正则表达式中的(wo)?部分表明， 模式 wo 是可选的分组。该正则表达式匹配的文本中， wo 将出现零次或一次。这就是为什么正则表达式既匹配'Batwoman'， 又匹配'Batman'。 用星号匹配零次或多次 *（称为星号）意味着“匹配零次或多次”，即星号之前的分组，可以在文本中出现任意次。它可以完全不存在，或一次又一次地重复。 >>> batRegex = re.compile(r'Bat(wo)*man') >>> mo1 = batRegex.search('The Adventures of Batman') >>> mo1.group() 'Batman' >>> mo2 = batRegex.search('The Adventures of Batwoman') >>> mo2.group() 'Batwoman' >>> mo3 = batRegex.search('The Adventures of Batwowowowoman') >>> mo3.group() 'Batwowowowoman' 对于'Batman'， 正则表达式的(wo)部分匹配 wo 的零个实例。对于'Batwoman'，(wo)匹配 wo 的一个实例。对于'Batwowowowoman'， (wo)匹配 wo 的 4 个实例。如果需要匹配真正的星号字符， 就在正则表达式的星号字符前加上倒斜杠，即\\。 用加号匹配一次或多次 *意味着“匹配零次或多次”， +（加号） 则意味着“匹配一次或多次”。 星号不要求分组出现在匹配的字符串中， 但加号不同， 加号前面的分组必须“至少出现一次”。这不是可选的。 >>> batRegex = re.compile(r'Bat(wo)+man') >>> mo1 = batRegex.search('The Adventures of Batwoman') >>> mo1.group() 'Batwoman' >>> mo2 = batRegex.search('The Adventures of Batwowowowoman') >>> mo2.group() 'Batwowowowoman' >>> mo3 = batRegex.search('The Adventures of Batman') >>> mo3 == None True 正则表达式 Bat(wo)+man 不会匹配字符串'The Adventures of Batman'，因为加号要求 wo 至少出现一次。 用花括号匹配特定次数 如果想要一个分组重复特定次数，就在正则表达式中该分组的后面，跟上花括号包围的数字。例如，正则表达式(Ha){3}将匹配字符串'HaHaHa'，但不会匹配'HaHa'，因为后者只重复了(Ha)分组两次。 除了一个数字，还可以指定一个范围，即在花括号中写下一个最小值、一个逗号和一个最大值。例如，正则表达式(Ha){3,5}将匹配'HaHaHa'、 'HaHaHaHa'和'HaHaHaHaHa'。 也可以不写花括号中的第一个或第二个数字， 不限定最小值或最大值。 (Ha){3,}将匹配 3 次或更多次实例， (Ha){,5}将匹配 0 到 5 次实例。花括号让正则表达式更简短。 >>> haRegex = re.compile(r'(Ha){3}') >>> mo1 = haRegex.search('HaHaHa') >>> mo1.group() 'HaHaHa' >>> mo2 = haRegex.search('Ha') >>> mo2 == None True 这里， (Ha){3}匹配'HaHaHa'， 但不匹配'Ha'。因为它不匹配'Ha'，所以 search()返回 None。 贪心和非贪心匹配 在字符串'HaHaHaHaHa'中，因为(Ha){3,5}可以匹配 3 个、 4 个或 5 个实例，你可能会想，为什么在前面花括号的例子中， Match 对象的 group()调用会返回'HaHaHaHaHa'，而不是更短的可能结果。毕竟， 'HaHaHa'和'HaHaHaHa'也能够有效地匹配正则表达式(Ha){3,5}。 Python 的正则表达式==默认是“贪心==” 的， 这表示在有二义的情况下，它们会尽可能匹配最长的字符串。==花括号的“非贪心” 版本匹配尽可能最短的字符串==，==即在结束的花括号后跟着一个问号。== >>> greedyHaRegex = re.compile(r'(Ha){3,5}') >>> mo1 = greedyHaRegex.search('HaHaHaHaHa') >>> mo1.group() 'HaHaHaHaHa' >>> nongreedyHaRegex = re.compile(r'(Ha){3,5}?') >>> mo2 = nongreedyHaRegex.search('HaHaHaHaHa') >>> mo2.g 请注意， 问号在正则表达式中可能有两种含义： 声明非贪心匹配或表示可选的分组。这两种含义是完全无关的。 findall()方法 除了search方法外， Regex对象也有一个findall()方法。search()将返回一个Match对象， 包含被查找字符串中的“第一次” 匹配的文本，而 findall()方法将返回一组字符串， 包含被查找字符串中的所有匹配。 >>> phoneNumRegex = re.compile(r'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d') >>> mo = phoneNumRegex.search('Cell: 415-555-9999 Work: 212-555-0000') >>> mo.group() '415-555-9999' 另一方面， findall()不是返回一个 Match 对象， 而是==返回一个字符串列表==， 只要在正则表达式中没有分组。列表中的每个字符串都是一段被查找的文本， 它匹配该正则表达式。 >>> phoneNumRegex = re.compile(r'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d') # has no groups >>> phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000') ['415-555-9999', '212-555-0000'] 如果在正则表达式中有分组， 那么 findall 将返回元组的列表。每个元组表示一个找到的匹配， 其中的项就是正则表达式中每个分组的匹配字符串。 >>> phoneNumRegex = re.compile(r'(\\d\\d\\d)-(\\d\\d\\d)-(\\d\\d\\d\\d)') # has groups >>> phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000') [('415', '555', '1122'), ('212', '555', '0000')] ==作为 findall()方法的返回结果的总结，请记住下面两点：== 1． 如果调用在一个没有分组的正则表达式上， 例如\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d， 方法findall()将返回一个匹配字符串的列表， 例如['415-555-9999', '212-555-0000']。 2． 如果调用在一个有分组的正则表达式上， 例如(\\d\\d\\d)-(\\d\\d\\d)-(\\d\\d\\d\\d)， 方法 findall()将返回一个==字符串的元组的列表==（每个分组对应一个字符串）， 例如[('415','555', '1122'), ('212', '555', '0000')]。 字符分类 在前面电话号码正则表达式的例子中， 你知道\\d 可以代表任何数字。也就是说， \\d是正则表达式(0|1|2|3|4|5|6|7|8|9)的缩写。有许多这样的“缩写字符分类”， ==常用字符分类的缩写代码== 字符分类对于缩短正则表达式很有用。字符分类[0-5]只匹配数字 0 到 5， 这比输入(0|1|2|3|4|5)要短很多。 例如， 在交互式环境中输入以下代码： >>> xmasRegex = re.compile(r'\\d+\\s\\w+') >>> xmasRegex.findall('12 drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, 7 swans, 6 geese, 5 rings, 4 birds, 3 hens, 2 doves, 1 partridge') ['12 drummers', '11 pipers', '10 lords', '9 ladies', '8 maids', '7 swans', '6 geese', '5 rings', '4 birds', '3 hens', '2 doves', '1 partridge'] Update time： 2020-05-25 "},"正则表达式/正则表达式 模式匹配与正则表达式二.html":{"url":"正则表达式/正则表达式 模式匹配与正则表达式二.html","title":"python 正则表达式 模式匹配与正则表达式 二","keywords":"","body":"python 正则表达式 模式匹配与正则表达式 二 建立自己的字符分类 有时候你想匹配一组字符， 但缩写的字符分类（\\d、 \\w、 \\s 等） 太宽泛。你可以用方括号定义自己的字符分类。例如， 字符分类[aeiouAEIOU]将匹配所有元音字符， 不论大小写。 >>> vowelRegex = re.compile(r'[aeiouAEIOU]') >>> vowelRegex.findall('RoboCop eats baby food. BABY FOOD.') ['o', 'o', 'o', 'e', 'a', 'a', 'o', 'o', 'A', 'O', 'O'] 也可以使用短横表示字母或数字的范围。例如， 字符分类[a-zA-Z0-9]将匹配所有小写字母、 大写字母和数字。 请注意，在方括号内，普通的正则表达式符号不会被解释。这意味着，你不需要前面加上倒斜杠转义.、 *、 ?或()字符。例如，字符分类将匹配数字 0 到 5 和一个句点。你不需要将它写成[0-5.]。 ==过在字符分类的左方括号后加上一个插入字符（^）， 就可以得到“非字符类”。非字符类将匹配不在这个字符类中的所有字符。== >>> consonantRegex = re.compile(r'[^aeiouAEIOU]') >>> consonantRegex.findall('RoboCop eats baby food. BABY FOOD.') ['R', 'b', 'c', 'p', ' ', 't', 's', ' ', 'b', 'b', 'y', ' ', 'f', 'd', '.', ' ', 'B', 'B', 'Y', ' ', 'F', 'D', '.'] 插入字符和美元字符 可以在正则表达式的开始处使用插入符号（^），表明匹配必须发生在被查找文本开始处。类似地，可以再正则表达式的末尾加上美元符号（$），表示该字符串必须以这个正则表达式的模式结束。可以同时使用^和$，表明整个字符串必须匹配该模式，也就是说，只匹配该字符串的某个子集是不够的。 例如， ==正则表达式 r'^Hello'匹配以'Hello'开始的字符串==。 >>> beginsWithHello = re.compile(r'^Hello') >>> beginsWithHello.search('Hello world!') >>> beginsWithHello.search('He said hello.') == None True ==正则表达式 r'\\d$'匹配以数字 0 到 9 结束的字符串。== >>> endsWithNumber = re.compile(r'\\d$') >>> endsWithNumber.search('Your number is 42') >>> endsWithNumber.search('Your number is forty two.') == None True ==正则表达式 r'^\\d+$'匹配从开始到结束都是数字的字符串。 == >>> wholeStringIsNum = re.compile(r'^\\d+$') >>> wholeStringIsNum.search('1234567890') >>> wholeStringIsNum.search('12345xyz67890') == None True >>> wholeStringIsNum.search('12 34567890') == None True 通配字符 在正则表达式中， .（句点）字符称为“通配符”。它匹配除了换行之外的所有字符。 >>> atRegex = re.compile(r'.at') >>> atRegex.findall('The cat in the hat sat on the flat mat.') ['cat', 'hat', 'sat', 'lat', 'mat'] 要记住，句点字符只匹配一个字符， 这就是为什么在前面的例子中， 对于文本flat， 只匹配 lat。要匹配真正的句点， 就是用倒斜杠转义： .。 贪婪模式和非贪婪模式 有时候想要匹配所有字符串。例如，假定想要匹配字符串'First Name:'，接下来是任意文本，接下来是'Last Name:'，然后又是任意文本。可以用点-星（ .*）表示“任意文本”。回忆一下，句点字符表示“除换行外所有单个字符”，星号字符表示“前面字符出现零次或多次”。 >>> nameRegex = re.compile(r'First Name: (.*) Last Name: (.*)') >>> mo = nameRegex.search('First Name: Al Last Name: Sweigart') >>> mo.group(1) 'Al' >>> mo.group(2) 'Sweigart' .*点-星使用“贪心” 模式：它总是匹配尽可能多的文本。要用“非贪心” 模式匹配所有文本， 就使用.*?点-星和问号。像和大括号一起使用时那样， 问号告诉 Python 用非贪心模式匹配。 >>> nongreedyRegex = re.compile(r'') >>> mo = nongreedyRegex.search(' for dinner.>') >>> mo.group() '' >>> greedyRegex = re.compile(r'') >>> mo = greedyRegex.search(' for dinner.>') >>> mo.group() ' for dinner.>' 两个正则表达式都可以翻译成“匹配一个左尖括号，接下来是任意字符，接下来是一个右尖括号”。但是字符串' for dinner.>'对右肩括号有两种可能的匹配。在非贪心的正则表达式中， Python 匹配最短可能的字符串： ''。在贪心版本中， Python 匹配最长可能的字符串： ' for dinner.>'。 用句点字符匹配换行 ==点-星将匹配除换行外的所有字符==。通过传入re.DOTALL 作为 re.compile()的第二个参数， 可以让句点字符匹配所有字符， 包括换行字符。 >>> noNewlineRegex = re.compile('.*') >>> noNewlineRegex.search('Serve the public trust.\\nProtect the innocent. \\nUphold the law.').group() 'Serve the public trust.' >>> newlineRegex = re.compile('.*', re.DOTALL) >>> newlineRegex.search('Serve the public trust.\\nProtect the innocent. \\nUphold the law.').group() 'Serve the public trust.\\nProtect the innocent.\\nUphold the law.' 正则表达式符号复习 ?匹配零次或一次前面的分组。 *匹配零次或多次前面的分组。 +匹配一次或多次前面的分组。 {n}匹配 n 次前面的分组。 {n,}匹配 n 次或更多前面的分组。 {,m}匹配零次到 m 次前面的分组。 {n,m}匹配至少 n 次、至多 m 次前面的分组。 {n,m}?或*?或+?对前面的分组进行非贪心匹配。 ^spam 意味着字符串必须以 spam 开始。 spam$意味着字符串必须以 spam 结束。 .匹配所有字符，换行符除外。 \\ 在字符串中表示转义字符 \\d、 \\w 和\\s 分别匹配数字、单词和空格。 \\D、 \\W 和\\S 分别匹配出数字、单词和空格外的所有字符。 [abc]匹配方括号内的任意一个字符（诸如 a、 b 或 c）。==字符集中没有特殊符号== [a-z]匹配a到z中的任意一个字符 abc匹配不在方括号内的任意字符。 不区分大小写的匹配 通常， 正则表达式用你指定的大小写匹配文本。例如， 下面的正则表达式匹配完全不同的字符串： >>> regex1 = re.compile('RoboCop') >>> regex2 = re.compile('ROBOCOP') >>> regex3 = re.compile('robOcop') >>> regex4 = re.compile('RobocOp') 但是，有时候你只关心匹配字母，不关心它们是大写或小写。要让正则表达式不区分大小写，可以向 re.compile()传入re.IGNORECASE 或 re.I，作为第二个参数。 >>> robocop = re.compile(r'robocop', re.I) >>> robocop.search('RoboCop is part man, part machine, all cop.').group() 'RoboCop' >>> robocop.search('ROBOCOP protects the innocent.').group() 'ROBOCOP' >>> robocop.search('Al, why does your programming book talk about robocop so much?').group() 'robocop' 用 sub()方法替换字符串 正则表达式不仅能找到文本模式， 而且能够用新的文本替换掉这些模式。 Regex对象的 sub()方法需要传入两个参数。==第一个参数是一个字符串， 用于取代发现的匹配==。==第二个参数是一个字符串，即正则表达式==。 sub()方法返回替换完成后的字符串。 >>> namesRegex = re.compile(r'Agent \\w+') >>> namesRegex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.') 'CENSORED gave the secret documents to CENSORED.' 有时候，你可能需要使用匹配的文本本身，作为替换的一部分。在 sub()的第一个参数中，可以输入\\1、 \\2、 \\3……。表示“在替换中输入分组 1、 2、 3……的文本”。例如，假定想要隐去密探的姓名，只显示他们姓名的第一个字母。要做到这一点，可以使用正则表达式 Agent (\\w)\\w，传入 r'\\1*'作为 sub()的第一个参数。字符串中的\\1 将由分组 1 匹配的文本所替代，也就是正则表达式的(\\w)分组。 >>> agentNamesRegex = re.compile(r'Agent (\\w)\\w*') >>> agentNamesRegex.sub(r'\\1****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.') A**** told C**** that E**** knew B**** was a double agent.' 管理复杂的正则表达式 如果要匹配的文本模式很简单， 正则表达式就很好。但匹配复杂的文本模式，可能需要长的、费解的正则表达式。你可以告诉 re.compile()， ==忽略正则表达式字符串中的空白符和注释==， 从而缓解这一点。 要实现这种详细模式， 可以向 re.compile()传入变量re.VERBOSE， 作为第二个参数。 phoneRegex = re.compile(r'''( (\\d{3}|\\(\\d{3}\\))? # area code (\\s|-|\\.)? # se \\d{3} # first 3 digits (\\s|-|\\.) # separator \\d{4} # last 4 digits (\\s*(ext|x|ext.)\\s*\\d{2,5})? # extension )''', re.VERBOSE) 请注意， 前面的例子使用了==三重引号('\")==， ==创建了一个多行字符串。这样就可以将正则表达式定义放在多行中， 让它更可读。==正则表达式字符串中的注释规则， 与普通的 Python 代码一样： #符号和它后面直到行末的内容， 都被忽略。而且， 表示正则表达式的多行字符串中， 多余的空白字符也不认为是要匹配的文本模式的一部分。这让你能够组织正则表达式， 让它更可读 组合使用 re.IGNORECASE、 re.DOTALL 和 re.VERBOSE 如果你希望在正则表达式中使用 re.VERBOSE 来编写注释，还希望使用re.IGNORECASE 来忽略大小写，该怎么办？遗憾的是， re.compile()函数只接受一个值作为它的第二参数。可以使用管道字符（|）将变量组合起来，从而绕过这个限制。管道字符在这里称为“按位或”操作符。 所以， 如果希望正则表达式不区分大小写， 并且句点字符匹配换行， 就可以这样构造 re.compile()调用： >>> someRegexValue = re.compile('foo', re.IGNORECASE | re.DOTALL | re.VERBOSE) re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同） M(MULTILINE): 多行模式，改变'^'和'$'的行为（参见上图） S(DOTALL): 点任意匹配模式，改变'.'的行为 L(LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 U(UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性 X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的： 参考 Python正则表达式指南 Update time： 2020-05-25 "},"多进程-多线程/":{"url":"多进程-多线程/","title":"python 多进程-多线程","keywords":"","body":"python 多进程-多线程 Update time： 2020-05-25 "},"多进程-多线程/Python 多进程multiprocessing模块.html":{"url":"多进程-多线程/Python 多进程multiprocessing模块.html","title":"Python 多进程multiprocessing模块","keywords":"","body":"Python 多进程multiprocessing模块 multiprocessing模块介绍 python中的多线程无法利用多核优势，如果想要充分地使用多核CPU的资源（os.cpu_count()查看），在python中大部分情况需要使用多进程。Python提供了multiprocessing。 multiprocessing模块用来开启 子进程，并在子进程中执行我们定制的任务（比如函数），该模块与多线程模块threading的编程接口类似。 　 multiprocessing模块的功能众多：支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。 与线程不同，进程没有任何共享状态，进程修改的数据，改动仅限于该进程内。 一、Process类的介绍 创建进程的类： Process(group=None, target=None, name=None, args=(), kwargs={} ) 参数介绍： group参数未使用，值始终为None target表示调用对象，即子进程要执行的任务 args表示调用对象的位置参数元组，args=(1,2,'egon',) kwargs表示调用对象的字典,kwargs={'name':'egon','age':18} name为子进程的名称 强调： 需要使用关键字的方式来指定参数 args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号 方法介绍： star() 方法启动进程， join()方法实现进程间的同步，等待所有进程退出。 close() 用来阻止多余的进程涌入进程池 Pool 造成进程阻塞。 p.is_alive() 如果p在运行，返回True p.join([timeout]) 等待进程p运行结束。timeout是可选的超时期限。如果timeout为None，则认为要无限期等待 p.run() 进程启动时运行的方法。默认情况下，会调用传递给Process构造函数中的target；定义进程的另一种方法是继承Process并重写run()方法 p.start() 运行进程p，并调用p.run() p.terminate() 强制杀死进程。如果调用此方法，进程p将被立即终止，同时不会进行任何清理动作。如果进程p创建了自己的子进程，这些进程将会变成 僵尸进程,此方法要小心使用 p.authkey 进程的身份验证键 p.daemon 守护进程标志，布尔变量。指进程是否为后台进程。如果该进程为后台进程(daemon = True)，当创建它的Python进程终止时，后台进程将自动终止; 其中p.daemon的值要在使用p.start()启动进程之前设置,并且禁止后台进程创建子进程 p.daemon = True 主进程终止,子进程终止, p.daemon = False 主进程终止,子进程不会终止 p.exitcode进程的整数退出码。如果进程仍在运行，值为None。如果值为-N，表示进程由信号N终止 p.name进程名 p.pid 进程号 需要注意的是start()，join()，is_alive()， terminate()和exitcode方法只能由创建进程对象的过程调用。 Process类的使用 注意：在windows中Process()必须放到# if name == 'main':下 class multiprocessing.pool.Pool([processes [, initializer [, initargs [, maxtasksperchild [, context]]]]] ) processes： 是要使用的工作进程数。如果进程是None，那么使用返回的数字os.cpu_count()。也就是说根据本地的cpu个数决定，processes小于等于本地的cpu个数； initializer： 如果initializer是None，那么每一个工作进程在开始的时候会调用initializer(*initargs)。 maxtasksperchild：工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来替代原进程，来让闲置的资源被释放。 maxtasksperchild默认是None，意味着只要Pool存在工作进程就会一直存活。 context: 用在制定工作进程启动时的上下文，一般使用 multiprocessing.Pool() 或者一个context对象的Pool()方法来创建一个池，两种方法都适当的设置了context。 创建并开启子进程的两种方式 开进程的方法一: import multiprocessing import os def run_proc(name): print('Child process {0} {1} Running '.format(name, os.getpid())) if __name__ == '__main__': print('Parent process {0} is Running'.format(os.getpid())) for i in range(5): p = multiprocessing.Process(target=run_proc, args=(str(i),)) print('process start') p.start() p.join() print('Process close') 结果： Parent process 132412 is Running process start process start process start process start process start Child process 3 18612 Running Child process 1 8840 Running Child process 2 142376 Running Child process 0 39368 Running Child process 4 142564 Running Process close 开进程的方法二: import time import random from multiprocessing import Process class Piao(Process): def __init__(self,name): super().__init__() self.name=name def run(self): print('%s piaoing' %self.name) time.sleep(random.randrange(1,5)) print('%s piao end' %self.name) p1=Piao('egon') p2=Piao('alex') p3=Piao('wupeiqi') p4=Piao('yuanhao') p1.start() #start会自动调用run p2.start() p3.start() p4.start() print('主线程') Process对象的join方法 from multiprocessing import Process import time import random def piao(name): print('%s is piaoing' %name) time.sleep(random.randint(1,3)) print('%s is piao end' %name) p1=Process(target=piao,args=('egon',)) p2=Process(target=piao,args=('alex',)) p3=Process(target=piao,args=('yuanhao',)) p4=Process(target=piao,args=('wupeiqi',)) p1.start() p2.start() p3.start() p4.start() #有的同学会有疑问:既然join是等待进程结束,那么我像下面这样写,进程不就又变成串行的了吗? #当然不是了,必须明确：p.join()是让谁等？ #很明显p.join()是让主线程等待p的结束，卡住的是主线程而绝非进程p， #详细解析如下： #进程只要start就会在开始运行了,所以p1-p4.start()时,系统中已经有四个并发的进程了 #而我们p1.join()是在等p1结束,没错p1只要不结束主线程就会一直卡在原地,这也是问题的关键 #join是让主线程等,而p1-p4仍然是并发执行的,p1.join的时候,其余p2,p3,p4仍然在运行,等#p1.join结束,可能p2,p3,p4早已经结束了,这样p2.join,p3.join.p4.join直接通过检测，无需等待 # 所以4个join花费的总时间仍然是耗费时间最长的那个进程运行的时间 p1.join() p2.join() p3.join() p4.join() print('主线程') #上述启动进程与join进程可以简写为 # p_l=[p1,p2,p3,p4] # # for p in p_l: # p.start() # # for p in p_l: # p.join() 二、Pool，进程池 Pool 可以提供指定数量的进程供用户使用，默认是 CPU 核数。当有新的请求提交到 Poll 的时候，如果池子没有满，会创建一个进程来执行，否则就会让该请求等待。 apply(func[, args[, kwds]]) apply_async(func[, args[, kwds[, callback]]]) map(func, iterable[, chunksize]) map_async(func, iterable[, chunksize[, callback]]) imap(func, iterable[, chunksize]) imap_unordered(func, iterable[, chunksize]) Pool对象调用join 方法会等待所有的子进程执行完毕 调用join方法之前，必须调用 close 调用 close之后就不能继续添加新的 Process 实例方法 1、apply apply（func [，args [，kwds ] ] ） 使用参数args和关键字参数kwds调用func。它会阻塞，直到结果准备就绪。鉴于此块，更适合并行执行工作。此外，func 仅在池中的一个工作程序中执行。 apply(func[, args[, kwds]]) 该方法只能允许一个进程进入池子，在一个进程结束之后，另外一个进程才可以进入池子。 from multiprocessing import Pool import time def test(p): print(p) # time.sleep(3) if __name__==\"__main__\": pool = Pool(processes=10) for i in range(500): ''' ('\\n' ' （1）遍历500个可迭代对象，往进程池放一个子进程\\n' ' （2）执行这个子进程，等子进程执行完毕，再往进程池放一个子进程，再执行。（同时只执行一个子进程）\\n' ' for循环执行完毕，再执行print函数。\\n' ' ') ''' pool.apply(test, args=(i,)) #维持执行的进程总数为10，当一个进程执行完后启动一个新进程. print('test') pool.close() pool.join() for循环内执行的步骤顺序，往进程池中添加一个子进程，执行子进程，等待执行完毕再添加一个子进程……等500个子进程都执行完了，再执行print。（从结果来看，并没有多进程并发） import multiprocessing import os import time def run_task(name): # print('Task {0} pid {1} is running, parent id is {2}'.format(name, os.getpid(), os.getppid())) # time.sleep(1) print('Task {0} end.'.format(name)) if __name__ == '__main__': print('current process {0}'.format(os.getpid())) p = multiprocessing.Pool(processes=5) for i in range(100000): p.apply(run_task, args=(i,)) print('Waiting for all subprocesses done...') p.close() p.join() print('All processes done!') 2、apply_async apply_async(func [，args [，kwds [，callback [，error_callback ] ] ] ] ) apply_async 方法用来同步执行进程，允许多个进程同时进入池子。 异步进程池（非阻塞）,返回结果对象的方法的变体。如果指定了回调，则它应该是可调用的，它接受单个参数。当结果变为就绪时，将对其应用回调，即除非调用失败，在这种情况下将应用error_callback。如果指定了error_callback，那么它应该是一个可调用的，它接受一个参数。如果目标函数失败，则使用异常实例调用error_callback。回调应立即完成，否则处理结果的线程将被阻止。 from multiprocessing import Pool import time def test(p): print(p) time.sleep(3) if __name__==\"__main__\": pool = Pool(processes=2) for i in range(500): ''' （1）循环遍历，将500个子进程添加到进程池（相对父进程会阻塞）\\n' （2）每次执行2个子进程，等一个子进程执行完后，立马启动新的子进程。（相对父进程不阻塞）\\n' ''' pool.apply_async(test, args=(i,)) #维持执行的进程总数为10，当一个进程执行完后启动一个新进程. print('test') pool.close() pool.join() import multiprocessing import os import time def run_task(name): # print('Task {0} pid {1} is running, parent id is {2}'.format(name, os.getpid(), os.getppid())) # time.sleep(1) print('Task {0} end.'.format(name)) if __name__ == '__main__': print('current process {0}'.format(os.getpid())) p = multiprocessing.Pool(processes=2) for i in range(10): p.apply_async(run_task, args=(i,)) print('Waiting for all subprocesses done...') p.close() # 不能继续往p里面添加新的进程 p.join() # jion 之后，主线(主函数)程等待 p 结束之后，主线程才能结束 print('All processes done!') 调用join之前，先调用close或者terminate方法，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束。 3、map map(func,iterable [,chunksize ]) map()内置函数的并行等价物（尽管它只支持一个可迭代的参数）。它会阻塞，直到结果准备就绪。此方法将iterable内的每一个对象作为单独的任务提交给进程池。可以通过将chunksize设置为正整数来指定这些块的（近似）大小。 from multiprocessing import Pool import time def test(i): print(i) time.sleep(1) if __name__ == \"__main__\": lists = [x for x in range(100)] pool = Pool(processes=2) #定义最大的进程数 pool.map(test, lists) #lists必须是一个可迭代变量。 pool.close() pool.join() 4、map_async map_async(func,iterable [,chunksize [,callback [,error_callback]]]) map()返回结果对象的方法的变体。需要传入可迭代对象iterable import time from multiprocessing import Pool def test(p): print(p) time.sleep(3) if __name__ == \"__main__\": pool = Pool(processes=2) # for i in range(500): # ''' # （1）循环遍历，将500个子进程添加到进程池（相对父进程会阻塞）\\n' # （2）每次执行2个子进程，等一个子进程执行完后，立马启动新的子进程。（相对父进程不阻塞）\\n' # ''' # pool.apply_async(test, args=(i,)) #维持执行的进程总数为10，当一个进程执行完后启动一个新进程. pool.map_async(test, range(500)) print('test') pool.close() pool.join() 三、Queue 用于进程通信，资源共享 允许多个进程之间 class multiprocessing.Queue（[ maxsize ] ） Queue 用来在多个进程间通信。Queue有两个方法，get和put。 put 方法 放数据，Queue.put( )默认有block=True和timeout两个参数。当block=True时，写入是阻塞式的，阻塞时间由timeout确定。当队列q被（其他线程）写满后，这段代码就会阻塞，直至其他线程取走数据。Queue.put（）方法加上 block=False 的参数，即可解决这个隐蔽的问题。但要注意，非阻塞方式写队列，当队列满时会抛出 exception Queue.Full 的异常 get方法 get 方法用来从队列中读取并删除一个元素。有两个参数可选，blocked 和 timeout blocked = False （默认），timeout 正值 等待时间内，没有取到任何元素，会抛出 Queue.Empty 异常。 Queue 有一个值可用，立刻返回改值；Queue 没有任何元素， import os import random import time # 进程间的通信 from multiprocessing import Process, Queue # 写数据进程执行的代码: def proc_write(q, urls): print('Process(%s) is writing...' % os.getpid()) for url in urls: q.put(url) print('Put %s to queue...' % url) time.sleep(random.random()) # 读数据进程执行的代码: def proc_read(q): print('Process(%s) is reading...' % os.getpid()) while True: url = q.get(True) print('Get %s from queue.' % url) if __name__ == '__main__': # 父进程创建Queue，并传给各个子进程： q = Queue() proc_writer1 = Process(target=proc_write, args=(q, ['url_1', 'url_2', 'url_3'])) proc_writer2 = Process(target=proc_write, args=(q, ['url_4', 'url_5', 'url_6'])) proc_reader = Process(target=proc_read, args=(q,)) # 启动子进程proc_writer，写入: proc_writer1.start() proc_writer2.start() # 启动子进程proc_reader，读取: proc_reader.start() # 等待proc_writer结束: proc_writer1.join() proc_writer2.join() # proc_reader进程里是死循环，无法等待其结束，只能强行终止: proc_reader.terminate() 四、Pipe 进程间通信 (用于管道通信，用于两个进程之间的连接） 常用来在两个进程间通信，两个进程分别位于管道的两端。 如果是全双工的(构造函数参数为True)，则双端口都可接收发送，否则前面的端口用于接收，后面的端口用于发送。 multiprocessing.Pipe([duplex]) 示例 1 from multiprocessing import Process, Pipe def send(pipe): pipe.send(['spam'] + [42, 'egg']) # send 传输一个列表 pipe.close() if __name__ == '__main__': (con1, con2) = Pipe() # 创建两个 Pipe 实例 # 函数的参数，args 一定是实例化之后的 Pip 变量，不能直接写 args=(Pip(),) sender = Process(target=send, args=(con1, )) sender.start() # Process 类启动进程 print(\"con2 got: %s\" % con2.recv()) # 管道的另一端 con2 从send收到消息 con2.close() # 关闭管道 # 输出：con2 got: ['spam', 42, 'egg'] con1管道的一端，负责存储,也可以理解为发送信息 con2管道的另一端，负责读取,也可以理解为接受信息 示例 2 管道是可以同时发送和接受消息的： from multiprocessing import Process, Pipe def talk(pipe): pipe.send(dict(name='Bob', spam=42)) # 传输一个字典 reply = pipe.recv() # 接收传输的数据 print('talker got:', reply) if __name__ == '__main__': (parentEnd, childEnd) = Pipe() # 创建两个 Pipe() 实例，也可以改成 conf1， conf2 child = Process(target=talk, args=(childEnd,)) # 创建一个 Process 进程，名称为 child child.start() # 启动进程 print('parent got:', parentEnd.recv()) # parentEnd 是一个 Pip() 管道，可以接收 child Process 进程传输的数据 parentEnd.send({x * 2 for x in 'spam'}) # parentEnd 是一个 Pip() 管道，可以使用 send 方法来传输数据 # 传输的数据被 talk 函数内的 pip 管道接收，并赋值给 reply child.join() print('parent exit') 五、Lock、Rlock进程同步 Value，Array（用于进程通信，资源共享）（还不太明白） 不使用锁进行同步 import multiprocessing import time def job(v, num): for _ in range(5): time.sleep(0.1) # 暂停0.1秒，让输出效果更明显 v.value += num # v.value获取共享变量值 print(v.value, end=\",\") def multicore(): v = multiprocessing.Value('i', 0) # 定义共享变量 p1 = multiprocessing.Process(target=job, args=(v, 1)) p2 = multiprocessing.Process(target=job, args=(v, 3)) # 设定不同的number看如何抢夺内存 p1.start() p2.start() p1.join() p2.join() if __name__ == '__main__': multicore() ''' # 进程1和进程2在相互抢着使用共享内存v 1,5,9,13,17,4,8,12,16,20, ''' 使用锁进行同步 import multiprocessing import time # lock = multiprocessing.Lock() lock = multiprocessing.RLock() def job(v, num,lock): lock.acquire() for _ in range(5): time.sleep(0.1) # 暂停0.1秒，让输出效果更明显 v.value += num # v.value获取共享变量值 print(v.value, end=\",\") lock.release() def multicore(): v = multiprocessing.Value('i', 0) # 定义共享变量 p1 = multiprocessing.Process(target=job, args=(v, 1, lock)) p2 = multiprocessing.Process(target=job, args=(v, 3, lock)) # 设定不同的number看如何抢夺内存 p1.start() p2.start() p1.join() p2.join() ''' # 显然，进程锁保证了进程p1的完整运行，然后才进行了进程p2的运行 1,2,3,4,5,8,11,14,17,20, ''' 参考： https://blog.csdn.net/CityzenOldwang/article/details/78584175 https://blog.csdn.net/brucewong0516/article/details/85776194 Update time： 2020-05-25 "},"多进程-多线程/Python 异步并发concurrent.futures模块.html":{"url":"多进程-多线程/Python 异步并发concurrent.futures模块.html","title":"Python 异步并发concurrent.futures模块","keywords":"","body":"Python 异步并发concurrent.futures模块 ﻿python异步并发模块concurrent.futures。它非常简单易用，主要用来实现多线程和多进程的异步并发。 Executor对象 class concurrent.futures.Executor Executor是一个抽象类，它提供了异步执行调用的方法。它不能直接使用，但可以通过它的两个子类ThreadPoolExecutor或者ProcessPoolExecutor进行调用。 Executor.submit(fn, *args, **kwargs) fn：需要异步执行的函数 *args, **kwargs：fn参数 示例： from concurrent import futures def test(num): import time return time.ctime(), num with futures.ThreadPoolExecutor(max_workers=1) as executor: future = executor.submit(test, 1) print(future.result()) #('Tue Oct 29 21:47:45 2019', 1) Executor.map(func, *iterables, timeout=None) 相当于map(func, *iterables)，但是func是异步执行。timeout的值可以是int或float，如果操作超时，会返回raisesTimeoutError；如果不指定timeout参数，则不设置超时间。 func：需要异步执行的函数 *iterables：可迭代对象，如列表等。每一次func执行，都会从iterables中取参数。 timeout：设置每次异步操作的超时时间 data = [1, 2, 3] with futures.ThreadPoolExecutor(max_workers=1) as executor: for future in executor.map(test, data): print(future) ''' ('Tue Oct 29 21:52:01 2019', 1) ('Tue Oct 29 21:52:01 2019', 2) ('Tue Oct 29 21:52:01 2019', 3) ''' 关闭线程 Executor.shutdown(wait=True) 释放系统资源,在Executor.submit()或 Executor.map()等异步操作后调用。 使用with语句可以避免显式调用此方法。 ThreadPoolExecutor对象 ThreadPoolExecutor类是Executor子类，使用线程池执行异步调用. class concurrent.futures.ThreadPoolExecutor(max_workers) 使用max_workers数目的线程池执行异步调用 import pandas as pd from datetime import date from time import time from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutor def parse (date_str, point): print(date_str,'------->',point) #创建线程对象，和线程个数 threadPool = ThreadPoolExecutor(30) date_list = pd.date_range(\"19000101\", str(date.today())) # 时间点 time_point = [2, 8, 14, 20] for each_date in date_list: date_str = str(each_date).split(\" \")[0] for each_point in time_point: # 多线程 threadPool.submit( parse, date_str=date_str, point=each_point ) # 关闭线程池 threadPool.shutdown() 线程池的基本使用 # coding: utf-8 from concurrent.futures import ThreadPoolExecutor import time def spider(page): time.sleep(page) print(f\"crawl task{page} finished\") return page with ThreadPoolExecutor(max_workers=5) as t: # 创建一个最大容纳数量为5的线程池 task1 = t.submit(spider, 1) task2 = t.submit(spider, 2) # 通过submit提交执行的函数到线程池中 task3 = t.submit(spider, 3) print(f\"task1: {task1.done()}\") # 通过done来判断线程是否完成 print(f\"task2: {task2.done()}\") print(f\"task3: {task3.done()}\") time.sleep(2.5) print(f\"task1: {task1.done()}\") print(f\"task2: {task2.done()}\") print(f\"task3: {task3.done()}\") print(task1.result()) # 通过result来获取返回值 执行结果如下: task1: False task2: False task3: False crawl task1 finished crawl task2 finished task1: True task2: True task3: False 1 crawl task3 finished 使用with 语句 ，通过 ThreadPoolExecutor构造实例，同时传入 max_workers 参数来设置线程池中最多能同时运行的线程数目。 使用submit 函数来提交线程需要执行的任务到线程池中，并返回该任务的句柄（类似于文件、画图），注意 submit() 不是阻塞的，而是立即返回。 通过使用 done() 方法判断该任务是否结束。上面的例子可以看出，提交任务后立即判断任务状态，显示四个任务都未完成。在延时2.5后，task1 和 task2 执行完毕，task3 仍在执行中。 使用result() 方法可以获取任务的返回值。 主要方法 wait wait(fs, timeout=None, return_when=ALL_COMPLETED) wait接受三个参数： fs: 表示需要执行的序列 timeout: 等待的最大时间，如果超过这个时间即使线程未执行完成也将返回 ,return_when：表示wait返回结果的条件，默认为ALL_COMPLETED 全部执行完成再返回. from concurrent.futures import ThreadPoolExecutor, wait, FIRST_COMPLETED, ALL_COMPLETED import time def spider(page): time.sleep(page) print(f\"crawl task{page} finished\") return page with ThreadPoolExecutor(max_workers=5) as t: all_task = [t.submit(spider, page) for page in range(1, 5)] wait(all_task, return_when=FIRST_COMPLETED) print('finished') print(wait(all_task, timeout=2.5)) # 运行结果 crawl task1 finished finished crawl task2 finished crawl task3 finished DoneAndNotDoneFutures(done={, , }, not_done={}) crawl task4 finished as_completed 上面虽然提供了判断任务是否结束的方法，但是不能在主线程中一直判断啊。最好的方法是当某个任务结束了，就给主线程返回结果，而不是一直判断每个任务是否结束。 ThreadPoolExecutor 中 的 as_completed() 就是这样一个方法，当子线程中的任务执行完后，直接用 result()获取返回结果 # coding: utf-8 from concurrent.futures import ThreadPoolExecutor, as_completed import time def spider(page): time.sleep(page) print(f\"crawl task{page} finished\") return page def main(): with ThreadPoolExecutor(max_workers=5) as t: obj_list = [] for page in range(1, 5): obj = t.submit(spider, page) obj_list.append(obj) for future in as_completed(obj_list): data = future.result() print(f\"main: {data}\") # 执行结果 crawl task1 finished main: 1 crawl task2 finished main: 2 crawl task3 finished main: 3 crawl task4 finished main: 4 as_completed() 方法是一个生成器，在没有任务完成的时候，会一直阻塞，除非设置了 timeout。 当有某个任务完成的时候，会 yield 这个任务，就能执行 for 循环下面的语句，然后继续阻塞住，循环到所有的任务结束。同时，先完成的任务会先返回给主线程。 map map(fn, *iterables, timeout=None) fn： 第一个参数 fn 是需要线程执行的函数； iterables：第二个参数接受一个可迭代对象； timeout： 第三个参数 timeout 跟 wait() 的 timeout 一样，但由于 map 是返回线程执行的结果，如果 timeout小于线程执行时间会抛异常 TimeoutError。 import time from concurrent.futures import ThreadPoolExecutor def spider(page): time.sleep(page) return page start = time.time() executor = ThreadPoolExecutor(max_workers=4) i = 1 for result in executor.map(spider, [2, 3, 1, 4]): print(\"task{}:{}\".format(i, result)) i += 1 # 运行结果 task1:2 task2:3 task3:1 task4:4 使用 map 方法，无需提前使用 submit 方法，map 方法与 python 高阶函数 map 的含义相同，都是将序列中的每个元素都执行同一个函数。 上面的代码对列表中的每个元素都执行 spider() 函数，并分配各线程池。 # coding: utf-8 import requests from concurrent.futures import ThreadPoolExecutor, as_completed import time import json from requests import adapters from proxy import get_proxies headers = { \"Host\": \"splcgk.court.gov.cn\", \"Origin\": \"https://splcgk.court.gov.cn\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\", \"Referer\": \"https://splcgk.court.gov.cn/gzfwww/ktgg\", } url = \"https://splcgk.court.gov.cn/gzfwww/ktgglist?pageNo=1\" def spider(page): data = { \"bt\": \"\", \"fydw\": \"\", \"pageNum\": page, } for _ in range(5): try: response = requests.post(url, headers=headers, data=data, proxies=get_proxies()) json_data = response.json() except (json.JSONDecodeError, adapters.SSLError): continue else: break else: return {} return json_data def main(): with ThreadPoolExecutor(max_workers=8) as t: obj_list = [] begin = time.time() for page in range(1, 15): obj = t.submit(spider, page) obj_list.append(obj) for future in as_completed(obj_list): data = future.result() print(data) print('*' * 50) times = time.time() - begin print(times) if __name__ == \"__main__\": main() ProcessPoolExecutor对象 ThreadPoolExecutor类是Executor子类，使用进程池执行异步调用. class concurrent.futures.ProcessPoolExecutor(max_workers=None) 使用max_workers数目的进程池执行异步调用，如果max_workers为None 则使用机器的处理器数目（如4核机器max_worker配置为None时，则使用4个进程进行异步并发）。 from concurrent import futures def test(num): import time return time.ctime(), num def muti_exec(m, n): # m 并发次数 # n 运行次数 with futures.ProcessPoolExecutor(max_workers=m) as executor: # 多进程 # with futures.ThreadPoolExecutor(max_workers=m) as executor: #多线程 executor_dict = dict((executor.submit(test, times), times) for times in range(m * n)) for future in futures.as_completed(executor_dict): times = executor_dict[future] if future.exception() is not None: print('%r generated an exception: %s' % (times, future.exception())) else: print('RunTimes:%d,Res:%s' % (times, future.result())) if __name__ == '__main__': muti_exec(5, 1) ''' RunTimes:4,Res:('Tue Oct 29 21:56:12 2019', 4) RunTimes:2,Res:('Tue Oct 29 21:56:12 2019', 2) RunTimes:0,Res:('Tue Oct 29 21:56:12 2019', 0) RunTimes:1,Res:('Tue Oct 29 21:56:12 2019', 1) RunTimes:3,Res:('Tue Oct 29 21:56:12 2019', 3) ''' 线程池： from concurrent.futures import ProcessPoolExecutor,ThreadPoolExecutor import threading import os,time,random def task(n): print('%s:%s is running' %(threading.currentThread().getName(),os.getpid())) time.sleep(2) return n**2 if __name__ == '__main__': p=ThreadPoolExecutor() #不填则默认为cpu的个数*5 l=[] start=time.time() for i in range(10): obj=p.submit(task,i) l.append(obj) p.shutdown() print('='*30) print([obj.result() for obj in l]) print(time.time()-start) #上面方法也可写成下面的方法 # start = time.time() # with ThreadPoolExecutor() as p: #类似打开文件,可省去.shutdown() # future_tasks = [p.submit(task, i) for i in range(10)] # print('=' * 30) # print([obj.result() for obj in future_tasks]) # print(time.time() - start) ''' ThreadPoolExecutor-0_0:1204 is running ThreadPoolExecutor-0_1:1204 is running ThreadPoolExecutor-0_2:1204 is running ThreadPoolExecutor-0_3:1204 is running ThreadPoolExecutor-0_4:1204 is running ThreadPoolExecutor-0_5:1204 is running ThreadPoolExecutor-0_6:1204 is running ThreadPoolExecutor-0_7:1204 is running ThreadPoolExecutor-0_8:1204 is running ThreadPoolExecutor-0_9:1204 is running ============================== [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 2.0051467418670654 ''' 进程池： from concurrent.futures import ProcessPoolExecutor import os,time,random def task(n): print('%s is running' %os.getpid()) time.sleep(2) return n**2 if __name__ == '__main__': p=ProcessPoolExecutor() #不填则默认为cpu的个数 l=[] start=time.time() for i in range(10): obj=p.submit(task,i) #submit()方法返回的是一个future实例，要得到结果需要用obj.result() l.append(obj) p.shutdown() #类似用from multiprocessing import Pool实现进程池中的close及join一起的作用 print('='*30) # print([obj for obj in l]) print([obj.result() for obj in l]) print(time.time()-start) #上面方法也可写成下面的方法 # start = time.time() # with ProcessPoolExecutor() as p: #类似打开文件,可省去.shutdown() # future_tasks = [p.submit(task, i) for i in range(10)] # print('=' * 30) # print([obj.result() for obj in future_tasks]) # print(time.time() - start) ''' 32088 is running 30512 is running 23388 is running 25216 is running 32088 is running 30512 is running 23388 is running 25216 is running 32088 is running 30512 is running ============================== [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 6.5124876499176025 ''' Update time： 2020-05-25 "},"面向对象/":{"url":"面向对象/","title":"python 面向对象","keywords":"","body":"python 面向对象 Update time： 2020-05-25 "},"面向对象/类.html":{"url":"面向对象/类.html","title":"python 类","keywords":"","body":"python 类 ﻿面向对象编程是最有效的软件编写方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。 基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。根据类来创建对象被称为实例化，这让你能够使用类的实例。 类与对象 类即类别、种类，是面向对象设计最重要的概念，对象是特征与技能的结合体，而类则是一系列对象相似的特征与技能的结合体 创建 Dog 类 class Dog(): \"\"\"一次模拟小狗的简单尝试\"\"\" def __init__(self, name, age): \"\"\"初始化属性name和age\"\"\" self.name = name self.age = age def sit(self): \"\"\"模拟小狗被命令时蹲下\"\"\" print(self.name.title() + \" is now sitting.\") def roll_over(self): \"\"\"模拟小狗被命令时打滚\"\"\" print(self.name.title() + \" rolled over!\") 在Python中，首字母大写的名称指的是类。这个类定义中的括号是空的，因为我们要从空白创建这个类。 方法init() 类中的函数称为方法；你前面学到的有关函数的一切都适用于方法，就目前而言，唯一重要的差别是调用方法的方式。 方法init()是一个特殊的方法，每当你根据Dog类创建新实例时， Python都会自动运行它。在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。 将方法init()定义成了包含三个形参： self、 name和age。在这个方法的定义中，形参self必不可少，还必须位于其他形参的前面。为何必须在方法定义中包含形参self呢？因为Python调用这个init()方法来创建Dog实例时，将自动传入实参self。每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。我们创建Dog实例时， Python将调用Dog类的方法init()。我们将通过实参向Dog()传递名字和年龄； self会自动传递，因此我们不需要传递它。每当我们根据Dog类创建实例时，都只需给最后两个形参（ name和age）提供值。 self.name = name self.age = age 定义的两个变量都有前缀self。以self为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。self.name = name获取存储在形参name中的值，并将其存储到变量name中，然后该变量被关联到当前创建的实例。 self.age = age的作用与此类似。像这样可通过实例访问的变量称为属性。 Dog类还定义了另外两个方法：sit()和roll_over()。由于这些方法不需要额外的信息，如名字或年龄，因此它们只有一个形参self。我们后面将创建的实例能够访问这些方法，换句话说，它们都会蹲下和打滚。当前， sit()和roll_over()所做的有限，它们只是打印一条消息，指出小狗正蹲下或打滚。但可以扩展这些方法以模拟实际情况：如果这个类包含在一个计算机游戏中，这些方法将包含创建小狗蹲下和打滚动画效果的代码。如果这个类是用于控制机器狗的，这些方法将引导机器狗做出蹲下和打滚的动作。 根据类创建实例 可将类视为有关如何创建实例的说明。 Dog类是一系列说明，让Python知道如何创建表示特定小狗的实例。 my_dog = Dog('willie', 6) print(\"My dog's name is \" + my_dog.name.title() + \".\") print(\"My dog is \" + str(my_dog.age) + \" years old.\") my_dog = Dog('willie', 6)让Python创建一条名字为'willie'、年龄为6的小狗。遇到这行代码时， Python使用实参'willie'和6调用Dog类中的方法init()。方法init()创建一个表示特定小狗的示例，并使用我们提供的值来设置属性name和age。方法init()并未显式地包含return语句，但Python自动返回一个表示这条小狗的实例。我们将这个实例存储在变量my_dog中。在这里，命名约定很有用：我们通常可以认为首字母大写的名称（如Dog）指的是类，而小写的名称（如my_dog）指的是根据类创建的实例。 访问属性 要访问实例的属性，可使用句点表示法。编写了如下代码来访问my_dog的属性name的值： my_dog.name 句点表示法在Python中很常用，这种语法演示了Python如何获悉属性的值。在这里， Python先找到实例my_dog，再查找与这个实例相关联的属性name。在Dog类中引用这个属性时，使用的是self.name。 调用方法 根据Dog类创建实例后，就可以使用句点表示法来调用Dog类中定义的任何方法。下面来让小狗蹲下和打滚： my_dog = Dog('willie', 6) my_dog.sit() my_dog.roll_over() 创建多个实例 my_dog = Dog('willie', 6) your_dog = Dog('lucy', 3) print(\"My dog's name is \" + my_dog.name.title() + \".\") print(\"My dog is \" + str(my_dog.age) + \" years old.\") my_dog.sit() print(\"\\nYour dog's name is \" + your_dog.name.title() + \".\") print(\"Your dog is \" + str(your_dog.age) + \" years old.\") your_dog.sit() 输出： My dog's name is Willie. My dog is 6 years old. Willie is now sitting. Your dog's name is Lucy. Your dog is 3 years old. Lucy is now sitting. 类和实例 class Car(): \"\"\"一次模拟汽车的简单尝试\"\"\" def __init__(self, make, model, year): \"\"\"初始化描述汽车的属性\"\"\" self.make = make self.model = model self.year = year def get_descriptive_name(self): \"\"\"返回整洁的描述性信息\"\"\" long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() my_new_car = Car('audi', 'a4', 2016) print(my_new_car.get_descriptive_name()) 定义了方法__init__()。与前面的Dog类中一样，这个方法的第一个形参为self；我们还在这个方法中包含了另外三个形参： make、 model和year。方法__init__()接受这些形参的值，并将它们存储在根据这个类创建的实例的属性中。 创建新的Car实例时，我们需要指定其制造商、型号和生产年份。 定义了一个名为get_descriptive_name()的方法，它使用属性year、 make和model创建一个对汽车进行描述的字符串，让我们无需分别打印每个属性的值。为在这个方法中访问属性的值，我们使用了self.make、 self.model和self.year。 给属性指定默认值 类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法init()内指定这种初始值是可行的；如果你对某个属性这样做了，就无需包含为它提供初始值的形参。 下面来添加一个名为odometer_reading的属性，其初始值总是为0。我们还添加了一个名为 read_odometer()的方法，用于读取汽车的里程表： class Car(): def __init__(self, make, model, year): \"\"\"初始化描述汽车的属性\"\"\" self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): \"\"\"返回整洁的描述性信息\"\"\" long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): \"\"\"打印一条指出汽车里程的消息\"\"\" print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") my_new_car = Car('audi', 'a4', 2016) print(my_new_car.get_descriptive_name()) my_new_car.read_odometer() 输出： 2016 Audi A4 This car has 0 miles on it. 修改属性的值 可以以三种不同的方式修改属性的值：直接通过实例进行修改；通过方法进行设置；通过方法进行递增（增加特定的值）。 直接修改属性的值 要修改属性的值，最简单的方式是通过实例直接访问它。 class Car(): --snip-- my_new_car = Car('audi', 'a4', 2016) print(my_new_car.get_descriptive_name()) my_new_car.odometer_reading = 23 my_new_car.read_odometer() 用句点表示法来直接访问并设置汽车的属性odometer_reading。这行代码让Python在实例my_new_car中找到属性odometer_reading，并将该属性的值设置为23： 通过方法修改属性的值 如果有替你更新属性的方法，将大有裨益。这样，你就无需直接访问属性，而可将值传递给一个方法，由它在内部进行更新。 class Car(): --snip-- def update_odometer(self, mileage): \"\"\"将里程表读数设置为指定的值\"\"\" self.odometer_reading = mileage my_new_car = Car('audi', 'a4', 2016) print(my_new_car.get_descriptive_name()) my_new_car.update_odometer(23) my_new_car.read_odometer() 添加了方法update_odometer()。这个方法接受一个里程值，并将其存储到self.odometer_reading中。 调用了update_odometer()，并向它提供了实参23（该实参对应于方法定义中的形参mileage）。它将里程表读数设置为23； 通过方法对属性的值进行递增 有时候需要将属性值递增特定的量，而不是将其设置为全新的值。假设我们购买了一辆二手车，且从购买到登记期间增加了100英里的里程，下面的方法让我们能够传递这个增量，并相应地增加里程表读数： class Car(): --snip-- def update_odometer(self, mileage): --snip-- def increment_odometer(self, miles): \"\"\"将里程表读数增加指定的量\"\"\" self.odometer_reading += miles my_used_car = Car('subaru', 'outback', 2013) print(my_used_car.get_descriptive_name()) my_used_car.update_odometer(23500) my_used_car.read_odometer() my_used_car.increment_odometer(100) my_used_car.read_odometer() 输出： 2013 Subaru Outback This car has 23500 miles on it. This car has 23600 miles on it. 新增的方法increment_odometer()接受一个单位为英里的数字，并将其加入到self.odometer_reading中。 创建了一辆二手车——my_used_car。 调用方法update_odometer()并传入23500，将这辆二手车的里程表读数设置为23 500。 调用increment_odometer()并传入100，以增加从购买到登记期间行驶的100英里： 继承 编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类，而新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。 子类的方法init() 创建子类的实例时， Python首先需要完成的任务是给父类的所有属性赋值。为此，子类的方法init()需要父类施以援手。 例如，下面来模拟电动汽车。电动汽车是一种特殊的汽车，因此我们可以在前面创建的Car类的基础上创建新类ElectricCar，这样我们就只需为电动汽车特有的属性和行为编写代码。 下面来创建一个简单的ElectricCar类版本，它具备Car类的所有功能： class Car(): \"\"\"一次模拟汽车的简单尝试\"\"\" def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") def update_odometer(self, mileage): if mileage >= self.odometer_reading: self.odometer_reading = mileage else: print(\"You can't roll back an odometer!\") def increment_odometer(self, miles): self.odometer_reading += miles class ElectricCar(Car): \"\"\"电动汽车的独特之处\"\"\" def __init__(self, make, model, year): \"\"\"初始化父类的属性\"\"\" super().__init__(make, model, year) my_tesla = ElectricCar('tesla', 'model s', 2016) print(my_tesla.get_descriptive_name()) 创建子类时，父类必须包含在当前文件中，且位于子类前面。 定义了子类ElectricCar。 定义子类时，必须在括号内指定父类的名称。方法init()接受创建Car实例所需的信息. super()是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar的父类的方法__init__()，让ElectricCar实例包含父类的所有属性。父类也称为超类（ superclass），名称super因此而得名。 my_tesla = ElectricCar('tesla', 'model s', 2016)建ElectricCar类的一个实例，并将其存储在变量mytesla中。这行代码调用ElectricCar类中定义的方法init()，后者让Python调用父类Car中定义的方法 _init()。 给子类定义属性和方法 让一个类继承另一个类后，可添加区分子类和父类所需的新属性和方法。 添加一个电动汽车特有的属性（电瓶），以及一个描述该属性的方法。我们将存储电 瓶容量，并编写一个打印电瓶描述的方法： class ElectricCar(Car): def __init__(self, make, model, year): \"\"\" 电动汽车的独特之处 初始化父类的属性，再初始化电动汽车特有的属性 \"\"\" super().__init__(make, model, year) self.battery_size = 70 def describe_battery(self): \"\"\"打印一条描述电瓶容量的消息\"\"\" print(\"This car has a \" + str(self.battery_size) + \"-kWh battery.\") my_tesla = ElectricCar('tesla', 'model s', 2016) print(my_tesla.get_descriptive_name()) my_tesla.describe_battery() 重写父类的方法 对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样， Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。 假设Car类有一个名为fill_gas_tank()的方法，它对全电动汽车来说毫无意义，因此你可能 想重写它。下面演示了一种重写方式： def ElectricCar(Car): --snip-- def fill_gas_tank(): \"\"\"电动汽车没有油箱\"\"\" print(\"This car doesn't need a gas tank!\") 现在，如果有人对电动汽车调用方法fill_gas_tank()， Python将忽略Car类中的方法fill_gas_tank()，转而运行上述代码。使用继承时，可让子类保留从父类那里继承而来的精华，并剔除不需要的糟粕。 将实例用作属性 使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。你可以将大型类拆分成多个协同工作的小类。 例如，不断给ElectricCar类添加细节时，我们可能会发现其中包含很多专门针对汽车电瓶的属性和方法。在这种情况下，我们可将这些属性和方法提取出来，放到另一个名为Battery的类中，并将一个Battery实例用作ElectricCar类的一个属性： class Car(): \"\"\"一次模拟汽车的简单尝试\"\"\" def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") def update_odometer(self, mileage): if mileage >= self.odometer_reading: self.odometer_reading = mileage else: print(\"You can't roll back an odometer!\") def increment_odometer(self, miles): self.odometer_reading += miles class Battery(): \"\"\"一次模拟电动汽车电瓶的简单尝试\"\"\" def __init__(self, battery_size=70): \"\"\"初始化电瓶的属性\"\"\" self.battery_size = battery_size def describe_battery(self): \"\"\"打印一条描述电瓶容量的消息\"\"\" print(\"This car has a \" + str(self.battery_size) + \"-kWh battery.\") class ElectricCar(Car): def __init__(self, make, model, year): \"\"\" 电动汽车的独特之处 初始化父类的属性，再初始化电动汽车特有的属性 \"\"\" super().__init__(make, model, year) self.battery = Battery() def describe_battery(self): \"\"\"打印一条描述电瓶容量的消息\"\"\" print(\"This car has a \" + str(self.battery.battery_size) + \"-kWh battery.\") my_tesla = ElectricCar('tesla', 'model s', 2016) print(my_tesla.get_descriptive_name()) my_tesla.battery.describe_battery() 输出： 2016 Tesla Model S This car has a 70-kWh battery. 定义了一个名为Battery的新类，它没有继承任何类。 方法__init__()除 self 外，还有另一个形参batterysize。这个形参是可选的：如果没有给它提供值，电瓶容量将被设置为70。方法describebattery()也移到了这个类中. 在ElectricCar类中，我们添加了一个名为self.battery的属性。这行代码让Python创建一个新的Battery实例（由于没有指定尺寸，因此为默认值70），并将该实例存储在属性self.battery中。每当方法`__init()`被调用时，都将执行该操作；因此现在每个ElectricCar实例都包含一个自动创建的Battery实例。 我们创建一辆电动汽车，并将其存储在变量my_tesla中。要描述电瓶时，需要使用电动汽车的属性battery： my_tesla.battery.describe_battery() 导入类 随着你不断地给类添加功能，文件可能变得很长，即便你妥善地使用了继承亦如此。为遵循Python的总体理念，应让文件尽可能整洁。为在这方面提供帮助， Python允许你将类存储在模块中，然后在主程序中导入所需的模块。 导入单个类 创建一个只包含Car类的模块。这让我们面临一个微妙的命名问题：在本章中，已经有一个名为car.py的文件，但这个模块也应命名为car.py，因为它包含表示汽车的代码。我们将这样解决这个命名问题：将Car类存储在一个名为car.py的模块中，该模块将覆盖前面使用的文件car.py。从现在开始，使用该模块的程序都必须使用更具体的文件名，如my_car.py。下面是模块car.py，其中只包含Car类的代码： #car.py \"\"\"一个可用于表示汽车的类\"\"\" class Car(): \"\"\"一次模拟汽车的简单尝试\"\"\" def __init__(self, make, model, year): \"\"\"初始化描述汽车的属性\"\"\" self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): \"\"\"返回整洁的描述性名称\"\"\" long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): \"\"\"打印一条消息，指出汽车的里程\"\"\" print(\"This car has \" + str(self.odometer_reading) + \" miles on it.\") def update_odometer(self, mileage): \"\"\" 将里程表读数设置为指定的值 拒绝将里程表往回拨 \"\"\" if mileage >= self.odometer_reading: self.odometer_reading = mileage else: print(\"You can't roll back an odometer!\") def increment_odometer(self, miles): \"\"\"将里程表读数增加指定的量\"\"\" self.odometer_reading += miles 导入Car类并创建其实例： from car import Car my_new_car = Car('audi', 'a4', 2016) print(my_new_car.get_descriptive_name()) my_new_car.odometer_reading = 23 my_new_car.read_odometer() 在一个模块中存储多个类 虽然同一个模块中的类之间应存在某种相关性，但可根据需要在一个模块中存储任意数量的类。类Battery和ElectricCar都可帮助模拟汽车，因此下面将它们都加入模块car.py中： #car.py \"\"\"一组用于表示燃油汽车和电动汽车的类\"\"\" class Car(): --snip-- class Battery(): \"\"\"一次模拟电动汽车电瓶的简单尝试\"\"\" def __init__(self, battery_size=60): \"\"\"初始化电瓶的属性\"\"\" self.battery_size = battery_size def describe_battery(self): \"\"\"打印一条描述电瓶容量的消息\"\"\" print(\"This car has a \" + str(self.battery_size) + \"-kWh battery.\") def get_range(self): \"\"\"打印一条描述电瓶续航里程的消息\"\"\" if self.battery_size == 70: range = 240 elif self.battery_size == 85: range = 270 message = \"This car can go approximately \" + str(range) message += \" miles on a full charge.\" print(message) class ElectricCar(Car): \"\"\"模拟电动汽车的独特之处\"\"\" def __init__(self, make, model, year): \"\"\" 初始化父类的属性，再初始化电动汽车特有的属性 \"\"\" super().__init__(make, model, year) self.battery = Battery() 现在，可以新建一个名为my_electric_car.py的文件，导入ElectricCar类，并创建一辆电动汽车了： #my_electric_car.py from car import ElectricCar my_tesla = ElectricCar('tesla', 'model s', 2016) print(my_tesla.get_descriptive_name()) my_tesla.battery.describe_battery() my_tesla.battery.get_range() 从一个模块中导入多个类 可根据需要在程序文件中导入任意数量的类。如果我们要在同一个程序中创建普通汽车和电动汽车，就需要将Car和ElectricCar类都导入： #my_cars.py from car import Car, ElectricCar my_beetle = Car('volkswagen', 'beetle', 2016) print(my_beetle.get_descriptive_name()) my_tesla = ElectricCar('tesla', 'roadster', 2016) print(my_tesla.get_descriptive_name()) 从一个模块中导入多个类时，用逗号分隔了各个类。导入必要的类后，就可根据需要创建每个类的任意数量的实例。 导入整个模块 还可以导入整个模块，再使用句点表示法访问需要的类。这种导入方法很简单，代码也易于阅读。由于创建类实例的代码都包含模块名，因此不会与当前文件使用的任何名称发生冲突。 #my_cars.py import car my_beetle = car.Car('volkswagen', 'beetle', 2016) print(my_beetle.get_descriptive_name()) my_tesla = car.ElectricCar('tesla', 'roadster', 2016) print(my_tesla.get_descriptive_name()) Update time： 2020-05-25 "},"面向对象/面向对象编程.html":{"url":"面向对象/面向对象编程.html","title":"python 面向对象编程","keywords":"","body":"python 面向对象编程 ﻿面向对象编程中，将函数和变量进一步封装成类，类才是程序的基本元素，它将数据和操作紧密地连结在一起，并保护数据不会被外界的函数意外地改变。类和和类的实例（也称对象）是面向对象的核心概念 import sys import time reload(sys) sys.setdefaultencoding('utf-8') class studetn: # 定义一个类名为studetn def __init__(self,idx): # 定义初始化构造，这里使用init，还有别的属性比如reversed，iter之类的 self.idx=idx # 初始化变量，方便继承 def runx(self): # 定义运行函数，从上面继承变量 print self.idx # 打印出idx的值，或者做一些别的处理 time.sleep(1) a=studetn('a') a.runx() # 这是类的调用，一定要记得类的使用方法，首先传入参数，类赋值给一个变量a # 然后调用这个类下面定义的函数 一些专业术语概念，既然有面向对象编程这个高大上的定义了，自然要搭配一些高大上的概念。 类(Class): 用来描述具有相同属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。其中的对象被称作类的实例。 实例：也称对象。通过类定义的初始化方法，赋予具体的值，成为一个”有血有肉的实体”。 实例化：创建类的实例的过程或操作。 实例变量：定义在实例中的变量，只作用于当前实例。 类变量：类变量是所有实例公有的变量。类变量定义在类中，但在方法体之外。 数据成员：类变量、实例变量、方法、类方法、静态方法和属性等的统称。 方法：类中定义的函数。 静态方法：不需要实例化就可以由类执行的方法 类方法：类方法是将类本身作为对象进行操作的方法。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对父类的方法进行改写，这个过程也称override。 封装：将内部实现包裹起来，对外透明，提供api接口进行调用的机制 继承：即一个派生类（derived class）继承父类（base class）的变量和方法。 多态：根据对象类型的不同以不同的方式进行处理。 类与实例 import sys import time import requests class cc: ccc = 'ccc' # cc就是类名 如果想要继承别的类 就class cc(threading) 意思就是从threading继承 def __init__(self,a,b,c): self.a=a self.b=b self.c=c # 定义构造的过程就是实例化 def runx(self): print(self.a*10) print(self.b*5) print(self.c*2) def runy(self): print(('http://www.langzi.fun')) e = cc('AAA','CCC','EEE') e.runx() ''' AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA CCCCCCCCCCCCCCC EEEEEE ''' e.runy() #http://www.langzi.fun # 这两个就是调用类里面的方法 print(e.c) #EEE #实例变量指的是实例本身拥有的变量。每个实例的变量在内存中都不一样。 print(e.ccc) #ccc #类变量，在类里面找到定义的变量。 调用类的三种方法 实例方法 import sys import time import requests reload(sys) sys.setdefaultencoding('utf-8') class dd: def __init__(self,url): self.url=url def runx(self): print requests.get(self.url).status_code a = dd('http://www.langzi.fun') a.runx() # 这种调用方法就是实例方法 静态方法 静态方法由类调用，无默认参数。将实例方法参数中的self去掉，然后在方法定义上方加上@staticmethod，就成为静态方法。它属于类，和实例无关。建议只使用类名.静态方法的调用方式。（虽然也可以使用实例名.静态方法的方式调用） import sys import requests reload(sys) sys.setdefaultencoding('utf-8') class ff: @staticmethod def runx(): print requests.get('http://www.langzi.fun').status_code ff.runx() #这里就直接调用了类的变量，只在类中运行而不在实例中运行的方法 经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法. 比如更改环境变量或者修改其他类的属性等能用到静态方法. 这种情况可以直接用函数解决, 但这样同样会扩散类内部的代码，造成维护困难。 类方法 类方法由类调用，采用@classmethod装饰，至少传入一个cls代指类本身，类似self）参数。执行类方法时，自动将调用该方法的类赋值给cls。建议只使用类名.类方法的调用方式。（虽然也可以使用实例名.类方法的方式调用） 如果要构造一个类，接受一个网站和这个网站的状态码，然后打印出来。就像这样： import sys import requests reload(sys) sys.setdefaultencoding('utf-8') class gg: def __init__(self,url,stat): self.url=url self.stat=stat def outer(self): print self.url print self.stat a = gg('langzi',200) a.outer() 这样就是使用实例方法，虽然可以实现，但是有的时候传入的参数并不是(‘langzi’,200)这样的格式，而是(‘langzi-200’)这样的，那该怎么做？首先要把这个拆分，但是要使用实例方法实现起来很麻烦，这个时候就可以使用类方法。 import sys import requests reload(sys) sys.setdefaultencoding('utf-8') class gg: url = 0 stat = 0 # 因为使用classmethod后会传入新的变量，所以一开始是需要自己先定义类变量 def __init__(self,url=0,stat=0): # 这里按照正常的定义构造函数 self.url=url self.stat=stat @classmethod # 装饰器，立马执行下面的函数 def split(cls,info): # 这个函数接受两个参数，默认的cls就是这个类的init函数，info就是外面传入进来的 url,stat=map(str,info.split('-')) # 这里转换成了格式化的结构 data = cls(url,stat) # 然后执行这个类第一个方法，这个类构造函数需要传入两个参数，于是就传入了两个参数 return data # 这里就直接返回了函数结果 def outer(self): print self.url print self.stat r = gg.split(('langzi-200')) r.outer() # 这里是调用类方法，与调用实例方法一样 魔法方法 在上面有提到除了init之外还有iter,reverse的方法，这里就详细说下除了init初始化还有哪些别的方法。 __init__ : 构造函数，在生成对象时调用 __del__ : 析构函数，释放对象时使用 __repr__ : 打印，转换 __setitem__ : 按照索引赋值 __getitem__: 按照索引获取值 __len__: 获得长度 __cmp__: 比较运算 __call__: 调用 __add__: 加运算 __sub__: 减运算 __mul__: 乘运算 __div__: 除运算 __mod__: 求余运算 __pow__: 幂 具体使用 1. doc 说明性文档和信息。Python自建，无需自定义。 class Foo: \"\"\" 描述类信息，可被自动收集 \"\"\" def func(self): pass # 打印类的说明文档 print(Foo.__doc__) 2. init() 实例化方法，通过类创建实例时，自动触发执行。 class Foo: def __init__(self, name): self.name = name self.age = 18 obj = Foo(jack') # 自动执行类中的 __init__ 方法 3. __module__和 __class__ module 表示当前操作的对象在属于哪个模块。 class 表示当前操作的对象属于哪个类。 这两者也是Python内建，无需自定义。 class Foo: pass obj = Foo() print(obj.__module__) print(obj.__class__) 运行结果： main 4. __del()__ 析构方法，当对象在内存中被释放时，自动触发此方法。 注：此方法一般无须自定义，因为Python自带内存分配和释放机制，除非你需要在释放的时候指定做一些动作。析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。 class Foo: def __del__(self): print(\"我被回收了！\") obj = Foo() del obj 5. call() 如果为一个类编写了该方法，那么在该类的实例后面加括号，可会调用这个方法。 注：构造方法的执行是由类加括号执行的，即：对象 = 类名()，而对于call() 方法，是由对象后加括号触发的，即：对象() 或者 类()() class Foo: def __init__(self): pass def __call__(self, *args, **kwargs): print('__call__') obj = Foo() # 执行 __init__ obj() # 执行 __call__ 可以用Python内建的callable()函数进行测试，判断一个对象是否可以被执行。 callable(Student()) 运行结果： True 6. dict 列出类或对象中的所有成员！非常重要和有用的一个属性，Python自建，无需用户自己定义。 class Province: country = 'China' def __init__(self, name, count): self.name = name self.count = count def func(self, *args, **kwargs): print（'func'） # 获取类的成员 print(Province.__dict__) # 获取 对象obj1 的成员 obj1 = Province('HeBei',10000) print(obj1.__dict__) # 获取 对象obj2 的成员 obj2 = Province('HeNan', 3888) print(obj2.__dict__) 7. str() 如果一个类中定义了str()方法，那么在打印对象时，默认输出该方法的返回值。这也是一个非常重要的方法，需要用户自己定义。　 下面的类，没有定义str()方法，打印结果是 class Foo: pass obj = Foo() print(obj) 定义了__str__()方法后，打印结果是：'jack'。 class Foo: def __str__(self): return 'jack' obj = Foo() print(obj) #jack 8、getitem()、setitem()、delitem() 取值、赋值、删除这“三剑客”的套路，在Python中，我们已经见过很多次了，比如前面的@property装饰器。 Python中，标识符后面加圆括号，通常代表执行或调用方法的意思。而在标识符后面加中括号[]，通常代表取值的意思。Python设计了getitem()、setitem()、delitem()这三个特殊成员，用于执行与中括号有关的动作。它们分别表示取值、赋值、删除数据。 Update time： 2020-05-25 "},"面向对象/绑定方法与非绑定方法.html":{"url":"面向对象/绑定方法与非绑定方法.html","title":"python 绑定方法与非绑定方法","keywords":"","body":"python 绑定方法与非绑定方法 绑定方法 （绑定给谁，谁来调用就自动将它本身当作第一个参数传入）： 绑定到类的方法：用classmethod装饰器装饰的方法。为类量身定制 类.boud_method(),自动将类当作第一个参数传入 （其实对象也可调用，但仍将类当作第一个参数传入） 绑定到对象的方法：没有被任何装饰器装饰的方法。为对象量身定制 对象.boud_method(),自动将对象当作第一个参数传入 （属于类的函数，类可以调用，但是必须按照函数的规则来，没有自动传值那么一说） 首先我们明确一个知识点，凡是类中的方法或函数，默认情况下都是绑定给对象使用的。 class People: def __init__(self,name,age): self.name = name self.age = age def talk(self): pass p = People('xiaohua',18) print(p.talk) 输出结果： > 从上面的输出结果来看，talk()這个类中的方法，是绑定给对象使用的。下面，我在看看另外一种情况。 class People: def __init__(self,name,age): self.name = name self.age = age def talk(): pass p = People('xiaohua',18) print(p.talk) 输出结果： > 　现在，我们将talk()函数的参数去掉，结果显示与上面是一样。这说明，不管是类中的方法，还是类中函数，默认情况下都是绑定给对象使用的。绑定给对象使用有一种好处，那就是不用手动将对象传入。对象是自动传到类中。 看看下面的例子： class People: def __init__(self,name,age): self.name = name self.age = age def talk(): pass p = People('xiaohua',18) print(People.talk) print(p.talk) 输出结果： 类来调用仅仅是当作函数使用 > 而对象来调用则为绑定方法 上面很好说明了，如果类来调用类中的方法，那么这个方法仅仅只是一个函数，那么既然是函数，就不会有自动传值这一功能。来看看下面代码： class People: def __init__(self,name,age): self.name = name self.age = age def talk(self): pass p = People('xiaohua',18) People.talk() 1 p.talk() 2 #代码1处报错 talk() missing 1 required positional argument: 'self' #代码2处正常 从上面输出结果来看，当类调用类中的方法时候i，是不会进行自动传值的，也就是说，函数有几个参数，我们就得传递进去几个参数。如果想结果正常运行，那么在类名调用talk()的时候，将参数一一都传递进去。即： People.talk(312312) 這个参数可以是任意的，但是，必须传递进去。 而，当对象调用类中方法时候，则不用传递，如上面的2正常执行。既然知道了区别，那么，我们来看看下面代码： class People: def __init__(self,name,age): self.name = name self.age = age def talk(): pass p = People('xiaohua',18) People.talk() 1 p.talk() 2 # 1处正常执行 # 2 处报错 talk() takes 0 positional arguments but 1 was given 从输出结果来看，People来调用talk()方法时候，并不需要传递参数；而当对象来调用talk()的时候，由于对象调用自己的绑定方法，会自动将对象当作第一个参数传递进去，所以，当类中talk()方法没有带参数时，而你又给它传递了一个，显然是会报错的。 综上所述，我们可以得出以下结论：　 凡是类中的方法和函数，都是绑定给对象使用的； 绑定方法都有自动传值的功能。传递进去的值，就是对象本身。 如果类想调用绑定方法，就必须遵循函数的参数规则，有几个参数，就必须传递几个参数。 绑定到类的方法 既然类中的方法，默认都是绑定给对象使用，那么，我们要采取一点措施，将类中的绑定方法解除对象绑定关系，进而绑定到类上。 　在python中，引入了@classmethod 方法，将类中的方法绑定到类身上。下面看看代码： class People: @classmethod def talk(cls): pass p = People() print(People.talk) #输出结果 > 从上述结果可以看出，我们加上了一个装饰器，将类中绑定给对象的方法，绑定到类身上了。 我们之前分析过，如果一个方法绑定到谁身上，那么在调用该函数的时候，将自动将该调用者当作第一个参数传递到函数中。 但是，绑定到类的方法与绑定到对象方法有一点点不同： class People: def __init__(self,name): self.name = name @classmethod def talk(cls): pass p = People('xiaohua') print(People.talk) print(p.talk) #输出结果 > > 也就是说，当对象在调用类的绑定方法时，也会默认把类当作参数传递进去！所以下面执行正常，并不会因为這个方法绑定到类身上，而对象调用没有传递参数，报错！ class People: @classmethod def talk(cls): pass p = People() People.talk() p.talk() 但是，如果talk()没有参数，则下面代码均会报错。 class People: @classmethod def talk(): pass p = People() People.talk() p.talk() #报错结果 talk() takes 0 positional arguments but 1 was given 两者报错结果一致，这就说明了，当对象来调用类的绑定方法时，也是自动将类传递进去，并不需遵循函数参数传递的规则。 类中方法默认都是绑定给对象使用，当对象调用绑定方法时，会自动将对象作为第一个参数传递进去；而类来调用，则必须遵循函数参数一一对应的规则，有几个参数，就必须传递几个参数。如果一个方法是用了@classmethod装饰器，那么這个方法绑定到类身上，不管是对象来调用还是类调用，都会将类作为第一个参数传递进去。 非绑定方法 类中的方法要么是绑定给对象使用，要么是绑定给类使用，那么有没有不绑定给两者使用的函数？ 当然有，python给我们提供了@staticmethod，可以解除绑定关系，将一个类中的方法，变为一个普通函数。 用 staticmethod 装饰器装饰的方法 不与类或对象绑定，类和对象都可以调用，但是没有自动传值那么一说。就是一个普通工具而已 注意：与绑定到对象方法区分开，==在类中直接定义的函数，没有被任何装饰器装饰的，都是绑定到对象的方法可不是普通函数，对象调用该方法会自动传值==，，而staticmethod装饰的方法，不管谁来调用，都没有自动传值 import hashlib import time class MySQL: def __init__(self,host,port): self.id=self.create_id() self.host=host self.port=port @staticmethod def create_id(): #就是一个普通工具 m=hashlib.md5(str(time.clock()).encode('utf-8')) return m.hexdigest() print(MySQL.create_id) # #查看结果为普通函数 conn=MySQL('127.0.0.1',3306) print(conn.create_id) # #查看结果为普通函数 从上面的输出结果，我们可以看出，使用了@staticmethod装饰了一个函数，那么这个函数跟普通函数没有什么区别。既然是普通函数，那么就遵从函数参数传递规则，有几个参数就传递几个参数。 参考 https://www.cnblogs.com/linhaifeng/articles/7341177.html python类的绑定方法与非绑定方法 Update time： 2020-05-25 "},"面向对象/实例方法、类方法和静态方法.html":{"url":"面向对象/实例方法、类方法和静态方法.html","title":"python 实例方法、类方法和静态方法","keywords":"","body":"python 实例方法、类方法和静态方法 在 Python 中，实例方法（instance method），类方法（class method）与静态方法（static method）经常容易混淆。 实例方法 Python 的实例方法用得最多，也最常见。我们先来看 Python 的实例方法。 class Kls(object): def __init__(self, data): self.data = data def printd(self): print(self.data) ik1 = Kls('leo') ik2 = Kls('lee') ik1.printd() ik2.printd() 输出： leo lee 上述例子中，printd为一个实例方法。实例方法第一个参数为self，当使用ik1.printd()调用实例方法时，实例ik1会传递给self参数，这样self参数就可以引用当前正在调用实例方法的实例。利用实例方法的这个特性，上述代码正确输出了两个实例的成员数据。 类方法 Python 的类方法采用装饰器@classmethod来定义 class Kls(object): num_inst = 0 def __init__(self): Kls.num_inst = Kls.num_inst + 1 @classmethod def get_no_of_instance(cls): return cls.num_inst ik1 = Kls() ik2 = Kls() print ik1.get_no_of_instance() print Kls.get_no_of_instance() 输出： 2 2 静态方法 在开发中，我们常常需要定义一些方法，这些方法跟类有关，但在实现时并不需要引用类或者实例，例如，设置环境变量，修改另一个类的变量，等。这个时候，我们可以使用静态方法。 Python 使用装饰器@staticmethod来定义一个静态方法。 IND = 'ON' class Kls(object): def __init__(self, data): self.data = data @staticmethod def checkind(): return IND == 'ON' def do_reset(self): if self.checkind(): print('Reset done for: %s' % self.data) def set_db(self): if self.checkind(): print('DB connection made for: %s' % self.data) ik1 = Kls(24) ik1.do_reset() ik1.set_db() 输出 Reset done for: 24 DB connection made for: 24 建议使用类名.静态方法的调用方式。 实例方法，类方法与静态方法的区别 我们用代码说明实例方法，类方法，静态方法的区别。注意下述代码中方法foo，class_foo，static_foo的定义以及使用 class Kls(object): def foo(self, x): print('executing foo(%s,%s)' % (self, x)) @classmethod def class_foo(cls,x): print('executing class_foo(%s,%s)' % (cls,x)) @staticmethod def static_foo(x): print('executing static_foo(%s)' % x) ik = Kls() # 实例方法 ik.foo(1) print(ik.foo) print('==========================================') # 类方法 ik.class_foo(1) Kls.class_foo(1) print(ik.class_foo) print('==========================================') # 静态方法 ik.static_foo(1) Kls.static_foo('hi') print(ik.static_foo) 输出 executing foo(,1) > ========================================== executing class_foo(,1) executing class_foo(,1) > ========================================== executing static_foo(1) executing static_foo(hi) 对于实例方法，调用时会把实例ik 作为第一个参数传递给self 参数。因此，调用ik.foo(1) 时输出了实例ik的地址。 对于类方法，调用时会把类Kls 作为第一个参数传递给cls 参数。因此，调用ik.class_foo(1) 时输出了Kls类型信息。 前面提到，可以通过类也可以通过实例来调用类方法，在上述代码中，我们再一次进行了验证。 对于静态方法，调用时并不需要传递类或者实例。其实，静态方法很像我们在类外定义的函数，只不过静态方法可以通过类或者实例来调用而已。 值得注意的是，在上述例子中，foo只是个函数，但当调用ik.foo的时候我们得到的是一个已经跟实例ik绑定的函数。调用foo时需要两个参数，但调用ik.foo时只需要一个参数。foo跟ik进行了绑定，因此，当我们打印ik.foo时，会看到以下输出: > 当调用ik.class_foo时，由于class_foo是类方法，因此，class_foo跟Kls进行了绑定（而不是跟ik绑定）。当我们打印ik.class_foo时，输出： > 当调用ik.static_foo时，静态方法并不会与类或者实例绑定，因此，打印ik.static_foo（或者Kls.static_foo）时输出： 概括来说，是否与类或者实例进行绑定，这就是实例方法，类方法，静态方法的区别。 参考 Python 实例方法、类方法和静态方法 Update time： 2020-05-25 "},"面向对象/面向对象编程--组合.html":{"url":"面向对象/面向对象编程--组合.html","title":"python 面向对象编程--组合","keywords":"","body":"python 面向对象编程--组合 ﻿我们定义一个类是希望能够把类当成模块来使用，并把类嵌入到我们的应用代码中，与其他的数据类型、逻辑执行流结合使用。一般来说我们可以使用两种方法在代码中利用类，那就是组合和派生。 ==组合:== 就是将不同的类混合并加入到其他类中，来 增加类的功能 / 提高代码的重用性 / 易于维护(对类的修改会直接反应到整个应用中) class School: def __init__(self,name,addr): self.name=name self.addr=addr def zhao_sheng(self): print('%s 正在招生' %self.name) class Course: def __init__(self,name,price,period,school): #school为另一个类 self.name=name self.price=price self.period=period self.school=school s1=School('oldboy','北京') c1=Course('linux',10,'1h',s1) print(c1.__dict__) print(c1.school.name) print(s1) 输出： {'name': 'linux', 'price': 10, 'period': '1h', 'school': } oldboy 组合--选课案例 class School: def __init__(self,name,addr): self.name=name self.addr=addr def zhao_sheng(self): print('%s 正在招生' %self.name) class Course: def __init__(self,name,price,period,school): self.name=name self.price=price self.period=period self.school=school s1=School('oldboy','北京') s2=School('oldboy','南京') s3=School('oldboy','东京') # c1=Course('linux',10,'1h','oldboy 北京') # c1=Course('linux',10,'1h',s1) msg=''' 1 老男孩 北京校区 2 老男孩 南京校区 3 老男孩 东京校区 ''' while True: print(msg) menu={ '1':s1, '2':s2, '3':s3 } choice=input('选择学校>>: ') school_obj=menu[choice] name=input('课程名>>： ') price=input('课程费用>>： ') period=input('课程周期>>： ') new_course=Course(name,price,period,school_obj) print('课程【%s】属于【%s】学校' %(new_course.name,new_course.school.name)) 运行： 1 老男孩 北京校区 2 老男孩 南京校区 3 老男孩 东京校区 选择学校>>: 1 课程名>>： lunix 课程费用>>： 100 课程周期>>： 10 课程【lunix】属于【oldboy】学校 派生 当我们希望较小的类是较大的类的组件时，组合是一个很好的处理方式。但当我们希望 相同的类却具有一些不同的功能时 派生就是最好的处理方式。这也是面向对象编程最强大的功能之一 —— 使用一个已经定义好的类，扩展它的功能或者对其进行修改生成一个新的类，但却不会对原来的类造成影响。 子类会从基类继承他们的任何属性(数据和方法)，这种派生是可以继承多代的，且可以同时继承多个基类。 语法： class SubClassName(ParentClass1[, ParentClass2, ...]): class_suite EXAMPLE： In [8]: class Parent(object): ...: def __init__(self): ...: print \"created an instance of: \", self.__class__.__name__ ...: ...: In [9]: class Child(Parent): ...: pass ...: In [10]: c = Child() created an instance of: Child In [14]: p = Parent() created an instance of: Parent 类 Child 的实例对象 c 并没有定义 __init__() 构造器，但仍然执行了 print 语句，这是因为 Child 从 Parent 继承了其构造器。 通过继承来覆盖(重载)方法 当我们派生一个子类，但同时希望相同的方法能在子类实现不同的功能，这时我们需要使用方法的 重载。使子类的方法能够覆盖父类的同名方法。 In [17]: class Parent(object): ...: def func(self): ...: print \"This is Parent.\" ...: In [18]: class Child(Parent): ...: def func(self): ...: print \"This is Child.\" ...: ...: In [19]: p = Parent() In [20]: p.func() This is Parent. In [21]: c = Child() In [22]: c.func() This is Child. 这里子类 Child 重载了父类 Parent 的 func() 方法，实现了不同的功能。 但仍然有些场合需要我们即能使用子类的重载方法的同时，也要求我们重现父类方法的功能。那么我们可以调用那个被我们覆盖的父类方法吗？ 答案是肯定的。 In [23]: Parent.func(c) This is Parent. 我们可以通过 ParentClassName.functionName(object) 的方式来重现父类所被覆盖的方法。当然我们还有其他的方式可以实现这个效果，EG. 在子类的重载方法里显式的调用父类的同名方法： In [24]: class Child(Parent): ...: def func(self): ...: print \"This is Child.\" ...: Parent.func(self) In [25]: c = Child() In [26]: c.func() This is Child. This is Parent. 两种方式本质上是相同的，都是通过 父类名结合句点表达式 来实现对父类方法的调用，而且需要注意的是，在调用的时候必须传递一个实例对象给 func()，否则会触发参数不匹配的语法错误。 还有一个更好的实现方式就是子类使用 super() 内置函数： In [27]: class Child(Parent): ...: def func(self): ...: print \"This is Child.\" ...: super(Child, self).func() ...: In [28]: c = Child() In [29]: c.func() This is Child. This is Parent. super()内置函数不仅能自动的找到父类方法，并且还是自动的为父类方法传入 self 参数来实现实例方法的绑定。 最常用的重载场景(实例方法的重载) 最常用的重载场景莫过于 重载父类的构造器 了。 在上述的例子可以看出，当我们在子类中没有重载构造器的时候，会自动的调用父类的构造器。这很明显是不符合我们的需求的，因为我们常常需要在子类中定义一些新的成员属性。但是问题是：当我们为了初始化子类中新的成员属性时，不可避免的需要重复的编写初始化从父类中继承而来的属性的代码。 这也不符合代码重用的原则，所以我们一般会采用 重载构造器(init()) + 重现父类构造器(super()) 的方式来解决这个问题。 In [32]: class Parent(object): ...: def __init__(self, name, age): ...: self.name = name ...: self.age = age ...: print \"This is Parent.\" ...: In [33]: class Child(Parent): ...: def __init__(self, name, age, sex): # 初始化子类实例对象的属性 ...: super(Child, self).__init__(name, age) # 初始化父类实例对象的属性 ...: self.sex = sex ...: print \"This is Child.\" ...: In [35]: p = Parent(\"fanguiju\", \"24\") This is Parent. In [36]: c = Child(\"fanguiju\", \"24\", \"man\") This is Parent. This is Child. In [37]: c.name Out[37]: 'fanguiju' In [38]: c.age Out[38]: '24' In [39]: c.sex Out[39]: 'man' 一般而言，我们会在子类的构造器中首先调用父类的构造器，当然这并不是强制的。只是为了我们能够在执行子类构造器的代码之前首先完成对父类属性的初始化，防止在调用从父类继承而来的属性时仍未初始化的问题出现。 使用 super() 内置函数的漂亮之处在于，我们不需要明确的给出父类的名字，交由解析器去自动的找到该子类的父类，并自动的传入 self 参数来完成绑定。这样能够让代码具有更高的灵活性，我们只需要改变子类的定义语句，就可以改变类的继承关系。 从标准类中派生(类方法的重载) 不可变数据类型的派生：定义一个精度为 2 的浮点数据类型 派生不可变标准类，经常需要重载类方法，而类方法的重载一般是重载 __new__()，也就是所谓的 真·构造器 。 class RoundFloat(float): def __new__(cls, value): return float.__new__(cls, round(value, 2)) # 将类对象 float 传入参数 cls In [44]: RoundFloat(1.1111111) Out[44]: 1.11 真·构造器会自动的将类对象 RoundFloat 传入 cls 参数，类似于构造器__init__(self)。 可变数据类型的派生：定义一个有序的字典数据类型 可变数据类型的派生可能不需要使用 构造器 或者 真·构造器 也能够实现。 class SortedDict(dict): def keys(self): return sorted(super(SortedDict, self).keys()) In [47]: for x in SortedDict(((\"name\", \"fanguiju\"), (\"age\", 24), (\"sex\", \"man\"))): ...: print x ...: age name sex 通过 SortedDict 生成的字典按照字母的顺序排序。 参考 Python 进阶OOP 面向对象编程组合与继承 Update time： 2020-05-25 "},"面向对象/ 子类继承父类构造函数说明.html":{"url":"面向对象/ 子类继承父类构造函数说明.html","title":"python 子类继承父类构造函数说明","keywords":"","body":"python 子类继承父类构造函数说明 ﻿如果在子类中需要父类的构造方法就需要显式地调用父类的构造方法，或者不重写父类的构造方法。 子类不重写 __init__，实例化子类时，会自动调用父类定义的 __init__。 class Father(object): def __init__(self, name): self.name=name print ( \"name: %s\" %( self.name) ) def getName(self): return 'Father ' + self.name class Son(Father): def getName(self): return 'Son '+self.name if __name__=='__main__': son=Son('runoob') print ( son.getName() ) #输出： #name: runoob #Son runoob 如果重写了__init__ 时，实例化子类，就不会调用父类已经定义的 __init__，语法格式如下： class Father(object): def __init__(self, name): self.name=name print ( \"name: %s\" %( self.name) ) def getName(self): return 'Father ' + self.name class Son(Father): def __init__(self, name): print ( \"hi\" ) self.name = name def getName(self): return 'Son '+self.name if __name__=='__main__': son=Son('runoob') print ( son.getName() ) #输出： #hi #Son runoob 如果重写了__init__ 时，要继承父类的构造方法，可以使用 super关键字： super(子类，self).__init__(参数1，参数2，....) 或者 父类名称.__init__(self,参数1，参数2，...) class Father(object): def __init__(self, name): self.name=name print ( \"name: %s\" %( self.name)) def getName(self): return 'Father ' + self.name class Son(Father): def __init__(self, name): super(Son, self).__init__(name) print (\"hi\") self.name = name def getName(self): return 'Son '+self.name if __name__=='__main__': son=Son('runoob') print ( son.getName() ) #输出： #name: runoob #hi #Son runoob 转自：https://www.runoob.com/w3cnote/python-extends-init.html Update time： 2020-05-26 "},"面向对象/面向对象描述符.html":{"url":"面向对象/面向对象描述符.html","title":"python 面向对象描述符","keywords":"","body":"python 面向对象描述符 ﻿ 描述符(__get__,__set__,__delete__) 描述符是什么 描述符本质就是一个新式类,在这个新式类中,至少实现了__get__(),__set__(),__delete__()中的一个,这也被称为描述符协议 __get__():调用一个属性时,触发 __set__():为一个属性赋值时,触发 __delete__():采用 del 删除属性时,触发 __get__用于访问属性。它返回属性的值，或者在所请求的属性不存在的情况下出现 AttributeError 异常。类似于javabean中的get。 __set__将在属性分配操作中调用。不会返回任何内容。类似于javabean中的set。 __delete__控制删除操作。不会返回内容。 描述符协议 __get__(self, instance, owner) :param self: 描述符对象本身 :param instance: 使用描述符的对象的实例 :param owner: 使用描述符的对象拥有者 __set__(self, instance, value) :param value: 对描述符的赋值 __delete__(self, instance) 只实现get方法的对象是非数据描述符，意味着在初始化之后它们只能被读取。而同时实现get和set的对象是数据描述符，意味着这种属性是可读写的。 定义一个描述符 #在python3中Foo是新式类,它实现了三种方法,这个类就被称作一个描述符 class Foo: def __get__(self, instance, owner): ''' instance:实例 owner：实例所属的类 ''' pass def __set__(self, instance, value): pass def __delete__(self, instance): pass 描述符是干什么的 描述符的作用是用来代理另外一个类的属性的(必须把描述符定义成这个类的类属性，不能定义到构造函数中) class name_des(object): def __init__(self): self.__name = None def __get__(self, instance, owner): print('call __get__') return self.__name def __set__(self, instance, value): print('call __set__') if isinstance(value,str): self.__name = value else: raise TypeError(\"Must be an string\") class test(object): name = name_des() t = test() t.name #--->call __get__ # t.name = 3 # #--->call __set__ (类型检查 报异常) # Traceback (most recent call last): # File \"\", line 1, in # t.name = 3 # File \"\", line 12, in __set__ # raise TypeError(\"Must be an string\") # TypeError: Must be an string t.name = 'my name is chenyang' # ---->call __set__ t.name # ---->call __get__ 引子:描述符类产生的实例进行属性操作并不会触发三个方法的执行 class Foo: def __get__(self, instance, owner): print('触发get') def __set__(self, instance, value): print('触发set') def __delete__(self, instance): print('触发delete') #包含这三个方法的新式类称为描述符,由这个类产生的实例进行属性的调用/赋值/删除,并不会触发这三个方法 f1=Foo() f1.name='egon' f1.name del f1.name #疑问:何时,何地,会触发这三个方法的执行 描述符应用之何时?何地? #描述符Str class Str: def __get__(self, instance, owner): print('Str调用') def __set__(self, instance, value): print('Str设置...') def __delete__(self, instance): print('Str删除...') #描述符Int class Int: def __get__(self, instance, owner): print('Int调用') def __set__(self, instance, value): print('Int设置...') def __delete__(self, instance): print('Int删除...') class People: name=Str() age=Int() def __init__(self,name,age): #name被Str类代理,age被Int类代理, self.name=name self.age=age #何地？：定义成另外一个类的类属性 #何时？：且看下列演示 p1=People('alex',18) #直接打印 Str设置... Int设置... #描述符Str的使用 p1.name #打印：Str调用 p1.name='egon' #打印：Str设置... del p1.name #打印： Str删除... #描述符Int的使用 p1.age #输出：Int调用 p1.age=18 #输出：Int设置... del p1.age #输出：Int删除... #到底发生了什么 print(p1.__dict__) # 输出：{} print(People.__dict__) 输出 {'__module__': '__main__', 'name': , 'age': , '__init__': , '__dict__': , '__weakref__': , '__doc__': None} #补充 print(type(p1) == People) #type(obj)其实是查看obj是由哪个类实例化来的 print(type(p1).__dict__ == People.__dict__) 输出： True True 描述符分两种 一 、==数据描述符:至少实现了_ _get_ _()和_ _set_ _()== class Foo: def __set__(self, instance, value): print('set') def __get__(self, instance, owner): print('get') 二 、==非数据描述符:没有实现__set__()== class Foo: def __get__(self, instance, owner): print('get') 注意事项: 一 描述符本身应该定义成新式类,被代理的类也应该是新式类 二 必须把描述符定义成这个类的类属性，不能为定义到构造函数中 三 要严格遵循该优先级,优先级由高到底分别是 1.类属性 2.数据描述符 3.实例属性 4.非数据描述符 5.找不到的属性触发getattr() $\\color{HotPink}{类属性>数据描述符}$ #描述符Str class Str: def __get__(self, instance, owner): print('Str调用') def __set__(self, instance, value): print('Str设置...') def __delete__(self, instance): print('Str删除...') class People: name=Str() def __init__(self,name,age): #name被Str类代理,age被Int类代理, self.name=name self.age=age #基于上面的演示,我们已经知道,在一个类中定义描述符它就是一个类属性,存在于类的属性字典中, 而不是实例的属性字典 #那既然描述符被定义成了一个类属性,直接通过类名也一定可以调用吧,没错 People.name #恩,调用类属性name,本质就是在调用描述符Str,触发了__get__() People.name='egon' #那赋值呢,我去,并没有触发__set__() del People.name #赶紧试试del,我去,也没有触发__delete__() **结论:描述符对类没有作用-------->傻逼到家的结论** ''' 原因:描述符在使用时被定义成另外一个类的类属性,因而类属性比二次加工的描述符伪装而来的类属性 有更高的优先级 People.name #恩,调用类属性name,找不到就去找描述符伪装的类属性name,触发了__get__() People.name='egon' #那赋值呢,直接赋值了一个类属性,它拥有更高的优先级,相当于覆盖了描述符, 肯定不会触发描述符的__set__() del People.name #同上 ''' $\\color{HotPink}{数据描述符>实例属性}$ #描述符Str class Str: def __get__(self, instance, owner): print('Str调用') def __set__(self, instance, value): print('Str设置...') def __delete__(self, instance): print('Str删除...') class People: name=Str() def __init__(self,name,age): #name被Str类代理,age被Int类代理, self.name=name self.age=age p1=People('egon',18) #如果描述符是一个数据描述符(即有__get__又有__set__),那么p1.name的调用与赋值都是 #触发描述符的操作,于p1本身无关了,相当于覆盖了实例的属性 p1.name='egonnnnnn' p1.name print(p1.__dict__)#实例的属性字典中没有name,因为name是一个数据描述符,优先级高于实例属性, #查看/赋值/删除都是跟描述符有关,与实例无关了 del p1.name $\\color{HotPink}{实例属性>非数据描述符}$ class Foo: def func(self): print('我胡汉三又回来了') f1=Foo() f1.func() #调用类的方法,也可以说是调用非数据描述符 #函数是一个非数据描述符对象(一切皆对象么) print(dir(Foo.func)) print(hasattr(Foo.func,'__set__')) #False print(hasattr(Foo.func,'__get__')) #True print(hasattr(Foo.func,'__delete__')) #False #有人可能会问,描述符不都是类么,函数怎么算也应该是一个对象啊,怎么就是描述符了 #,描述符是类没问题,描述符在应用的时候不都是实例化成一个类属性么 #函数就是一个由非描述符类实例化得到的对象 f1.func='这是实例属性啊' print(f1.func) del f1.func #删掉了非数据 f1.func() $\\color{HotPink}{再次验证：实例属性>非数据描述符}$ class Foo: def __set__(self, instance, value): print('set') def __get__(self, instance, owner): print('get') class Room: name=Foo() def __init__(self,name,width,length): self.name=name self.width=width self.length=length #name是一个数据描述符,因为name=Foo()而Foo实现了get和set方法,因而比实例属性有更高的优先级 #对实例的属性操作,触发的都是描述符的 r1=Room('厕所',1,1) r1.name r1.name='厨房' #打印--->： #set #get #set class Foo: def __get__(self, instance, owner): print('get') class Room: name=Foo() def __init__(self,name,width,length): self.name=name self.width=width self.length=length #name是一个非数据描述符,因为name=Foo()而Foo没有实现set方法,因而比实例属性有更低的优先级 #对实例的属性操作,触发的都是实例自己的 r1=Room('厕所',1,1) r1.name r1.name='厨房' #输出为空 非数据描述符>找不到 class Foo: def func(self): print('我胡汉三又回来了') def __getattr__(self, item): print('找不到了当然是来找我啦',item) # item为xxxx属性 f1=Foo() f1.xxxx 输出：找不到了当然是来找我啦 xxxx # 描述符使用 众所周知，python是弱类型语言，即参数的赋值没有类型限制，下面我们通过描述符机制来实现类型限制功能 case1 #描述符 class Str: def __init__(self,name): self.name=name def __get__(self, instance, owner): print('get--->',instance,owner) return instance.__dic__[self.name] def __set__(self, instance, value): print('set--->',instance,value) instance.__dic__[self.name]=value def __delete__(self, instance): print('delete--->',instance) instance.__dic__pop(self.name) class People: #传入的参数为想要描述的键 name=Str('name') def __init__(self,name,age,salary): self.name=name self.age=age self.salary=salary p1=People('egon',18,3231.3) #调用 print(p1.__dict__) p1.name #赋值 print(p1.__dict__) p1.name='egonlin' print(p1.__dict__) #删除 print(p1.__dict__) del p1.name print(p1.__dict__) case2 class Str: def __init__(self,name): self.name=name def __get__(self, instance, owner): print('get--->',instance,owner) return instance.__dict__[self.name] def __set__(self, instance, value): print('set--->',instance,value) instance.__dict__[self.name]=value def __delete__(self, instance): print('delete--->',instance) instance.__dict__.pop(self.name) class People: name=Str('name') def __init__(self,name,age,salary): self.name=name self.age=age self.salary=salary #疑问:如果我用类名去操作属性呢 People.name #报错,错误的根源在于类去操作属性时,会把None传给instance #修订__get__方法 class Str: def __init__(self,name): self.name=name def __get__(self, instance, owner): print('get--->',instance,owner) if instance is None: return self return instance.__dict__[self.name] def __set__(self, instance, value): print('set--->',instance,value) instance.__dict__[self.name]=value def __delete__(self, instance): print('delete--->',instance) instance.__dict__.pop(self.name) class People: name=Str('name') def __init__(self,name,age,salary): self.name=name self.age=age self.salary=salary print(People.name) #完美,解决 拔刀相助 case3 class Str: def __init__(self,name,expected_type): self.name=name self.expected_type=expected_type def __get__(self, instance, owner): print('get--->',instance,owner) if instance is None: return self return instance.__dict__[self.name] def __set__(self, instance, value): print('set--->',instance,value) if not isinstance(value,self.expected_type): #如果不是期望的类型，则抛出异常 raise TypeError('Expected %s' %str(self.expected_type)) instance.__dict__[self.name]=value def __delete__(self, instance): print('delete--->',instance) instance.__dict__.pop(self.name) class People: name=Str('name',str) #新增类型限制str def __init__(self,name,age,salary): self.name=name self.age=age self.salary=salary p1=People(123,18,3333.3)#传入的name因不是字符串类型而抛出异常 磨刀霍霍 case 4 class Typed: # 参数expected_type为要传入的数据类型 def __init__(self,name,expected_type): self.name=name self.expected_type=expected_type def __get__(self, instance, owner): print('get--->',instance,owner) if instance is None: return self return instance.__dict__[self.name] def __set__(self, instance, value): print('set--->',instance,value) if not isinstance(value,self.expected_type): raise TypeError('Expected %s' %str(self.expected_type)) instance.__dict__[self.name]=value def __delete__(self, instance): print('delete--->',instance) instance.__dict__.pop(self.name) class People: #第二个参数为传入的描述符的限定类型 name=Typed('name',str) age=Typed('name',int) salary=Typed('name',float) def __init__(self,name,age,salary): self.name=name self.age=age self.salary=salary p1=People(123,18,3333.3) p1=People('egon','18',3333.3) p1=People('egon',18,3333) 已然能实现功能了，但是问题是，如果我们的类有很多属性，你仍然采用在定义一堆类属性的方式去实现，low， 类的装饰器：为添加属性 类的装饰器:无参 def decorate(cls): print('类的装饰器开始运行啦------>') return cls @decorate #无参:People=decorate(People) class People: def __init__(self,name,age,salary): self.name=name self.age=age self.salary=salary p1=People('egon',18,3333.3) # 打印：类的装饰器开始运行啦------> 类的装饰器:有参 def typeassert(**kwargs):#kwargs={'name':str,'age':int,'salary':float} def decorate(cls): print('类的装饰器开始运行啦------>',kwargs) return cls return decorate @typeassert(name=str,age=int,salary=float) #有参:1.运行typeassert(...)返回结果是decorate,此时参数都传给kwargs 2.People=decorate(People) class People: def __init__(self,name,age,salary): self.name=name self.age=age self.salary=salary p1=People('egon',18,3333.3) #打印： 类的装饰器开始运行啦------> {'name': , 'age': , 'salary': } Case class Typed: def __init__(self,name,expected_type): self.name=name self.expected_type=expected_type def __get__(self, instance, owner): print('get--->',instance,owner) if instance is None: return self return instance.__dict__[self.name] def __set__(self, instance, value): print('set--->',instance,value) if not isinstance(value,self.expected_type): raise TypeError('Expected %s' %str(self.expected_type)) instance.__dict__[self.name]=value def __delete__(self, instance): print('delete--->',instance) instance.__dict__.pop(self.name) def typeassert(**kwargs): #kwargs={'name':str,'age':int,'salary':float} def decorate(cls): print('类的装饰器开始运行啦------>',kwargs) for name,expected_type in kwargs.items(): #kwargs.items()：(('name':str),('age':int).) setattr(cls,name,Typed(name,expected_type)) return cls return decorate @typeassert(name=str,age=int,salary=float) #有参:1.运行typeassert(...)返回结果是decorate,此时参数都传给kwargs 2.People=decorate(People) class People: def __init__(self,name,age,salary): self.name=name self.age=age self.salary=salary print(People.__dict__) p1=People('egon',18,3333.3) 描述符总结 描述符是可以实现大部分python类特性中的底层魔法,包括@classmethod,@staticmethd,@property甚至是__slots__ 属性 描述符是很多高级库和框架的重要工具之一,描述符通常是使用到装饰器或者元类的大型框架中的一个组件. 原文链接 ：https://www.cnblogs.com/linhaifeng/articles/6204014.html#_label4 Update time： 2020-05-25 "},"面向对象/反射机制.html":{"url":"面向对象/反射机制.html","title":"python 反射机制","keywords":"","body":"python 反射机制 def hasattr(*args, **kwargs): # real signature unknown \"\"\" Return whether the object has an attribute with the given name. This is done by calling getattr(obj, name) and catching AttributeError. \"\"\" pass def getattr(object, name, default=None): # known special case of getattr \"\"\" getattr(object, name[, default]) -> value Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y. When a default argument is given, it is returned when the attribute doesn't exist; without it, an exception is raised in that case. \"\"\" pass 什么是反射 反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。 python面向对象中的反射： 通过字符串的形式操作对象相关的属性。python中的一切事物都是对象（都可以使用反射） 四个可以实现自省的函数 下列方法适用于类和对象（一切皆对象，类本身也是一个对象） hasattr(object, name) 判断一个对象里面是否有 name 属性或者 name 方法，返回 BOOL值，有name特性返回True， 否则返回False。 需要注意的是name要用括号括起来 >>> class test(): ... name=\"xiaohua\" ... def run(self): ... return \"HelloWord\" ... >>> t=test() >>> hasattr(t, \"name\") #判断对象有name属性 True >>> hasattr(t, \"run\") #判断对象有run方法 True >>> getattr(object, name[,default]) 获取对象object的属性或者方法，如果存在打印出来，如果不存在，打印出默认值，默认值可选。 需要注意的是，如果是返回的对象的方法，返回的是方法的内存地址，如果需要运行这个方法，可以在后面添加一对括号。 >>> class test(): ... name=\"xiaohua\" ... def run(self): ... return \"HelloWord\" ... >>> t=test() >>> getattr(t, \"name\") #获取name属性，存在就打印出来。 'xiaohua' >>> getattr(t, \"run\") #获取run方法，存在就打印出方法的内存地址。 > >>> getattr(t, \"run\")() #获取run方法，后面加括号可以将这个方法运行。 'HelloWord' >>> getattr(t, \"age\") #获取一个不存在的属性。 Traceback (most recent call last): File \"\", line 1, in AttributeError: test instance has no attribute 'age' >>> getattr(t, \"age\",\"18\") #若属性不存在，返回一个默认值。 '18' >>> setattr(object, name, values) 给对象的属性赋值，若属性不存在，先创建再赋值。 >>> class test(): ... name=\"xiaohua\" ... def run(self): ... return \"HelloWord\" ... >>> t=test() >>> hasattr(t, \"age\") #判断属性是否存在 False >>> setattr(t, \"age\", \"18\") #为属相赋值，并没有返回值 >>> hasattr(t, \"age\") #属性存在了 True >>> 一种综合的用法是：判断一个对象的属性是否存在，若不存在就添加该属性。 >>> class test(): ... name=\"xiaohua\" ... def run(self): ... return \"HelloWord\" ... >>> t=test() >>> getattr(t, \"age\") #age属性不存在 Traceback (most recent call last): File \"\", line 1, in AttributeError: test instance has no attribute 'age' >>> getattr(t, \"age\", setattr(t, \"age\", \"18\")) #age属性不存在时，设置该属性 '18' >>> getattr(t, \"age\") #可检测设置成功 '18' >>> delattr（object，name ） 这是一个相对的setattr()。 参数是一个对象和一个字符串。该字符串必须是对象属性之一的名称。该函数删除指定的属性，只要该对象允许。例如，delattr(x, ‘foobar’)相当于del x.foobar。 In [12]: delattr(y, 'foobar') In [13]: y.foobar --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) in () ----> 1 y.foobar AttributeError: 'Y' object has no attribute 'foobar' # **`类也是对象`** ```python class Foo(object): staticField = \"old boy\" def __init__(self): self.name = 'wupeiqi' def func(self): return 'func' @staticmethod def bar(): return 'bar' print(getattr(Foo, 'staticField')) print(getattr(Foo, 'func')) print(getattr(Foo, 'bar')) 输出： old boy 使用 导入其他模块，利用反射查找该模块是否存在某个方法 #!/usr/bin/env python # -*- coding:utf-8 -*- def test(): print('from the test') #!/usr/bin/env python # -*- coding:utf-8 -*- \"\"\" 程序目录： module_test.py index.py 当前文件： index.py \"\"\" import module_test as obj #obj.test() print(hasattr(obj,'test')) getattr(obj,'test')() 为什么用反射的好处 好处一：实现可插拔机制 有俩程序员，一个lili，一个是egon，lili在写程序的时候需要用到egon所写的类，但是egon去跟女朋友度蜜月去了，还没有完成他写的类，lili想到了反射，使用了反射机制lili可以继续完成自己的代码，等egon度蜜月回来后再继续完成类的定义并且去实现lili想要的功能。 总之反射的好处就是，可以事先定义好接口，接口只有在被完成后才会真正执行，这实现了即插即用，这其实是一种‘后期绑定’，什么意思？即你可以事先把主要的逻辑写好（只定义接口），然后后期再去实现接口的功能 class FtpClient: 'ftp客户端,但是还么有实现具体的功能' def __init__(self,addr): print('正在连接服务器[%s]' %addr) self.addr=addr python #from module import FtpClient f1=FtpClient('192.168.1.1') if hasattr(f1,'get'): func_get=getattr(f1,'get') func_get() else: print('---->不存在此方法') print('处理其他的逻辑') Update time： 2020-05-25 "},"面向对象/slots.html":{"url":"面向对象/slots.html","title":"python slots","keywords":"","body":"python slots ﻿## __slots__ __slots__:是一个类变量,变量值可以是列表,元祖,或者可迭代对象,也可以是一个字符串(意味着所有实例只有一个数据属性) 引子: 使用点来访问属性本质就是在访问类或者对象的__dict__属性字典(类的字典是共享的,而每个实例的是独立的) 为何使用__slots__: 字典会占用大量内存, ==如果你有一个属性很少的类,但是有很多实例,为了节省内存可以使用__slots__取代实例的__dict__== 当你定义__slots__后, __slots__就会为实例使用一种更加紧凑的内部表示。实例通过一个很小的固定大小的数组来构建, 而不是为每个实例定义一个字典, 这跟元组或列表很类似。在__slots__中列出的属性名在内部被映射到这个数组的指定小标上。使用__slots__一个不好的地方就是我们不能再给实例添加新的属性了,只能使用在__slots__中定义的那些属性名。 注意事项: __slots__ 的很多特性都依赖于普通的基于字典的实现。另外,定义了__slots__后的类不再 支持一些普通类特性了,比如多继承。大多数情况下,你应该只在那些经常被使用到 的用作数据结构的类上定义__slots__ 比如在程序中需要创建某个类的几百万个实例对象 。 关于__slots__的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。尽管使用__slots__可以达到这样的目的,但是这个并不是它的初衷。更多的是用来作为一个内存优化工具。 slots定义后 对象不再具有__dict__字典属性 class Foo: __slots__='x' #只定义一个 f1=Foo() f1.x=1 f1.y=2 #报错 实际的过程 --->setattr-->f1.__dic__['y']=2 print(f1.__slots__) #f1不再有__dict__ class Bar: __slots__=['x','y'] n=Bar() n.x,n.y=1,2 n.z=3#报错 class Foo: __slots__=['name','age'] #{'name':None,'age':None} f1=Foo() f1.name='alex' f1.age=18 print(f1.__slots__) #输出：['name', 'age'] print(f1.__dict__) #输出： # print(f1.__dict__) #AttributeError: 'Foo' object has no attribute '__dict__' # slots定义后 对象不再具有字典属性 f2=Foo() f2.name='egon' f2.age=19 print(f2.__slots__) print(Foo.__dict__) #f1与f2都没有属性字典__dict__了,统一归__slots__管,节省内存 #打印： {'__module__': '__main__', '__slots__': ['name', 'age'], 'age': , 'name': , '__doc__': None} slots使用 为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性： 比如，只允许对Student实例添加name和age属性。 class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称 s = Student() # 创建新的实例 s.name = 'Michael' # 绑定属性'name' s.age = 25 # 绑定属性'age' s.score = 99 # 绑定属性'score' 会报错 AttributeError: 'Student' object has no attribute 'score' Python 是动态语言，允许我们动态的增加属性和方法 class Student(object): pass s = Student() s.name = \"LiLei\" print(s.name) >>> LiLei 同样也有办法限制属性的动态绑定 class Teacher(object): # 用tuple定义允许绑定的属性名称，但是此限制对子类不起作用 __slots__ = ('name', 'age') 如上所示可以规定 class Teacher 只可以绑定 name 和 age 两个属性 t = Teacher() # 此处不能再添加属性 t.height = 1 >>> AttributeError: 'Teacher' object has no attribute 'height' Update time： 2020-05-25 "},"面向对象/属性property.html":{"url":"面向对象/属性property.html","title":"python 属性property","keywords":"","body":"python 属性property ﻿## property python的@property是python的一种装饰器，是用来修饰方法的。 在我们定义数据库字段类的时候,往往需要对其中的类属性做一些限制,一般用 get 和 set 方法来写, 那在 python 中,我们该怎么做能够少写代码,又能优雅的实现想要的限制,减少错误的发生呢,这时候就需要我们的@property property属性的定义和调用要注意一下几点： 定义时，在实例方法上添加 @property装饰器；并且仅有一个self参数 调用时，无需括号 一个静态属性property本质就是实现了get，set，delete三种方法 由于python进行属性的定义时，没办法设置私有属性，因此要通过@property的方法来进行设置。这样可以隐藏属性名，让用户进行使用的时候无法随意修改。 什么是property属性 一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法 class Foo: def func(self): pass # 定义property属性 @property def prop(self): pass # ############### 调用 ############### foo_obj = Foo() foo_obj.func() # 调用实例方法 foo_obj.prop # 调用property属性 class Goods(object): @property def size(self): return 100 g = Goods() print(g.size) property属性的定义和调用要注意一下几点： 定义时，在实例方法的基础上添加 @property 装饰器；并且仅有一个self参数 调用时，无需括号 对于京东商城中显示电脑主机的列表页面，每次请求不可能把数据库中的所有内容都显示到页面上，而是通过分页的功能局部显示，所以在向数据库中请求数据时就要显示的指定获取从第m条到第n条的所有数据 这个分页的功能包括： 根据用户请求的当前页和总数据条数计算出 m 和 n 根据m 和 n 去数据库中请求数据 # ############### 定义 ############### class Pager: def __init__(self, current_page): # 用户当前请求的页码（第一页、第二页...） self.current_page = current_page # 每页默认显示10条数据 self.per_items = 10 @property def start(self): val = (self.current_page - 1) * self.per_items return val @property def end(self): val = self.current_page * self.per_items return val # ############### 调用 ############### p = Pager(1) p.start # 就是起始值，即：m p.end # 就是结束值，即：n 从上述可见： Python的property属性的功能是：property属性内部进行一系列的逻辑计算，最终将计算结果返回。 property属性的有两种方式 装饰器 即：在方法上应用装饰器 类属性 即：在类中定义值为property对象的类属性 新式类，具有三种@property装饰器： #coding=utf-8 # ############### 定义 ############### class Goods: \"\"\"python3中默认继承object类 以python2、3执行此程序的结果不同，因为只有在python3中才有@xxx.setter @xxx.deleter \"\"\" @property def price(self): print('@property') @price.setter def price(self, value): print('@price.setter') @price.deleter def price(self): print('@price.deleter') # ############### 调用 ############### obj = Goods() obj.price # 自动执行 @property 修饰的 price 方法，并获取方法的返回值 obj.price = 123 # 自动执行 @price.setter 修饰的 price 方法，并将 123 赋值给方法的参数 del obj.price # 自动执行 @price.deleter 修饰的 price 方法 新式类中的属性有三种访问方式，并分别对应了三个被@property、@方法名.setter、@方法名.deleter 修饰的方法 被 @property 装饰的方法是获取属性值的方法，被装饰方法的名字会被用做 属性名。 被 @属性名.setter 装饰的方法是设置属性值的方法。 被 @属性名.deleter 装饰的方法是删除属性值的方法。 由于新式类中具有三种访问方式，我们可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除 class Goods(object): def __init__(self): # 原价 self.original_price = 100 # 折扣 self.discount = 0.8 @property def price(self): # 实际价格 = 原价 * 折扣 new_price = self.original_price * self.discount return new_price @price.setter def price(self, value): self.original_price = value @price.deleter def price(self): del self.original_price obj = Goods() obj.price # 获取商品价格 obj.price = 200 # 修改商品原价 del obj.price # 删除商品原价 使用property取代 getter 和setter 方法 class Money(object): def __init__(self): self.__money = 0 # 使用装饰器对money进行装饰，那么会自动添加一个叫money的属性，当调用获取money的值时， # 调用装饰的方法 @property def money(self): return self.__money # 使用装饰器对money进行装饰，当对money设置值时，调用装饰的方法 @money.setter def money(self, value): if isinstance(value, int): self.__money = value else: print(\"error:不是整型数字\") a = Money() a.money = 100 print(a.money) Case 1 class Goods: def __init__(self): # 原价 self.original_price = 100 # 折扣 self.discount = 0.8 @property def price(self): # 实际价格 = 原价 * 折扣 new_price = self.original_price * self.discount return new_price @price.setter def price(self, value): self.original_price = value @price.deleter def price(self): del self.original_price obj = Goods() obj.price # 获取商品价格 obj.price = 200 # 修改商品原价 print(obj.price) del obj.price # 删除商品原价 Case 2 #实现类型检测功能 #第一关： class People: def __init__(self,name): self.name=name @property def name(self): return self.name # p1=People('alex') # property自动实现了set和get方法属于数据描述符,比实例属性优先级高, # 所以你这面写会触发property内置的set,抛出异常 #第二关：修订版 class People: def __init__(self,name): self.name=name #实例化就触发property @property def name(self): # return self.name #无限递归 print('get------>') return self.DouNiWan @name.setter def name(self,value): print('set------>') self.DouNiWan=value @name.deleter def name(self): print('delete------>') del self.DouNiWan p1=People('alex') #self.name实际是存放到self.DouNiWan里 #set------> print(p1.name) #get------> #alex print(p1.name) #get------> #alex print(p1.__dict__) #{'DouNiWan': 'alex'} p1.name='egon' print(p1.__dict__) del p1.name #set------> print(p1.__dict__) #{'DouNiWan': 'egon'} #第三关:加上类型检查 class People: def __init__(self,name): self.name=name #实例化就触发property @property def name(self): # return self.name #无限递归 print('get------>') return self.DouNiWan @name.setter def name(self,value): print('set------>') if not isinstance(value,str): raise TypeError('必须是字符串类型') self.DouNiWan=value @name.deleter def name(self): print('delete------>') del self.DouNiWan p1=People('alex') #self.name实际是存放到self.DouNiWan里 p1.name=1 class People(object): ''' 给name属性赋值，值必须是字符串，否则抛出异常 给age属性赋值，值必须是整数，否则抛出异常 ''' def __init__(self,name,age): #执行@name.setter装饰的name函数，在函数中给_name属性赋值 self.name = name self.age = age #获取name的属性值 @property def name(self): #返回属性值时，也可以添加一些额外的功能 a = self._name #把姓氏换成* a = a.replace(a[0],'*') #返回name属性值 return a #设置name属性的值 @name.setter def name(self,value): #在赋值之前添加判断 if not isinstance(value,str): # 抛出异常 raise TypeError('People object.name,name must be a str!') #设置name的属性值 self._name = value #还可以继续添加其他功能 # 删除name属性 @name.deleter def name(self): #添加一些额外的功能 if not hasattr(self,'_name'): raise AttributeError('People object has no attribute \"_name\"') #删除_name属性 del self._name #获取age属性的值 @property def age(self): if self._age >=100: print('老妖精') elif 50 Update time： 2020-05-25 "},"面向对象/attrs 和 cattrs 实现面向对象编程.html":{"url":"面向对象/attrs 和 cattrs 实现面向对象编程.html","title":"python attrs 和 cattrs 实现面向对象编程","keywords":"","body":"python attrs 和 cattrs 实现面向对象编程 ﻿Python 是支持面向对象的，很多情况下使用面向对象编程会使得代码更加容易扩展，并且可维护性更高，但是如果你写的多了或者某一对象非常复杂了，其中的一些写法会相当相当繁琐，而且我们会经常碰到对象和 JSON 序列化及反序列化的问题，原生的 Python 转起来还是很费劲的。 首先让我们定义一个对象吧，比如颜色。我们常用 RGB 三个原色来表示颜色，R、G、B 分别代表红、绿、蓝三个颜色的数值，范围是 0-255，也就是每个原色有 256 个取值。如 RGB(0, 0, 0) 就代表黑色，RGB(255, 255, 255) 就代表白色，RGB(255, 0, 0) 就代表红色，如果不太明白可以具体看看 RGB 颜色的定义哈。 好，那么我们现在如果想定义一个颜色对象，那么正常的写法就是这样了，创建这个对象的时候需要三个参数，就是 R、G、B 三个数值，定义如下： class Color(object): \"\"\" Color Object of RGB \"\"\" def __init__(self, r, g, b): self.r = r self.g = g self.b = b 其实对象一般就是这么定义的，初始化方法里面传入各个参数，然后定义全局变量并赋值这些值。其实挺多常用语言比如 Java、PHP 里面都是这么定义的。但其实这种写法是比较冗余的，比如 r、g、b 这三个变量一写就写了三遍。 好，那么我们初始化一下这个对象，然后打印输出下，看看什么结果： color = Color(255, 255, 255) print(color) 结果是什么样的呢？或许我们也就能看懂一个 Color 吧，别的都没有什么有效信息，像这样子： 我们知道，在 Python 里面想要定义某个对象本身的打印输出结果的时候，需要实现它的__repr__方法，所以我们比如我们添加这么一个方法： def __repr__(self): return f'{self.__class__.__name__}(r={self.r}, g={self.g}, b={self.b})' 这里使用了 Python 中的fstring 来实现了 __repr__方法，在这里我们构造了一个字符串并返回，字符串中包含了这个 Color 类中的 r、g、b 属性，这个返回的结果就是 print 的打印结果，我们再重新执行一下，结果就变成这样子了： Color(r=255, g=255, b=255) 再继续，如果我们要想实现这个对象里面的__eq__、__lt__等各种方法来实现对象之间的比较呢？照样需要继续定义成类似这样子的形式： def __lt__(self, other): if not isinstance(other, self.__class__): return NotImplemented return (self.r, self.g, self.b) 这里是 __lt__方法，有了这个方法就可以使用比较符来对两个 Color 对象进行比较了，但这里又把这几个属性写了两遍。 最后再考虑考虑，如果我要把 JSON 转成 Color 对象，难道我要读完 JSON 然后一个个属性赋值吗？如果我想把 Color 对象转化为 JSON，又得把这几个属性写几遍呢？ attrs 这个库，其官方的介绍如下： attrs 是这样的一个 Python 工具包，它能将你从繁综复杂的实现上解脱出来，享受编写 Python 类的快乐。它的目标就是在不减慢你编程速度的前提下，帮助你来编写简洁而又正确的代码。 其实意思就是用了它，定义和实现 Python 类变得更加简洁和高效。 基本用法 首先明确一点，我们现在是装了 attrs和 cattrs 这两个库，但是实际导入的时候是使用 attr 和 cattr 这两个包，是不带 s 的。 在attr这个库里面有两个比较常用的组件叫做attrs 和 attrib，前者是主要用来修饰一个自定义类的，后者是定义类里面的一个字段的。有了它们，我们就可以将上文中的定义改写成下面的样子： from attr import attrs, attrib @attrs class Color(object): r = attrib(type=int, default=0) g = attrib(type=int, default=0) b = attrib(type=int, default=0) if __name__ == \"__main__\": color = Color(255, 255, 255) print(color) 首先我们导入了刚才所说的两个组件，然后用 attrs里面修饰了 Color 这个自定义类，然后用attrib来定义一个个属性，同时可以指定属性的类型和默认值。最后打印输出，结果如下： # Color(r=255, g=255, b=255) 观察一下有什么变化，是不是变得更简洁了？r、g、b 三个属性都只写了一次，同时还指定了各个字段的类型和默认值，另外也不需要再定义__init__方法和 __repr__方法了，一切都显得那么简洁。 实际上，主要是 attrs 这个修饰符起了作用，然后根据定义的 attrib 属性自动帮我们实现了__init__、__repr__、__eq__、__ne__、__lt__、__le__、__gt__、__ge__、__hash__这几个方法。 如使用 attrs 修饰的类定义是这样子： from attr import attrs, attrib @attrs class SmartClass(object): a = attrib() b = attrib() 其实就相当于已经实现了这些方法： class RoughClass(object): def __init__(self, a, b): self.a = a self.b = b def __repr__(self): return \"RoughClass(a={}, b={})\".format(self.a, self.b) def __eq__(self, other): if other.__class__ is self.__class__: return (self.a, self.b) == (other.a, other.b) else: return NotImplemented def __ne__(self, other): result = self.__eq__(other) if result is NotImplemented: return NotImplemented else: return not result def __lt__(self, other): if other.__class__ is self.__class__: return (self.a, self.b) (other.a, other.b) else: return NotImplemented def __ge__(self, other): if other.__class__ is self.__class__: return (self.a, self.b) >= (other.a, other.b) else: return NotImplemented def __hash__(self): return hash((self.__class__, self.a, self.b)) 别名使用 感觉里面的定义好乱啊，库名叫做 attrs，包名叫做 attr，然后又导入了 attrs 和 attrib，这太奇怪了。 首先库的名字就叫做 attrs，这个就是装 Python 包的时候这么装就行了。但是库的名字和导入的包的名字确实是不一样的，我们用的时候就导入 attr 这个包就行了，里面包含了各种各样的模块和组件，这是完全固定的。 好，然后接下来看看 attr 包里面包含了什么，刚才我们引入了attrs和 attrib。 首先是 `attrs`，它主要是用来修饰 class 类的，而 `attrib `主要是用来做属性定义的，这个就记住它们两个的用法就好了。 翻了一下源代码，发现其实它还有一些别名： s = attributes = attrs ib = attr = attrib 也就是说，attrs可以用 s或 attributes来代替，attrib 可以用 attr或 ib来代替。 from attr import s, ib @s class Color(object): r = ib(type=int, default=0) g = ib(type=int, default=0) b = ib(type=int, default=0) if __name__ == '__main__': color = Color(255, 255, 255) print(color) 所以总结一下： 库名：attrs 导入包名：attr 修饰类：s 或 attributes 或 attrs 定义属性：ib或attr 或 attrib 声明和比较 在这里我们再声明一个简单一点的数据结构，比如叫做 Point，包含 x、y 的坐标，定义如下： @attrs class Point(object): x = attrib() y = attrib() 其中 attrib里面什么参数都没有，如果我们要使用的话，参数可以顺次指定，也可以根据名字指定，如： p1 = Point(1, 2) print(p1) # Point(x=1, y=2) p2 = Point(x=3, y=4) print(p2) # Point(x=3, y=4) 重载运算符 OK，接下来让我们再验证下类之间的比较方法，由于使用了 attrs，相当于我们定义的类已经有了` __eq__`、`__ne__`、`__lt__`、`__le__`、`__gt__`、`__ge__` 这几个方法，所以我们可以直接使用比较符来对类和类之间进行比较，下面我们用实例来感受一下： ```python print('Equal:', Point(1, 2) == Point(1, 2)) # Equal: True print('Not Equal(ne):', Point(1, 2) != Point(3, 4)) # Not Equal(ne): True print('Less Than(lt):', Point(1, 2) Point(3, 2), Point(4, 2) > Point(3, 1)) # Greater Than(gt): True True print('Greater or Equal(ge):', Point(4, 2) >= Point(4, 1)) # Greater or Equal(ge): True ``` ## 属性定义 现在看来，对于这个类的定义莫过于每个属性的定义了，也就是 attrib 的定义。对于` attrib `的定义，我们可以传入各种参数，**不同的参数对于这个类的定义有非常大的影响。** 每个属性的具体参数和用法 首先让我们概览一下总共可能有多少可以控制一个属性的参数，我们用 `attrs `里面的`fields `方法可以查看一下： ```python from attr import attrs, attrib, fields @attrs class Point(object): x = attrib() y = attrib() print(fields(Point)) ``` 这就可以输出 Point 的所有属性和对应的参数，结果如下： ```python (Attribute(name='x', default=NOTHING, validator=None, repr=True, cmp=True, hash=None, init=True, metadata=mappingproxy({}), type=None, converter=None, kw_only=False), Attribute(name='y', default=NOTHING, validator=None, repr=True, cmp=True, hash=None, init=True, metadata=mappingproxy({}), type=None, converter=None, kw_only=False) ) ``` 输出出来了，可以看到结果是一个元组，元组每一个元素都其实是一个 `Attribute `对象，包含了各个参数，下面详细解释下几个参数的含义： - `name`：属性的名字，是一个字符串类型。 - `default`：属性的默认值，如果没有传入初始化数据，那么就会使用默认值。如果没有默认值定义，那么就是 NOTHING，即没有默认值。 - `validator`：验证器，检查传入的参数是否合法。 - `init`：是否参与初始化，如果为 False，那么这个参数不能当做类的初始化参数，默认是 True。 - `metadata`：元数据，只读性的附加数据。 - `type`：类型，比如 int、str 等各种类型，默认为 None。 - `converter`：转换器，进行一些值的处理和转换器，增加容错性。 - `kw_only`：是否为强制关键字参数，默认为 False。 ### 属性名 对于属性名，非常清楚了，我们定义什么属性，属性名就是什么，例如上面的例子，定义了： x = attrib() 那么其属性名就是 x。 默认值 对于默认值，如果在初始化的时候没有指定，那么就会默认使用默认值进行初始化，我们看下面的一个实例： from attr import attrs, attrib, fields @attrs class Point(object): x = attrib() y = attrib(default=100) if __name__ == '__main__': print(Point(x=1, y=3)) print(Point(x=1)) 在这里我们将 y 属性的默认值设置为了 100，在初始化的时候，第一次都传入了 x、y 两个参数，第二次只传入了 x 这个参数，看下运行结果： Point(x=1, y=3) Point(x=1, y=100) 可以看到结果，当设置了默认参数的属性没有被传入值时，他就会使用设置的默认值进行初始化。 那假如没有设置默认值但是也没有初始化呢？比如执行下： Point() 那么就会报错了 初始化 如果一个类的某些属性不想参与初始化，比如想直接设置一个初始值，一直固定不变，我们可以将属性的 init 参数设置为 False，看一个实例： from attr import attrs, attrib @attrs class Point(object): x = attrib(init=False, default=10) y = attrib() if __name__ == '__main__': print(Point(3)) 比如 x 我们只想在初始化的时候设置固定值，不想初始化的时候被改变和设定，我们将其设置了 init 参数为 False，同时设置了一个默认值，如果不设置默认值，默认为 NOTHING。然后初始化的时候我们只传入了一个值，其实也就是为 y 这个属性赋值。 Point(x=10, y=3) 没什么问题，y 被赋值为了我们设置的值 3。 那假如我们非要设置 x 呢？会发生什么，比如改写成这样子： Point(1, 2) 报错了， 强制关键字 强制关键字是 Python 里面的一个特性，在传入的时候必须使用关键字的名字来传入，如果不太理解可以再了解下 Python 的基础。 设置了强制关键字参数的属性必须要放在后面，其后面不能再有非强制关键字参数的属性，否则会报这样的错误： ValueError: Non keyword-only attributes are not allowed after a keyword-only attribute (unless they are init=False) 将最后一个属性设置kw_only 参数为True： from attr import attrs, attrib, fields @attrs class Point(object): x = attrib(default=0) y = attrib(kw_only=True) if __name__ == '__main__': print(Point(1, y=3)) 如果设置了 kw_only 参数为 True，那么在初始化的时候必须传入关键字的名字，这里就必须指定 y 这个名字，运行结果如下： Point(x=1, y=3) 如果没有指定 y 这个名字，像这样调用： Point(1, 3) 那么就会报错 注意，如果我们将一个属性设置了init 为False，那么kw_only这个参数会被忽略。 验证器 有时候在设置一个属性的时候必须要满足某个条件，比如性别必须要是男或者女，否则就不合法。对于这种情况，我们就需要有条件来控制某些属性不能为非法值。 from attr import attrs, attrib def is_valid_gender(instance, attribute, value): if value not in ['male', 'female']: raise ValueError(f'gender {value} is not valid') @attrs class Person(object): name = attrib() gender = attrib(validator=is_valid_gender) if __name__ == '__main__': print(Person(name='Mike', gender='male')) print(Person(name='Mike', gender='mlae')) 在这里我们定义了一个验证器 Validator 方法，叫做 is_valid_gender。 然后定义了一个类 Person 还有它的两个属性 name 和 gender，其中 gender 定义的时候传入了一个参数validator，其值就是我们定义的 Validator 方法。 这个Validator定义的时候有几个固定的参数： instance：类对象 attribute：属性名 value：属性值 这是三个参数是固定的，在类初始化的时候，其内部会将这三个参数传递给这个 Validator，因此 Validator 里面就可以接受到这三个值，然后进行判断即可。在 Validator 里面，我们判断如果不是男性或女性，那么就直接抛出错误。 OK，结果显而易见了，第二个报错了，因为其值不是正常的性别，所以程序直接报错终止。 注意在 Validator 里面返回 True 或 False 是没用的，错误的值还会被照常复制。所以，一定要在 Validator 里面 raise 某个错误 另外 attrs 库里面还给我们内置了好多 Validator，比如判断类型，这里我们再增加一个属性 age，必须为 int 类型： age = attrib(validator=validators.instance_of(int)) 这时候初始化的时候就必须传入 int 类型，如果为其他类型，则直接抛错： TypeError: (\"'age' must be (got 'x' that is a ). 其它的一些验证器： attr.validators.in_(options) >>> import enum >>> class State(enum.Enum): ... ON = \"on\" ... OFF = \"off\" >>> @attr.s ... class C(object): ... state = attr.ib(validator=attr.validators.in_(State)) ... val = attr.ib(validator=attr.validators.in_([1, 2, 3])) >>> C(State.ON, 1) C(state=, val=1) >>> C(\"on\", 1) Traceback (most recent call last): ... ValueError: 'state' must be in (got 'on') >>> C(State.ON, 4) Traceback (most recent call last): ... ValueError: 'val' must be in [1, 2, 3] (got 4) attr.validators.instance_of() >>> @attr.s ... class C(object): ... x = attr.ib(validator=attr.validators.instance_of(int)) >>> C(42) C(x=42) >>> C(\"42\") Traceback (most recent call last): ... TypeError: (\"'x' must be (got '42' that is a ).\", Attribute(name='x', default=NOTHING, validator=>, type=None, kw_only=False), , '42') >>> C(None) Traceback (most recent call last): ... TypeError: (\"'x' must be (got None that is a ).\", Attribute(name='x', default=NOTHING, validator=>, repr=True, cmp=True, hash=None, init=True, type=None, kw_only=False), , None) 更多验证器，参考官方文档 转换器 其实很多时候我们会不小心传入一些形式不太标准的结果，比如本来是 int 类型的 100，我们传入了字符串类型的 100，那这时候直接抛错应该不好吧，所以我们可以设置一些转换器来增强容错机制，比如将字符串自动转为数字等等，看一个实例： from attr import attrs, attrib def to_int(value): try: return int(value) except: return None @attrs class Point(object): x = attrib(converter=to_int) y = attrib() if __name__ == '__main__': print(Point('100', 3)) 看这里，我们定义了一个方法，可以将值转化为数字类型，如果不能转，那么就返回 None，这样保证了任何可以被转数字的值都被转为数字，否则就留空，容错性非常高。 运行结果如下 Point(x=100, y=3) 类型 为什么把这个放到最后来讲呢，因为 Python 中的类型是非常复杂的，有原生类型，有 typing 类型，有自定义类的类型。 首先我们来看看原生类型是怎样的，这个很容易理解了，就是普通的 int、float、str 等类型，其定义如下： from attr import attrs, attrib @attrs class Point(object): x = attrib(type=int) y = attrib() if __name__ == '__main__': print(Point(100, 3)) print(Point('100', 3)) 这里我们将 x 属性定义为 int 类型了，初始化的时候传入了数值型 100 和字符串型 100，结果如下： Point(x=100, y=3) Point(x='100', y=3) 但我们发现，虽然定义了，但是不会被自动转类型的。 另外我们还可以自定义 typing 里面的类型，比如 List，另外 attrs 里面也提供了类型的定义： from attr import attrs, attrib, Factory import typing @attrs class Point(object): x = attrib(type=int) y = attrib(type=typing.List[int]) z = attrib(type=Factory(list)) 这里我们引入了 typing 这个包，定义了 y 为 int 数字组成的列表，z 使用了 attrs 里面定义的 Factory 定义了同样为列表类型。 序列转换 在很多情况下，我们经常会遇到 JSON 等字符串序列和对象互相转换的需求，尤其是在写 REST API、数据库交互的时候。 attrs 库的存在让我们可以非常方便地定义 Python 类，但是它对于序列字符串的转换功能还是比较薄弱的，cattrs 这个库就是用来弥补这个缺陷的，下面我们再来看看 cattrs 库。 cattrs 导入的时候名字也不太一样，叫做 cattr，它里面提供了两个主要的方法，叫做 structure和 unstructure，两个方法是相反的，对于类的序列化和反序列化支持非常好。 基本转换 首先我们来看看基本的转换方法的用法，看一个基本的转换实例： from attr import attrib, attrs from cattr import unstructure, structure @attrs class Point(object): x = attrib(type=int, default=0) y = attrib(type=int, default=0) if __name__ == \"__main__\": point = Point(1, 2) json = unstructure(point) print('json:', json) obj = structure(json, Point) print('obj:', obj) 在这里我们定义了一个 Point 对象，然后调用 unstructure 方法即可直接转换为 JSON 字符串。如果我们再想把它转回来，那就需要调用 structure 方法，这样就成功转回了一个 Point 对象。 看下运行结果： json: {'x': 1, 'y': 2} obj: Point(x=1, y=2) 多类型转换 另外 structure 也支持一些其他的类型转换，看下实例： >>> cattr.structure(1, str) '1' >>> cattr.structure(\"1\", float) 1.0 >>> cattr.structure([1.0, 2, \"3\"], Tuple[int, int, int]) (1, 2, 3) >>> cattr.structure((1, 2, 3), MutableSequence[int]) [1, 2, 3] >>> cattr.structure((1, None, 3), List[Optional[str]]) ['1', None, '3'] >>> cattr.structure([1, 2, 3, 4], Set) {1, 2, 3, 4} >>> cattr.structure([[1, 2], [3, 4]], Set[FrozenSet[str]]) {frozenset({'4', '3'}), frozenset({'1', '2'})} >>> cattr.structure(OrderedDict([(1, 2), (3, 4)]), Dict) {1: 2, 3: 4} >>> cattr.structure([1, 2, 3], Tuple[int, str, float]) (1, '2', 3.0) 不过总的来说，大部分情况下，JSON 和对象的互转是用的最多的。 属性处理 上面的例子都是理想情况下使用的，但在实际情况下，很容易遇到 JSON 和对象不对应的情况，比如 JSON 多个字段，或者对象多个字段。 from attr import attrs, attrib from cattr import structure @attrs class Point(object): x = attrib(type=int, default=0) y = attrib(type=int, default=0) json = {'x': 1, 'y': 2, 'z': 3} print(structure(json, Point)) 在这里，JSON 多了一个字段 z，而 Point 类只有 x、y 两个字段，那么直接执行 structure 会出现什么情况呢？ TypeError: __init__() got an unexpected keyword argument 'z' Update time： 2020-05-25 "},"面向对象/Dataclasses.html":{"url":"面向对象/Dataclasses.html","title":"python Dataclasses","keywords":"","body":"python Dataclasses ﻿原文链接：https://medium.com/mindorks/understanding-python-dataclasses-part-2-660ecc11c9b8 参考：https://linux.cn/article-9974-1.html 介绍 Dataclasses 是 Python 的类（LCTT 译注：更准确的说，它是一个模块），适用于存储数据对象。你可能会问什么是数据对象？下面是定义数据对象的一个不太详细的特性列表： 它们存储数据并代表某种数据类型。例如：一个数字。对于熟悉 ORM 的人来说，模型实例就是一个数据对象。它代表一种特定的实体。它包含那些定义或表示实体的属性。 它们可以与同一类型的其他对象进行比较。例如：一个数字可以是 greater than（大于）、less than（小于） 或equal（等于） 另一个数字。 Python 3.7 提供了一个装饰器 dataclass，用于将类转换为 dataclass 你所要做的就是将类包在装饰器中： from dataclasses import dataclass @dataclass class A: ... 初始化 通常是这样： class Number: def __init__(self, val): self.val = val >>> one = Number(1) >>> one.val >>> 1 用 dataclass 是这样： @dataclass class Number: val:int >>> one = Number(1) >>> one.val >>> 1 以下是 dataclass 装饰器带来的变化： 无需定义__init__，然后将值赋给 self，dataclass 负责处理它; 们以更加易读的方式预先定义了成员属性，以及类型提示。我们现在立即能知道 val是int 类型。这无疑比一般定义类成员的方式更具可读性。 它也可以定义默认值： @dataclass class Number: val:int = 0 表示 对象表示指的是对象的一个有意义的字符串表示，它在调试时非常有用。 默认的 Python 对象表示不是很直观： class Number: def __init__(self, val = 0): self.val = val >>> a = Number(1) >>> a >>> 这让我们无法知悉对象的作用，并且会导致糟糕的调试体验。 一个有意义的表示可以通过在类中定义一个__repr__方法来实现。 def __repr__(self): return self.val 现在我们得到这个对象有意义的表示： >>> a = Number(1) >>> a >>> 1 dataclass会自动添加一个 __repr__函数，这样我们就不必手动实现它了。 @dataclass class Number: val: int = 0 >>> a = Number(1) >>> a >>> Number(val = 1) 数据比较 通常，数据对象之间需要相互比较。 两个对象 a 和 b 之间的比较通常包括以下操作： a a > b a == b a >= b a https://docs.python.org/3/reference/datamodel.html#object.__lt__ 通常这样写： class Number: def __init__( self, val = 0): self.val = val def __eq__(self, other): return self.val == other.val def __lt__(self, other): return self.val 使用dataclass： @dataclass(order = True) class Number: val: int = 0 我们不需要定义__eq__和 __lt__方法，因为当 order = True 被调用时，dataclass装饰器会自动将它们添加到我们的类定义中。 那么，它是如何做到的呢？ 当你使用 dataclass 时，它会在类定义中添加函数 eq 和 lt 。我们已经知道这点了。那么，这些函数是怎样知道如何检查相等并进行比较呢？ 生成 __eq__函数的 dataclass类会比较两个属性构成的元组，一个由自己属性构成的，另一个由同类的其他实例的属性构成。在我们的例子中，自动生成的 __eq__函数相当于： def __eq__(self, other): return (self.val,) == (other.val,) 让我们来看一个更详细的例子： 我们会编写一个dataclass 类 Person来保存 name和 age。 @dataclass(order = True) class Person: name: str age:int = 0 自动生成的__eq__方法等同于： def __eq__(self, other): return (self.name, self.age) == ( other.name, other.age) 同样，等效的__le__函数类似于： def __le__(self, other): return (self.name, self.age) 当你需要对数据对象列表进行排序时，通常会出现像__le__这样的函数的定义。Python 内置的 sorted函数依赖于比较两个对象。 >>> import random >>> a = [Number(random.randint(1,10)) for _ in range(10)] #generate list of random numbers >>> a >>> [Number(val=2), Number(val=7), Number(val=6), Number(val=5), Number(val=10), Number(val=9), Number(val=1), Number(val=10), Number(val=1), Number(val=7)] >>> sorted_a = sorted(a) #Sort Numbers in ascending order >>> [Number(val=1), Number(val=1), Number(val=2), Number(val=5), Number(val=6), Number(val=7), Number(val=7), Number(val=9), Number(val=10), Number(val=10)] >>> reverse_sorted_a = sorted(a, reverse = True) #Sort Numbers in descending order >>> reverse_sorted_a >>> [Number(val=10), Number(val=10), Number(val=9), Number(val=7), Number(val=7), Number(val=6), Number(val=5), Number(val=2), Number(val=1), Number(val=1)] dataclass作为一个可调用的装饰器 定义所有的dunder（LCTT 译注：这是指双下划线方法，即魔法方法）方法并不总是值得的。你的用例可能只包括存储值和检查相等性。因此，你只需定义 __init__ 和 __eq__方法。如果我们可以告诉装饰器不生成其他方法，那么它会减少一些开销，并且我们将在数据对象上有正确的操作。 幸运的是，这可以通过将 dataclass装饰器作为可调用对象来实现。 从官方文档来看，装饰器可以用作具有如下参数的可调用对象： @dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False) class C: … init：默认将生成 __init__方法。如果传入 False，那么该类将不会有 __init__方法。 repr：__repr__方法默认生成。如果传入 False，那么该类将不会有 __repr__方法。 eq：默认将生成__eq__方法。如果传入 False，那么__eq__方法将不会被 dataclass 添加，但默认为 object.eq。 order：默认将生成__gt__、__ge__、__lt__、__le__方法。如果传入 False，则省略它们。 Frozen（不可变） 实例 Frozen 实例是在初始化对象后无法修改其属性的对象。 以下是我们期望不可变对象能够做到的： >>> a = Number(10) #Assuming Number class is immutable >>> a.val = 10 # Raises Error 有了 dataclass，就可以通过使用 dataclass 装饰器作为可调用对象配合参数 frozen=True 来定义一个 frozen 对象。 当实例化一个 frozen对象时，任何企图修改对象属性的行为都会引发 FrozenInstanceError。 @dataclass(frozen = True) class Number: val: int = 0 >>> a = Number(1) >>> a.val >>> 1 >>> a.val = 2 >>> Traceback (most recent call last): File “”, line 1, in File “”, line 3, in __setattr__ dataclasses.FrozenInstanceError: cannot assign to field ‘val’ 因此，一个frozen 实例是一种很好方式来存储： 常数 设置 这些通常不会在应用程序的生命周期内发生变化，任何企图修改它们的行为都应该被禁止。 后期初始化处理 有了 dataclass，需要定义一个 __init__方法来将变量赋给 self这种初始化操作已经得到了处理。但是我们失去了在变量被赋值之后立即需要的函数调用或处理的灵活性。 让我们来讨论一个用例，在这个用例中，我们定义一个 Float 类来包含浮点数，然后在初始化之后立即计算整数和小数部分。 在这里插入代码片 import math class Float: def __init__(self, val = 0): self.val = val self.process() def process(self): self.decimal, self.integer = math.modf(self.val) >>> a = Float( 2.2) >>> a.decimal >>> 0.2000 >>> a.integer >>> 2.0 幸运的是，使用 __post_init__ 方法已经能够处理后期初始化操作。 生成的 __init__ 方法在返回之前调用 __post_init__返回。因此，可以在函数中进行任何处理。 import math @dataclass class FloatNumber: val: float = 0.0 def __post_init__(self): self.decimal, self.integer = math.modf(self.val) >>> a = FloatNumber(2.2) >>> a.val >>> 2.2 >>> a.integer >>> 2.0 >>> a.decimal >>> 0.2 继承 Dataclasses 支持继承，就像普通的 Python 类一样。 因此，父类中定义的属性将在子类中可用。 @dataclass class Person: age: int = 0 name: str @dataclass class Student(Person): grade: int >>> s = Student(20, \"John Doe\", 12) >>> s.age >>> 20 >>> s.name >>> \"John Doe\" >>> s.grade >>> 12 请注意，Student的参数是在类中定义的字段的顺序。 继承过程中 __post_init__的行为是怎样的？ 由于__post_init__只是另一个函数，因此必须以传统方式调用它： @dataclass class A: a: int def __post_init__(self): print(\"A\") @dataclass class B(A): b: int def __post_init__(self): print(\"B\") >>> a = B(1,2) >>> B 在上面的例子中，只有 B 的 __post_init__被调用，那么我们如何调用 A 的 __post_init__ 呢？ @dataclass class B(A): b: int def __post_init__(self): super().__post_init__() # 调用 A 的 post init print(\"B\") >>> a = B(1,2) >>> A B Dataclass fields 我们已经知道 Dataclasses 会生成他们自身的__init__方法。它同时把初始化的值赋给这些字段。在上一面定义的内容： • 变量名 • 数据类型 这些内容仅给我们有限的 dataclass 字段使用范围。让我们讨论一下这些局限性，以及它们如何通过 dataclass.field 被解决。 复合初始化 考虑以下情形：你想要初始化一个变量为列表。你如何实现它呢?一种简单的方式是使用__post_init__方法。 import random from typing import List def get_random_marks(): return [random.randint(1,10) for _ in range(5)] @dataclass class Student: marks: List[int] def __post_init__(self): self.marks = get_random_marks() #Assign random speeds >>> a = Student() >>> a.marks >>> [1,4,2,6,9] 数据类 Student 产生了一个名为 marks 的列表。我们不传递 marks 的值，而是使用__post_init__方法初始化。这是我们定义的单一属性。此外，我们必须在__post_init__里调用 get_random_marks 函数。这些工作是额外的。 辛运的是，Python 为我们提供了一个解决方案。我们可以使用 dataclasses.field来定制化 dataclass 字段的行为以及它们在 dataclass 的影响。 仍然是上述的使用情形，让我们从__post_init__里去除get_random_marks的调用。以下是使用dataclasses.field的情形： from dataclasses import field @dataclass class Student: marks: List[int] = field(default_factory = get_random_marks) >>> s = Student() >>> s.marks >>> [1,4,2,6,9] dataclasses.field接受了一个名为 default_factory的参数，它的作用是：如果在创建对象时没有赋值，则使用该方法初始化该字段。 default_factory必须是一个可以调用的无参数方法(通常为一个函数)。 这样我们就可以使用复合形式初始化字段。现在，让我们考虑另一个使用场景。 dataclass 能够自动生成, =, >, 和>=这些比较方法。但是这些比较方法的一个缺陷是，它们使用类中的所有字段进行比较，而这种情况往往不常见。更经常地，这种比较方法会给我们使用 dataclasses 造成麻烦。 考虑以下的使用情形：你有一个数据类用于存放用户的信息。现在，它可能存在以下字段： • 姓名 • 年龄 • 身高 • 体重 你仅想比较用户对象的年龄、身高和体重。你不想比较姓名。这是后端开发者经常会遇到的使用情景。 @dataclass(order = True) class User: name: str age: int height: float weight: float 自动生成的比较方法会比较一下的元组： (self.name, self.age, self.height, self.weight) 这将会破坏我们的意图。我们不想让姓名(name)用于比较。那么，如何使用 dataclasses.field 来实现我们的想法呢? @dataclass(order = True) class User: name:str = field(compare = False) # compare = False tells the dataclass to not use name for comparison methods age: int weight: float height: float >>> user_1 = User(\"John Doe\", 23, 70, 1.70) >>> user_2 = User(\"Adam\", 24, 65, 1.60) >>> user_1 >> True 默认情况下，所用的字段都用于比较，因此我们仅仅需要指定哪些字段用于比较，而实现方法是直接把不需要的字段定义为filed(compare=False)。 一个更为简单的应用情形也可以被讨论。让我们定义一个数据类，它被用来存储一个数字激起字符串表示。我们想让比较仅仅发生在该数字的值，而不是他的字符串表示。 @dataclass(order = True) class Number: string: str val: int >>> a = Number(\"one\",1) >>> b = Number(\"eight\", 8) >>> b > a # Compares as (\"eight\",8) > (\"one\",1) >>> False #Now we shall only compare using the Number.val @dataclass(order = True) class Number: string: str: = field(compare = False) #Do not use Number.string for comparison val: int >>> a = Number(\"one\", 1) >>> b = Number(\"eight\", 8) >>> b > a # Compares (8,) > (1,) >>> True 现在，我们有更大的自由来控制 dataclasses 的行为。 使用全部字段进行数据表示 自动生成的repr方法使用所有的字段用于表示。当然，这也不是大多数情形下的理想选择，尤其是当你的数据类有大量的字段时。单个对象的表示会变得异常臃肿，对调试来说也不利。 @dataclass(order = True) class User: name: str = field(compare = False) age: int height: float weight: float city: str = field(compare = False) country: str = field(compare = False) >>> a = User(\"John Doe\", 24, 1.7, 70, \"Massachusetts\" ,\"United States of America\") >>> a >>> User(name='John Doe', age=24, height=1.7, weight=70, city='Massachusetts', country='United States of America') #Debugging Nightmare coming through 想象一下在你的日志里看到这样的表示吧，然后还要写一个正则表达式来搜索它。 当然，我们也能够个性化这种行为。考虑一个类似的使用场景，也许最合适的用于表示的属性是姓名(name)。那么对__repr__，我们仅使用它： @dataclass(order=True) class User: name: str = field(compare=False) age: int = field(repr=False) # This tells the dataclass to not show age in the representation height:float = field(repr=False) weight:float = field(repr=False) city:str = field(repr=False, compare=False) #Do not use city for representation and comparison country:str = field(repr=False, compare=False) >>> a = User(\"John Doe\", 24, 1.7, 70, \"Massachusetts\", \"United States of America\") >>> b = User(\"Adam\", 24, 1.6, 65, \"San Jose\", \"United States of America\") >>> a >>> User(name='John Doe') >>> b >>> User(name='Adam') >>> b > a #Compares (24, 1.7, 70) > (23, 1.6, 65) >>> True 这样看起来就很棒了。调试很方便，比较也有意义! 从初始化中省略字段 目前为止我们看到的所有例子，都有一个共同特点——即我们需要为所有被声明的字段传递值，除了有默认值之外。在那种情形下(指有默认值的情况下)，我们可以选择传递值，也可以不传递。 @dataclass class Number: string: str val:int = 0 >>> a = Number(\"Zero\") #Not passing value of the field with default value >>> a >>> Number(string='Zero', val=0) >>> b = Number(\"One\",1) #Passing the default value of the field which has default declared >>> b >>> Number(string='One', val=1) 但是，还有一种情形：我们可能不想在初始化时设定某个字段的值。这也是一种常见的使用场景。也许你在追踪一个对象的状态，并且希望它在初始化时一直被设为 False。更一般地，这个值在初始化时不能够被传递。 class User: def __init__(self, email = None): self.email = email self.verified = False #This field is set during initialization, but its value cannot be set manually while creating object 那么，我们如何实现上述想法呢?以下是具体内容： @dataclass class User: email: str = field(repr = True) verified: bool = field(repr = False, init = False, default = False) #Omit verified from representation as well as __init__ >>> a = User(\"a@test.com\") >>> a >>> User(email='a@test.com') >>> a.verified >>> False >>> b = User(\"b@test.com\", True) #Let us try to pass the value of verified >>> Traceback (most recent call last): File \"\", line 1, in TypeError: __init__() takes 2 positional arguments but 3 were given Update time： 2020-05-25 "},"Chapter5/":{"url":"Chapter5/","title":"python MongoDB数据库","keywords":"","body":"python MongoDB数据库 Update time： 2020-05-25 "},"Chapter5/MongoDB基础.html":{"url":"Chapter5/MongoDB基础.html","title":"python MongoDB基础","keywords":"","body":"python MongoDB基础 ﻿MongoDB 的数据以类似于 JSON 格式的二进制文档存储： { name: \"Angeladady\", age: 18, hobbies: [\"Steam\", \"Guitar\"] } 在项目目录中，使用 mongod 命令来启动 mongoDB 进程： 创建完目录之后，直接运行mongod命令即可启动MongoDb服务器。mongod命令默认使用/data/db为 MongoDb 数据库的数据文件目录。如果需要改变数据文件存储目录，需要指定--dbpath参数，例如： mongod --dbpath /Users/yurongchan/mongodb_data_file 类似的启动配置参数还有： 连接MongoDb服务器: 服务器启动之后，我们启动一个终端连接到 MongoDb 服务器，这样我们就可以运行进行数据库CURD操作。连接MongoDb服务器命令的语法如下： mongo server_ip:port/dbname -u user -p password 这里直接连接本地服务器，因此直接运行mongo命令即可。 MongoDb创建数据库 MongoDb 创建和切换数据库的语法格式为： use database_name 如果数据库不存在，则创建数据库，否则切换到指定数据库。 > use chenyurong switched to db chenyurong > db chenyurong > show dbs admin 0.000GB local 0.000GB 上面创建了名为chenyurong的数据库，但是我们使用show dbs命令时并没有看到该数据库存在，这是因为该数据库中还没有数据。要显示它，我们需要向 chenyurong 数据库插入一些数据。 MongoDb创建表 MongoDb 中并没有直接创建表的命令，表的数据结构在你往表插入数据时确定。因此在 MongoDb 中，你创建完数据库之后就可以直接往表中插入数据，表名在插入数据时指定。 常用shell操作 db 显示当前所在数据库 show dbs 列出可用数据库 show tables or show collections 列出数据库中可用集合 use 用于切换数据库 MongoDb插入数据 MongoDB 使用 insert() 或save()方法向集合中插入文档 db.collection.inserOne() 插入单个文档 db.collection.inserMany() 插入多个文档 db.collection.insert() 插入单条或多条文档 ```python db.collection.insert() db.collection.insert( , { writeConcern: , ordered: } ) ```python _id Field If the document does not specify an _id field, then MongoDB will add the _id field and assign a unique ObjectId for the document before inserting. Most drivers create an ObjectId and insert the _id field, but the mongod will create and populate the _id if the driver or application does not. MongoDb查询数据 db.collection.find() db.collection.find(query, projection) 返回查询值的列表 query（可选）：使用查询操作符指定查询条件。该参数是一个JSON对象，key 一般为查询的列名，value 为查询匹配的值。 projection（可选）：使用投影操作符指定返回的键。如果省略该参数，那么查询时返回文档中所有键值。该参数是一个JSON对象，key 为需要显示的列名，value 为 1（显示） 或 0（不显示）。_id:默认就是1，没指定返回该字段时，默认会返回，除非设置为0是，就不会返回该字段。 第一个参数为查询条件： > db.drivers.find() #查找所有文档 { \"_id\" : ObjectId(\"598964bd56b8c69ae1e5f36a\"), \"name\" : \"Chen1fa\", \"age\" : 18 } { \"_id\" : ObjectId(\"598964d456b8c69ae1e5f36b\"), \"name\" : \"Xiaose\", \"age\" : 35 } { \"_id\" : 91, \"name\" : \"Sun1feng\", \"age\" : 34 } > db.drivers.find({name: \"Xiaose\"}) #查找 name 为 Xiaose 的文档 { \"_id\" : ObjectId(\"598964d456b8c69ae1e5f36b\"), \"name\" : \"Xiaose\", \"age\" : 35 } > db.drivers.find({age:{$gt:20}}) #查找 age 大于 20 的文档 { \"_id\" : ObjectId(\"598964d456b8c69ae1e5f36b\"), \"name\" : \"Xiaose\", \"age\" : 35 } { \"_id\" : 91, \"name\" : \"Sun1feng\", \"age\" : 34 } 上述代码中的$gt对应于大于号>的转义。 第二个参数可以传入投影 ,文档映射数据： > db.drivers.find({age:{$gt:20}},{name:1}) { \"_id\" : ObjectId(\"598964d456b8c69ae1e5f36b\"), \"name\" : \"Xiaose\" } { \"_id\" : 91, \"name\" : \"Sun1feng\" } 如果不 想显示'_id' db.drivers.find({age:{$gt:20}},{name:1,_id:0}) 投影文档中字段为 1 或真值表示包含，0 或假值表示排除，可以设置多个字段为 1 或 0，但不能混合使用。 除此之外，还可以通过 count、skip、limit 等指针（Cursor）方法，改变文档查询的执行方式： db.drivers.find().count() #统计查询文档数目 3 > db.drivers.find().skip(1).limit(10).sort({age:1}) { \"_id\" : 91, \"name\" : \"Sun1feng\", \"age\" : 34 } { \"_id\" : ObjectId(\"598964d456b8c69ae1e5f36b\"), \"name\" : \"Xiaose\", \"age\" : 35 } 上述查找命令跳过 1 个文档，限制输出 10 个，以 name 子段正序排序（大于 0 为正序，小于 0 位反序）输出结果。最后，可以使用 Cursor 方法中的pretty方法，提升查询文档的易读性，特别是在查看嵌套的文档和配置文件的时候： MongoDB Enterprise > db.test.find().pretty() { \"_id\" : ObjectId(\"5dc2791643fecd3d34021152\"), \"id\" : \"20170101\", \"name\" : \"Jordan\", \"age\" : 20, \"gender\" : \"male\" } { \"_id\" : ObjectId(\"5dc27af23b8c62878c1061e4\"), \"id\" : \"20170101\", \"name\" : \"Jordan\", \"age\" : 20, \"gender\" : \"male\" } { \"_id\" : ObjectId(\"5dc27af23b8c62878c1061e5\"), \"id\" : \"20170202\", \"name\" : \"Mike\", \"age\" : 21, \"gender\" : \"male\" } 查询第一条数据 db.collection.findOne() 范围操作符 范围操作符指的是：大于、大于等于、等于、不等于、小于、小于等于操作符，在 MongoDb 中它们的表示以及使用如下面表格所示： 例如我要查询用户表中所有年龄大于等于25岁的用户，那么查询语句为： db.user.find({\"age\": {$gte:25}},{\"_id\":0}).pretty() AND操作符 MongoDB 的 find() 方法可以传入多个键（key），每个键（key）以逗号隔开。每个键（key）之间是与的逻辑关系。 { $and: [ { }, { } , ... , ]} 例如我要查询用户表（user）中地址为ShenZhen且年龄大于等于25岁的用户，那么查询语句为： db.user.find({\"addr\": \"ShenZhen\",\"age\": {$gte:25}},{\"_id\":0}).pretty() OR操作符 MongoDB 中关键字$or表示或逻辑关系，其语法格式如下： 语法： { $nor: [ { }, { }, ... ] } db.col.find( { $or: [ {key1: value1}, {key2:value2} ] } ).pretty() 例如我要查询用户表（user）中地址为ShenZhen或者年龄大于等于30岁的用户，那么查询语句为： db.user.find({$or:[{\"addr\":\"ShenZhen\"},{\"age\":{$gte:30}}]}).pretty() AND操作符和OR操作符可以混合使用，例如要实现以下SQL查询： select * from user where name = \"ChenYuRong\" or (age 那么该 MongoDb 查询语句应该这样写： db.user.find({$or:[{\"name\":\"ChenYuRong\"}, {\"age\": {$lte:25}, \"addr\": \"JieYang\"}]}).pretty() $in（包含）、$nin（不包含）条件查询 1）$in（包含）条件查询 语法： { field: { $in: [, , ...] } } >db.orders.find({\"onumber\":{$in:[\"001\",\"002\"]}}) 查询onumber in(\"001\",\"002\") 条件的文档，就是onumber等于001或者等于002 这个跟$or有点像，不过$or做为条件查询时，可以指定不同的字段: db.orders.find({$or:[{\"onumber\":\"002\"},{\"cname\":\"zcy1\"}]}) ，而$in只针对一个字段。 2）$nin（不包含）条件查询 语法： { field: { $nin: [, , ...] } } $not(不等于) 条件查询 语法： { field: { $not: { } } } $not操作符不能独立使用，必须跟其他操作条件一起使用（除$regex） >db.orders.find({\"onumber\":{$not:{$gt:\"002\"}}}) 查找onumber不等于大于002的文档数据 $exists用来判断一个field是否存在 语法： { field: { $ exists: } } >db.orders.find({\"age\":{$exists:true}}) 没有age这个元素，什么都没返回 插入有age元素，在执行一下 对数组根据条件查询 $all、$size、$slice、$elemMatch s=[ { 'onumber':'008', 'date':'2015-07-08', 'cname':'zcy8', 'books':['java','c','mongo'] }, { 'onumber': '009', 'date': '2015-07-09', 'cname': 'zcy8', 'books': ['java', 'c'] } ] （1）$all查找数组中包含指定的值的文档 语法： { field:{ $all: [ , ... ]} db.orders.find({\"books\":{$all:[\"java\",\"mongo\"]}}) 查找books包含java、mongo的文档数据 （2）$size 查找数组大小等于指定值的文档 语法： {field: {$size: number } } >db.orders.find({\"books\":{$size:2}}) （3）$slice查询数组中指定返回元素的个数 语法： >db.collect.find({},{field:{$slice: number }}) number 说明： 为正数表示返回前面指定的值的个数：例如1 返回数组第一个 为负数表示返回倒数指定的值的个数：例如-1返回数组倒数第一个 >db.orders.find({\"onumber\":{$in:[\"008\",\"009\"]}},{books:{$slice:1}}) $slice可以查询数组中第几个到第几个 语法： >db.collect.find({},{field:{$slice:[ number1, number2] }}) 跳过数组的number1个位置然后返回number2个数 number1说明： 为正数表示跳到指定值的数组个数：例如2 跳到数组第3个 为负数表示跳到指定值的数组倒数个数：例如-2跳到到数组倒数第3个 >db.orders.find({\"onumber\":{$in:[\"008\",\"009\"]}},{books:{$slice:[1,1]}}) 对数组内嵌文档查询 db. orders.insert([ { \"onumber\" : \"001\", \"date\" : \"2015-07-02\", \"cname\" : \"zcy1\", \"items\" :[ { \"ino\" : \"001\", \"quantity\" :2, \"price\" : 4.0 },{ \"ino\" : \"002\", \"quantity\" : 4, \"price\" : 6.0 } ] },{ \"onumber\" : \"002\", \"date\" : \"2015-07-02\", \"cname\" : \"zcy2\", \"items\" :[ { \"ino\" : \"001\", \"quantity\" :2, \"price\" : 4.0 },{ \"ino\" : \"002\", \"quantity\" :6, \"price\" : 6.0 } ] } （1）$elemMatch 文档包含有一个元素是数组，那么$elemMatch可以匹配内数组内的元素并返回文档数据 语法： >{field:{$elemMatch:{ field1:value1, field2:value2,………}}} >db.orders.find({\"items\":{$elemMatch:{\"quantity\":2}}}) 返回quantity为2的文档 也可以这样查询db.orders.find({\"items.quantity\":2}) （2） $elemMatch可以带多个查询条件 >db.orders.find({\"items\":{$elemMatch:{\"quantity\":4,\"ino\":\"002\"}}}) 我们查询数组中的quantity等于4并且ino等于002，但是我们就想返回数组中的quantity等于4并且ino等于002的这个文档，并不想把ino等于001等这些无关的文档返回。 （3）$elemMatch 同样可以用在find方法的第二个参数来限制返回数组内的元素，只返回我们需要的文档 db.orders.find({\"onumber\":\"001\"}, {\"items\":{$elemMatch:{\"quantity\":4,\"ino\":\"002\"}},\"cname\":1,\"date\":1,\"onumber\":1}) 我们只返回quantity等于4并且ino等于002的文档，无关的文档没有返回，方便我们处理数据，这样也可以节省传输数据量，减少了内存消耗，提高了性能，在数据大时，性能很明显的。 游标的操作 我们还可以对文档的游标，可以随意修改返回结果的限制、跳跃、和排序顺序的功能。 limit limit方法是限制游标返回结果的数量，如下面例子： >db.items.find().limit(5) 只返回结果5条文档 sort()排序 在 MongoDB 中使用使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。 sort()方法基本语法如下所示： db.collection.find().sort({KEY:1}) 其中KEY表示要进行排序的字段。 例如我们将所有年龄小于30岁的用户查询出来并将其按照年龄升序排列： db.user.find({\"age\":{$lt:30}}).sort({age:1}).pretty() 我们可以指定多个字段排序，例如我们先按quantity字段降序，然后在按info升序,如下面的例子： ```python >db.items.find({\"ino\":{$lt:5}}).sort({\"quantity\":-1,\"info\":1}) ``` 我们查询ino小于5，并对这结果进行排序，按quantity字段降序 我们还可以跟limit()方法进行组合查询并对结果进行排序 ```python >db.items.find().limit(3).sort({\"quantity\":1}) ``` skip skip方法可以跳过指定值的条数，返回剩下的条数的结果，可以跟limit()方法进行组合可以实现分页的效果。 db.items.find().skip(10).limit(10) 跳过第10条，从第11条开始返回，只返回10条文档. skip方法是跳过条数，而且是一条一条的跳过，如果集合比较大时（如书页数很多）skip会越来越慢, 需要更多的处理器(CPU)，这会影响性能。 我们可以通过一个键值比较有顺序的来进行分页，这样就避免使用skip方法。 >db.items.find({\"ino\":{$lt:20,$gt:9}}).sort({\"info\":1}) 更新（Update) MongoDB 提供 updata 方法更新文档： db.collection.updateOne() 更新最多一个符合条件的文档 db.collection.updateMany() 更新所有符合条件的文档 db.collection.replaceOne()替代最多一个符合条件的文档 db.collection.update() 默认更新一个文档，可配置 multi 参数，跟新多个文档 update() 方法用于更新已存在的文档。语法格式如下： db.collection.update( , , { upsert: , multi: , writeConcern: } ) query：为查询条件 update：为修改的文档。 upsert（可选）：如果不存在update的记录，是否将其作为记录插入。true为插入，默认是false，不插入。 multi（可选）：是否更新多条记录。MongoDb 默认是false，只更新找到的第一条记录。如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern（可选）：表示抛出异常的级别 下面的命令将 name 字段为 Chen1fa 的文档，更新 age 字段为 30： > db.drivers.update({name:\"Chen1fa\"},{name:\"Chen1fa\", age:30}) 要注意的是，如果更新文档只传入 age 字段，那么文档会被更新为{age: 30}，而不是{name:\"Chen1fa\", age:30}。要避免文档被覆盖，需要用到$set指令，$set仅替换或添加指定字段： > db.drivers.update({name:\"Chen1fa\"},{$set:{age:30}}) 如果要在查询的文档不存在的时候插入文档，要把 upsert 参数设置真值： > db.drivers.update({name:\"Alen\"},{age:24},{upsert: true}) update 方法默认情况只更新一个文档，如果要更新符合条件的所有文档，要把 multi设为真值，并使用$set 指令： > db.drivers.update({age:{$gt:25}},{$set:{license:'A'}},{multi: true}) > db.drivers.update({age:{$lt:25}},{$set:{license:'C'}},{multi: true}) 如果不想传入multi参数，可以用 db.collection.updateOne() db.collection.updateMany() 对单个字段进行修改 2) 采用$set来根据查询条件修改文档，用来指定一个键的值，如果不存在则创建它。 > db.orders.update( {\"onumber\" : \"001\"}, { $set: { \"cname \" : \"zcy\"} }, false, true ) multi设置为true，全部更新 3） $mul 将该字段的值乘以指定的值 语法： { $mul: { field: } } >db. orders.update( {\"ino\" : \"001\"}, { $mul: {\"quantity\" :3} } ) 修改之前： >db. orders.insert({ \"ino\" : \"001\", \"quantity\": 2, \"price\" : 4.0 } 修改之后： 4）$setOnInsert 操作时,操作给相应的字段赋值 语法： db.collection.update( , {$setOnInsert: { : , ... } }, {upsert: true } ) 对数组进行修改 （1）根据查询条件修改文档里内嵌文档（第二层级的），例如我们想修改items 字段ino为001下的price的4修改8,语法items.$. price ，更新数组中第一个匹配的子文档，我们内嵌文档的ino是唯一的，满足我们的需求 >db. orders.update( {\"onumber\" : \"001\",\"items.ino\":\"001\"}, { $set: {\"items.$.price\" : 8.0} } ) 修改前的数据： 修改后的数据： （2）根据查询条件修改文档里内嵌文档在内嵌文档（第三层级的），例如我们想修改items 字段ino等于001下的products并且pno等于001的pName值为ps,语法items.0. products.$. pName,0代表items第一个数组（也就是数组的下标），$ 更新数组中第一个匹配的子文档。 >db. orders.update( {\"onumber\" : \"001\",\"items.ino\":\"001\",\"items.products.pno\":\"001\"}, { $set: {\"items.0.products.$.pName\": \"ps\"} } ) （3）$pop删除数组的第一个或最后一个项 语法： { $pop: { : ,... } } 1最后一项 -1是第一项 >db. orders.update( {\"onumber\" : \"001\"}, { $pop: {\"items\" : -1} } ) （4）$push将值添加到数组中，如果有的数组存在则向数组末尾添加该值，如果数组不存在则创建该数组并保存该值 语法： { $push: { : ,... } } >db. orders.update( {\"onumber\" : \"001\"}, { $push: {\"items\" : { \"ino\" : \"002\", \"quantity\" :2, \"price\" : 6.0, \"products\" : [ { \"pno\":\"003\", \"pName\":\"p3\" }, { \"pno\":\"004\", \"pName\":\"p4\" } ] } } } ) MongoDb删除数据 MongoDB 提供了 delete 方法删除文档： db.collection.deleteOne()删除最多一个符合条件的文档 db.collection.deleteMany()删除所有符合条件的文档 db.collection.remove() 删除一个或多个文档 MongoDB 聚合Group 关闭实例 关闭 mongoDB 服务： > use admin > db.shutdownServer() 使用 exit 或 Ctrl + C 断开连接: > exit 参考： MongoDb 快速入门教程 简明 MongoDB 入门教程 Update time： 2020-05-25 "},"Chapter5/Python操作MongoDB.html":{"url":"Chapter5/Python操作MongoDB.html","title":"python Python操作MongoDB","keywords":"","body":"python Python操作MongoDB ﻿Python 3下MongoDB的存储操作。 在开始之前，请确保已经安装好了MongoDB并启动了其服务，并且安装好了Python的PyMongo库。 2. 连接MongoDB 连接MongoDB时，我们需要使用PyMongo库里面MongoClient。一般来说，传入MongoDB的IP及端口即可，其中第一个参数为地址host，第二个参数为端口port（如果不给它传递参数，默认是27017）： import pymongo client = pymongo.MongoClient(host='localhost', port=27017) 这样就可以创建MongoDB的连接对象了。 3. 指定数据库 MongoDB中可以建立多个数据库，接下来我们需要指定操作哪个数据库。这里我们以test数据库为例来说明，下一步需要在程序中指定要使用的数据库： db = client.test 这里调用client的test属性即可返回test数据库。当然，我们也可以这样指定： db = client['test'] 4. 指定集合 MongoDB的每个数据库又包含许多集合（collection），它们类似于关系型数据库中的表。 下一步需要指定要操作的集合，这里指定一个集合名称为students。与指定数据库类似，指定集合也有两种方式： collection = db.students collection = db['students'] 5. 插入数据 接下来，便可以插入数据了。对于students这个集合，新建一条学生数据，这条数据以字典形式表示： student = { 'id': '20170101', 'name': 'Jordan', 'age': 20, 'gender': 'male' } 这里指定了学生的学号、姓名、年龄和性别。接下来，直接调用collection的insert()方法即可插入数据，代码如下： result = collection.insert(student) print(result) 在MongoDB中，每条数据其实都有一个_id属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个ObjectId类型的_id属性。insert()方法会在执行后返回_id值。 也可以同时插入多条数据，只需要以列表形式传递即可，示例如下： student1 = { 'id': '20170101', 'name': 'Jordan', 'age': 20, 'gender': 'male' } student2 = { 'id': '20170202', 'name': 'Mike', 'age': 21, 'gender': 'male' } result = collection.insert([student1, student2]) print(result) 返回结果是对应的_id的集合： 在PyMongo 3.x版本中，官方已经不推荐使用insert()方法了。当然，继续使用也没有什么问题。官方推荐使用insert_one()和insert_many()方法来分别插入单条记录和多条记录，示例如下： student = { 'id': '20170101', 'name': 'Jordan', 'age': 20, 'gender': 'male' } result = collection.insert_one(student) print(result) print(result.inserted_id) 调用其inserted_id属性获取_id。 对于insert_many()方法，我们可以将数据以列表形式传递，示例如下： student1 = { 'id': '20170101', 'name': 'Jordan', 'age': 20, 'gender': 'male' } student2 = { 'id': '20170202', 'name': 'Mike', 'age': 21, 'gender': 'male' } result = collection.insert_many([student1, student2]) print(result) print(result.inserted_ids) 调用inserted_ids属性可以获取插入数据的_id列表。 python使用pymongo访问MongoDB的基本操作，以及CSV文件导出 # coding:utf-8 import pymongo class MongoDB: def __init__(self,db,collections): \"\"\" 初始化数据库 :param db:数据库名称 :param collections: 数据库的集合的名称 \"\"\" self.client = pymongo.MongoClient('localhost', 27017) #获取的连接 self.db = self.client[db] #创建数据库db self.post = self.db[collections] #创建或者选择要操作的集合 def update(self, data,upsert): \"\"\" 更新数据库中的数据，如果upsert为Ture，那么当没有找到指定的数据时就直接插入，反之不执行插入 :param data: 要插入的数据 :param upsert: 判断是插入还是不插入 :return: \"\"\" self.post.update({\"ip\": data}, {'$set': {'ip': data}} , upsert) def find(self,select): \"\"\" 根据传入的参数查找指定的值，注意这里的select是字典 :param select: 指定的查找条件，这里的是字典类型的，比如{\"name\":\"chenjiabing\",\"age\":22} :return: 返回的是查询的结果，同样是字典类型的 \"\"\" return self.post.find(select) def insert(self,data): \"\"\" 向数据库中插入指定的数据 :param data: 要插入的数据，这里的是字典的类型比如：{\"name\":\"chenjiabing\",\"age\":22} :return: 插入成功返回True,反之返回false \"\"\" try: self.post.insert(data) return True except: return False def remove(self,select): \"\"\" 删除指定条件的记录 :param select: 指定的条件，这里是字典类型的，比如{\"age\":22} 表示删除age=22的所有数据 :return: 如果删除成功返回True，else返回False \"\"\" try: self.post.remove(select) return True except: return False # coding:utf-8 import requests from bs4 import BeautifulSoup import time from Queue import Queue import threading from Mongo import MongoDB #导入文件 class XICI: def __init__(self, page): \"\"\" self.header:请求头 self.q:存储ip的队列 slef.urls:页面的url :param page:传入的参数，表示获取多少页的ip \"\"\" self.header = {\"User-Agent\": 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0'} self.q = Queue() self.urls = [] for i in range(1, page + 1): self.urls.append(\"http://www.xicidaili.com/nn/\" + str(i)) self.mongo = MongoDB('python','ip') # 创建MogoDB对象 def get_ips(self, url): \"\"\" 根据一页的请求爬取一个页面的ip :param url:传入的参数，表示每一页的链接 :return: None \"\"\" try: res = requests.get(url, headers=self.header) if res.status_code == 200: soup = BeautifulSoup(res.text, 'lxml') ips = soup.find_all('tr') for i in range(1, len(ips)): ip = ips[i] tds = ip.find_all(\"td\") ip_temp = \"http://\" + tds[1].contents[0] + \":\" + tds[2].contents[0] print ip_temp self.q.put(ip_temp) # ip进入队列 except: print \"-------------------------------------------请求出现异常------------------------------------------------\" def insert(self, url): \"\"\" 验证出过来的ip，如果成功就直接存入数据库 :param url: 验证ip地址的url :return: 无返回值 \"\"\" while not self.q.empty(): ip = self.q.get() proxy = {\"http\": ip} print proxy try: res = requests.get(url, headers=self.header, proxies=proxy, timeout=5) if res.status_code == 200: self.mongo.update(ip,True) # 如果成功验证直接进入数据库 print \"**************************成功存入数据库********************************************\" else: print \"这个ip地址不能用\" except: print \"--------------------------请求失败---------------------------------------------\" def main(self): for url in self.urls: self.get_ips(url) threads = [] for i in range(5): t=threading.Thread(target=self.insert,args=[\"http://blog.csdn.net/qq_34162294/article/details/72353389\"]) threads.append(t) for t in threads: t.start() if __name__ == '__main__': p = XICI(3) p.main() Update time： 2020-05-25 "}}