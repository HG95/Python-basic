# python 正则表达式 去优先级，选择

## 选择

用圆括号将所有选择项括起来，相邻的选择项之间用`|`分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 `?:` 放在第一个选项前来消除这种副作用。

其中 `?:` 是非捕获元之一，还有两个非捕获元是 `?=` 和 `?!`，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。


## 去优先级

```python
import re

ret = re.findall('www.(baidu|oldboy).com', 'www.oldboy.com')
print(ret)  # ['oldboy']     这是因为findall会优先把匹配结果组里内容返回,如果想要匹配结果,取消权限即可

ret = re.findall('www.(?:baidu|oldboy).com', 'www.oldboy.com')
print(ret)  # ['www.oldboy.com']

```

```python
import re 
pattern_0 = re.compile(r'(.*?(省|自治区|特别行政区|市))')
pattern_1 = re.compile(r'(.*?(?:省|自治区|特别行政区|市))')
s = '江苏省苏州市虎丘区马涧路靠近白马涧花园'
result_0 = re.search(pattern_0, s).groups()
result_1 = re.search(pattern_1, s).groups()

In[242]: result_0
Out[242]: ('江苏省', '省')
In[243]: result_1
Out[243]: ('江苏省',)


```

result_0中的分组结果中有两个元素，而第二个元素‘省’不是我们需要的，所以在pattern_1的括号中增加 `?:` ， 也就是(`?:`省|自治区|特别行政区|市)， 这样，括号中的内容就不会被捕获。



## 反向引用

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用` \n` 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。

可以使用非捕获元字符` ?:`、`?= `或` ?! `来重写捕获，忽略对相关匹配的保存。

正则表达式中，放在圆括号`()`中的表示是一个组。然后你可以对整个组使用一些正则操作,例如重复操作符。

要注意的是, 只有圆括号`()`才能用于形成组。”“用于定义字符集。”{}”用于定义重复操作。

当用`()`定义了一个正则表达式组后, 正则引擎则会把被匹配的组按照顺序编号,存入缓存。这样我们想在后面对已经匹配过的内容进行引用时，就可以用`\数字` 的方式或者是通过命名分组进行`(?P=name)` 进行引用。`\1` 表示引用第一个分组， `\2`引用第二个分组,以此类推， `\n`引用第 n 个组。而 `\0` 则引用整个被匹配的正则表达式本身。这些引用都必须是在正则表达式中才有效，用于匹配一些重复的字符串。

```python
#通过命名分组进行后向引用
>>> re.search(r'(?P<name>go)\s+(?P=name)\s+(?P=name)', 'go go go').group('name')
'go'
#通过默认分组编号进行后向引用
>>> re.search(r'(go)\s+\1\s+\1', 'go go go').group()
'go go go'



```



